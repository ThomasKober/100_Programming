//------------------------------------------------------------------------------
// <auto-generated>
//     This file was generated by cswinrt.exe version 2.3.0-prerelease.250720.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq.Expressions;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using WinRT;
using WinRT.Interop;


#pragma warning disable 0169 // warning CS0169: The field '...' is never used
#pragma warning disable 0649 // warning CS0169: Field '...' is never assigned to
#pragma warning disable CA2207, CA1063, CA1033, CA1001, CA2213

namespace Windows.Storage.Streams
{
    [global::WinRT.WindowsRuntimeType("Windows.Foundation.UniversalApiContract")]
    [global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Windows.Storage.Streams.Buffer))]
    [global::ABI.Windows.Storage.Streams.BufferRcwFactory]
    [global::WinRT.ProjectedRuntimeClass(typeof(IBuffer))]
    [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    public sealed class Buffer : IBuffer, global::System.Runtime.InteropServices.ICustomQueryInterface, IWinRTObject, IEquatable<Buffer>
    {
        private IntPtr ThisPtr => _inner == null ? (((IWinRTObject)this).NativeObject).ThisPtr : _inner.ThisPtr;

        private readonly IObjectReference _inner = null;



        private IObjectReference _objRef_global__Windows_Storage_Streams_IBuffer => _inner;


        private static class _IBufferFactoryMethods
        {
            public static unsafe IntPtr Create(IObjectReference _obj, uint capacity)
            {
                var ThisPtr = _obj.ThisPtr;

                IntPtr __retval = default;
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, uint, IntPtr*, int>**)ThisPtr)[6](ThisPtr, capacity, &__retval));
                global::System.GC.KeepAlive(_obj);
                return __retval;
            }
        }

        private static volatile IObjectReference ___objRef_global__Windows_Storage_Streams_IBufferFactory;
        private static IObjectReference _objRef_global__Windows_Storage_Streams_IBufferFactory
        {
            get
            { 
                var factory = ___objRef_global__Windows_Storage_Streams_IBufferFactory;
                if (factory != null && factory.IsInCurrentContext)
                {
                    return factory;
                }
                else
                {
                    return ___objRef_global__Windows_Storage_Streams_IBufferFactory = ActivationFactory.Get("Windows.Storage.Streams.Buffer", global::ABI.Windows.Storage.Streams.IBufferFactoryMethods.IID);
                }
            }
        }

        public Buffer(uint capacity) 
        { 
        IntPtr ptr = (_IBufferFactoryMethods.Create(_objRef_global__Windows_Storage_Streams_IBufferFactory, capacity)); 
        try 
        { 
        _inner = ComWrappersSupport.GetObjectReferenceForInterface(ptr, global::ABI.Windows.Storage.Streams.IBufferMethods.IID, false); 

        } 
        finally 
        { 
        MarshalInspectable<object>.DisposeAbi(ptr); 
        }

        ComWrappersSupport.RegisterObjectForInterface(this, ThisPtr);
        ComWrappersHelper.Init(_inner, false);
        }

        public static I As<I>() => ActivationFactory.Get("Windows.Storage.Streams.Buffer").AsInterface<I>();

        private static volatile IObjectReference ___objRef_global__Windows_Storage_Streams_IBufferStatics;
        private static IObjectReference _objRef_global__Windows_Storage_Streams_IBufferStatics
        {
            get
            { 
                var factory = ___objRef_global__Windows_Storage_Streams_IBufferStatics;
                if (factory != null && factory.IsInCurrentContext)
                {
                    return factory;
                }
                else
                {
                    return ___objRef_global__Windows_Storage_Streams_IBufferStatics = ActivationFactory.Get("Windows.Storage.Streams.Buffer", global::ABI.Windows.Storage.Streams.IBufferStaticsMethods.IID);
                }
            }
        }

        public static Buffer CreateCopyFromMemoryBuffer(global::Windows.Foundation.IMemoryBuffer input) => global::ABI.Windows.Storage.Streams.IBufferStaticsMethods.CreateCopyFromMemoryBuffer(_objRef_global__Windows_Storage_Streams_IBufferStatics, input);

        public static global::Windows.Foundation.MemoryBuffer CreateMemoryBufferOverIBuffer(IBuffer input) => global::ABI.Windows.Storage.Streams.IBufferStaticsMethods.CreateMemoryBufferOverIBuffer(_objRef_global__Windows_Storage_Streams_IBufferStatics, input);

        public static Buffer FromAbi(IntPtr thisPtr)
        {
            if (thisPtr == IntPtr.Zero) return null;
            return MarshalInspectable<Buffer>.FromAbi(thisPtr);
        }

        internal Buffer(IObjectReference objRef)
        {
            _inner = objRef.As(global::ABI.Windows.Storage.Streams.IBufferMethods.IID);

        }


        public static bool operator ==(Buffer x, Buffer y) => (x?.ThisPtr ?? IntPtr.Zero) == (y?.ThisPtr ?? IntPtr.Zero);
        public static bool operator !=(Buffer x, Buffer y) => !(x == y);
        public bool Equals(Buffer other) => this == other;
        public override bool Equals(object obj) => obj is Buffer that && this == that;
        public override int GetHashCode() => ThisPtr.GetHashCode();


        bool IWinRTObject.HasUnwrappableNativeObject => true;
        IObjectReference IWinRTObject.NativeObject => _inner;
        private volatile global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> _queryInterfaceCache;
        private global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> MakeQueryInterfaceCache()
        {
            global::System.Threading.Interlocked.CompareExchange(ref _queryInterfaceCache, new global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference>(), null); 
            return _queryInterfaceCache;
        }
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache => _queryInterfaceCache ?? MakeQueryInterfaceCache();
        private volatile global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> _additionalTypeData;
        private global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> MakeAdditionalTypeData()
        {
            global::System.Threading.Interlocked.CompareExchange(ref _additionalTypeData, new global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object>(), null); 
            return _additionalTypeData;
        }
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData => _additionalTypeData ?? MakeAdditionalTypeData();

        private struct InterfaceTag<I>{};


        public uint Capacity => global::ABI.Windows.Storage.Streams.IBufferMethods.get_Capacity(_objRef_global__Windows_Storage_Streams_IBuffer);

        public uint Length
        {
            get => global::ABI.Windows.Storage.Streams.IBufferMethods.get_Length(_objRef_global__Windows_Storage_Streams_IBuffer);
            set => global::ABI.Windows.Storage.Streams.IBufferMethods.set_Length(_objRef_global__Windows_Storage_Streams_IBuffer, value);
        }

        private bool IsOverridableInterface(Guid iid) => false;

        global::System.Runtime.InteropServices.CustomQueryInterfaceResult global::System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(ref Guid iid, out IntPtr ppv)
        {
            ppv = IntPtr.Zero;
            if (IsOverridableInterface(iid) || global::WinRT.Interop.IID.IID_IInspectable == iid || global::WinRT.Interop.IID.IID_IWeakReferenceSource == iid)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
            }

            if (((IWinRTObject)this).NativeObject.TryAs(iid, out ppv) >= 0)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.Handled;
            }

            return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
        }
    }
    [global::WinRT.WindowsRuntimeType("Windows.Foundation.UniversalApiContract")][global::WinRT.WinRTExposedType(typeof(global::WinRT.EnumTypeDetails<ByteOrder>))][global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    public enum ByteOrder : int
    {
        LittleEndian = unchecked((int)0),
        BigEndian = unchecked((int)0x1),
    }
    [global::WinRT.WindowsRuntimeType("Windows.Foundation.UniversalApiContract")]
    [global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Windows.Storage.Streams.DataReader))]
    [global::ABI.Windows.Storage.Streams.DataReaderRcwFactory]
    [global::WinRT.ProjectedRuntimeClass(typeof(IDataReader))]
    [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    public sealed class DataReader : IDataReader, global::System.IDisposable, global::System.Runtime.InteropServices.ICustomQueryInterface, IWinRTObject, IEquatable<DataReader>
    {
        private IntPtr ThisPtr => _inner == null ? (((IWinRTObject)this).NativeObject).ThisPtr : _inner.ThisPtr;

        private readonly IObjectReference _inner = null;



        private IObjectReference _objRef_global__Windows_Storage_Streams_IDataReader => _inner;
        private volatile IObjectReference ___objRef_global__System_IDisposable;
        private IObjectReference Make___objRef_global__System_IDisposable()
        {
            global::System.Threading.Interlocked.CompareExchange(ref ___objRef_global__System_IDisposable, ((IWinRTObject)this).NativeObject.As<IUnknownVftbl>(global::ABI.System.IDisposableMethods.IID), null);
            return ___objRef_global__System_IDisposable;
        }
        private IObjectReference _objRef_global__System_IDisposable => ___objRef_global__System_IDisposable ?? Make___objRef_global__System_IDisposable();



        private static class _IDataReaderFactoryMethods
        {
            public static unsafe IntPtr CreateDataReader(IObjectReference _obj, IInputStream inputStream)
            {
                var ThisPtr = _obj.ThisPtr;

                ObjectReferenceValue __inputStream = default;
                IntPtr __retval = default;
                try
                {
                    __inputStream = MarshalInterface<IInputStream>.CreateMarshaler2(inputStream, global::ABI.Windows.Storage.Streams.IInputStreamMethods.IID);
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr*, int>**)ThisPtr)[6](ThisPtr, MarshalInspectable<object>.GetAbi(__inputStream), &__retval));
                    global::System.GC.KeepAlive(_obj);
                    return __retval;
                }
                finally
                {
                    MarshalInspectable<object>.DisposeMarshaler(__inputStream);
                }
            }
        }

        private static volatile IObjectReference ___objRef_global__Windows_Storage_Streams_IDataReaderFactory;
        private static IObjectReference _objRef_global__Windows_Storage_Streams_IDataReaderFactory
        {
            get
            { 
                var factory = ___objRef_global__Windows_Storage_Streams_IDataReaderFactory;
                if (factory != null && factory.IsInCurrentContext)
                {
                    return factory;
                }
                else
                {
                    return ___objRef_global__Windows_Storage_Streams_IDataReaderFactory = ActivationFactory.Get("Windows.Storage.Streams.DataReader", global::ABI.Windows.Storage.Streams.IDataReaderFactoryMethods.IID);
                }
            }
        }

        public DataReader(IInputStream inputStream) 
        { 
        IntPtr ptr = (_IDataReaderFactoryMethods.CreateDataReader(_objRef_global__Windows_Storage_Streams_IDataReaderFactory, inputStream)); 
        try 
        { 
        _inner = ComWrappersSupport.GetObjectReferenceForInterface(ptr, global::ABI.Windows.Storage.Streams.IDataReaderMethods.IID, false); 

        } 
        finally 
        { 
        MarshalInspectable<object>.DisposeAbi(ptr); 
        }

        ComWrappersSupport.RegisterObjectForInterface(this, ThisPtr);
        ComWrappersHelper.Init(_inner, false);
        }

        public static I As<I>() => ActivationFactory.Get("Windows.Storage.Streams.DataReader").AsInterface<I>();

        private static volatile IObjectReference ___objRef_global__Windows_Storage_Streams_IDataReaderStatics;
        private static IObjectReference _objRef_global__Windows_Storage_Streams_IDataReaderStatics
        {
            get
            { 
                var factory = ___objRef_global__Windows_Storage_Streams_IDataReaderStatics;
                if (factory != null && factory.IsInCurrentContext)
                {
                    return factory;
                }
                else
                {
                    return ___objRef_global__Windows_Storage_Streams_IDataReaderStatics = ActivationFactory.Get("Windows.Storage.Streams.DataReader", global::ABI.Windows.Storage.Streams.IDataReaderStaticsMethods.IID);
                }
            }
        }

        public static DataReader FromBuffer(IBuffer buffer) => global::ABI.Windows.Storage.Streams.IDataReaderStaticsMethods.FromBuffer(_objRef_global__Windows_Storage_Streams_IDataReaderStatics, buffer);

        public static DataReader FromAbi(IntPtr thisPtr)
        {
            if (thisPtr == IntPtr.Zero) return null;
            return MarshalInspectable<DataReader>.FromAbi(thisPtr);
        }

        internal DataReader(IObjectReference objRef)
        {
            _inner = objRef.As(global::ABI.Windows.Storage.Streams.IDataReaderMethods.IID);

        }


        public static bool operator ==(DataReader x, DataReader y) => (x?.ThisPtr ?? IntPtr.Zero) == (y?.ThisPtr ?? IntPtr.Zero);
        public static bool operator !=(DataReader x, DataReader y) => !(x == y);
        public bool Equals(DataReader other) => this == other;
        public override bool Equals(object obj) => obj is DataReader that && this == that;
        public override int GetHashCode() => ThisPtr.GetHashCode();


        bool IWinRTObject.HasUnwrappableNativeObject => true;
        IObjectReference IWinRTObject.NativeObject => _inner;
        private volatile global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> _queryInterfaceCache;
        private global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> MakeQueryInterfaceCache()
        {
            global::System.Threading.Interlocked.CompareExchange(ref _queryInterfaceCache, new global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference>(), null); 
            return _queryInterfaceCache;
        }
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache => _queryInterfaceCache ?? MakeQueryInterfaceCache();
        private volatile global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> _additionalTypeData;
        private global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> MakeAdditionalTypeData()
        {
            global::System.Threading.Interlocked.CompareExchange(ref _additionalTypeData, new global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object>(), null); 
            return _additionalTypeData;
        }
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData => _additionalTypeData ?? MakeAdditionalTypeData();

        private struct InterfaceTag<I>{};


        public byte ReadByte() => global::ABI.Windows.Storage.Streams.IDataReaderMethods.ReadByte(_objRef_global__Windows_Storage_Streams_IDataReader);

        public void ReadBytes(byte[] value) => global::ABI.Windows.Storage.Streams.IDataReaderMethods.ReadBytes(_objRef_global__Windows_Storage_Streams_IDataReader, value);

        public IBuffer ReadBuffer(uint length) => global::ABI.Windows.Storage.Streams.IDataReaderMethods.ReadBuffer(_objRef_global__Windows_Storage_Streams_IDataReader, length);

        public bool ReadBoolean() => global::ABI.Windows.Storage.Streams.IDataReaderMethods.ReadBoolean(_objRef_global__Windows_Storage_Streams_IDataReader);

        public Guid ReadGuid() => global::ABI.Windows.Storage.Streams.IDataReaderMethods.ReadGuid(_objRef_global__Windows_Storage_Streams_IDataReader);

        public short ReadInt16() => global::ABI.Windows.Storage.Streams.IDataReaderMethods.ReadInt16(_objRef_global__Windows_Storage_Streams_IDataReader);

        public int ReadInt32() => global::ABI.Windows.Storage.Streams.IDataReaderMethods.ReadInt32(_objRef_global__Windows_Storage_Streams_IDataReader);

        public long ReadInt64() => global::ABI.Windows.Storage.Streams.IDataReaderMethods.ReadInt64(_objRef_global__Windows_Storage_Streams_IDataReader);

        public ushort ReadUInt16() => global::ABI.Windows.Storage.Streams.IDataReaderMethods.ReadUInt16(_objRef_global__Windows_Storage_Streams_IDataReader);

        public uint ReadUInt32() => global::ABI.Windows.Storage.Streams.IDataReaderMethods.ReadUInt32(_objRef_global__Windows_Storage_Streams_IDataReader);

        public ulong ReadUInt64() => global::ABI.Windows.Storage.Streams.IDataReaderMethods.ReadUInt64(_objRef_global__Windows_Storage_Streams_IDataReader);

        public float ReadSingle() => global::ABI.Windows.Storage.Streams.IDataReaderMethods.ReadSingle(_objRef_global__Windows_Storage_Streams_IDataReader);

        public double ReadDouble() => global::ABI.Windows.Storage.Streams.IDataReaderMethods.ReadDouble(_objRef_global__Windows_Storage_Streams_IDataReader);

        public string ReadString(uint codeUnitCount) => global::ABI.Windows.Storage.Streams.IDataReaderMethods.ReadString(_objRef_global__Windows_Storage_Streams_IDataReader, codeUnitCount);

        public global::System.DateTimeOffset ReadDateTime() => global::ABI.Windows.Storage.Streams.IDataReaderMethods.ReadDateTime(_objRef_global__Windows_Storage_Streams_IDataReader);

        public global::System.TimeSpan ReadTimeSpan() => global::ABI.Windows.Storage.Streams.IDataReaderMethods.ReadTimeSpan(_objRef_global__Windows_Storage_Streams_IDataReader);

        public DataReaderLoadOperation LoadAsync(uint count) => global::ABI.Windows.Storage.Streams.IDataReaderMethods.LoadAsync(_objRef_global__Windows_Storage_Streams_IDataReader, count);

        public IBuffer DetachBuffer() => global::ABI.Windows.Storage.Streams.IDataReaderMethods.DetachBuffer(_objRef_global__Windows_Storage_Streams_IDataReader);

        public IInputStream DetachStream() => global::ABI.Windows.Storage.Streams.IDataReaderMethods.DetachStream(_objRef_global__Windows_Storage_Streams_IDataReader);

        public void Dispose() => global::ABI.System.IDisposableMethods.Dispose(_objRef_global__System_IDisposable);

        public ByteOrder ByteOrder
        {
            get => global::ABI.Windows.Storage.Streams.IDataReaderMethods.get_ByteOrder(_objRef_global__Windows_Storage_Streams_IDataReader);
            set => global::ABI.Windows.Storage.Streams.IDataReaderMethods.set_ByteOrder(_objRef_global__Windows_Storage_Streams_IDataReader, value);
        }

        public InputStreamOptions InputStreamOptions
        {
            get => global::ABI.Windows.Storage.Streams.IDataReaderMethods.get_InputStreamOptions(_objRef_global__Windows_Storage_Streams_IDataReader);
            set => global::ABI.Windows.Storage.Streams.IDataReaderMethods.set_InputStreamOptions(_objRef_global__Windows_Storage_Streams_IDataReader, value);
        }

        public uint UnconsumedBufferLength => global::ABI.Windows.Storage.Streams.IDataReaderMethods.get_UnconsumedBufferLength(_objRef_global__Windows_Storage_Streams_IDataReader);

        public UnicodeEncoding UnicodeEncoding
        {
            get => global::ABI.Windows.Storage.Streams.IDataReaderMethods.get_UnicodeEncoding(_objRef_global__Windows_Storage_Streams_IDataReader);
            set => global::ABI.Windows.Storage.Streams.IDataReaderMethods.set_UnicodeEncoding(_objRef_global__Windows_Storage_Streams_IDataReader, value);
        }

        private bool IsOverridableInterface(Guid iid) => false;

        global::System.Runtime.InteropServices.CustomQueryInterfaceResult global::System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(ref Guid iid, out IntPtr ppv)
        {
            ppv = IntPtr.Zero;
            if (IsOverridableInterface(iid) || global::WinRT.Interop.IID.IID_IInspectable == iid || global::WinRT.Interop.IID.IID_IWeakReferenceSource == iid)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
            }

            if (((IWinRTObject)this).NativeObject.TryAs(iid, out ppv) >= 0)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.Handled;
            }

            return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
        }
    }
    [global::WinRT.WindowsRuntimeType("Windows.Foundation.UniversalApiContract")]
    [global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Windows.Storage.Streams.DataReaderLoadOperation))]
    [global::ABI.Windows.Storage.Streams.DataReaderLoadOperationRcwFactory]
    [global::WinRT.ProjectedRuntimeClass(typeof(global::Windows.Foundation.IAsyncOperation<uint>))]
    [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    public sealed class DataReaderLoadOperation : global::Windows.Foundation.IAsyncOperation<uint>, global::Windows.Foundation.IAsyncInfo, global::System.Runtime.InteropServices.ICustomQueryInterface, IWinRTObject, IEquatable<DataReaderLoadOperation>
    {
        private IntPtr ThisPtr => _inner == null ? (((IWinRTObject)this).NativeObject).ThisPtr : _inner.ThisPtr;

        private readonly IObjectReference _inner = null;




        private volatile IObjectReference ___objRef_global__Windows_Foundation_IAsyncOperation_uint_;
        private IObjectReference Make___objRef_global__Windows_Foundation_IAsyncOperation_uint_()
        {
            _ = global::WinRT.GenericTypeInstantiations.Windows_Foundation_IAsyncOperation_1_UInt32.EnsureInitialized();
            global::System.Threading.Interlocked.CompareExchange(ref ___objRef_global__Windows_Foundation_IAsyncOperation_uint_, ((IWinRTObject)this).NativeObject.As<IUnknownVftbl>(global::ABI.Windows.Foundation.IAsyncOperationMethods<uint>.IID), null);
            return ___objRef_global__Windows_Foundation_IAsyncOperation_uint_;
        }
        private IObjectReference _objRef_global__Windows_Foundation_IAsyncOperation_uint_ => ___objRef_global__Windows_Foundation_IAsyncOperation_uint_ ?? Make___objRef_global__Windows_Foundation_IAsyncOperation_uint_();

        private volatile IObjectReference ___objRef_global__Windows_Foundation_IAsyncInfo;
        private IObjectReference Make___objRef_global__Windows_Foundation_IAsyncInfo()
        {
            global::System.Threading.Interlocked.CompareExchange(ref ___objRef_global__Windows_Foundation_IAsyncInfo, ((IWinRTObject)this).NativeObject.As<IUnknownVftbl>(global::ABI.Windows.Foundation.IAsyncInfoMethods.IID), null);
            return ___objRef_global__Windows_Foundation_IAsyncInfo;
        }
        private IObjectReference _objRef_global__Windows_Foundation_IAsyncInfo => ___objRef_global__Windows_Foundation_IAsyncInfo ?? Make___objRef_global__Windows_Foundation_IAsyncInfo();



        public static DataReaderLoadOperation FromAbi(IntPtr thisPtr)
        {
            if (thisPtr == IntPtr.Zero) return null;
            return MarshalInspectable<DataReaderLoadOperation>.FromAbi(thisPtr);
        }

        internal DataReaderLoadOperation(IObjectReference objRef)
        {
            _inner = objRef.As(global::ABI.Windows.Foundation.IAsyncOperationMethods<uint>.IID);

        }


        public static bool operator ==(DataReaderLoadOperation x, DataReaderLoadOperation y) => (x?.ThisPtr ?? IntPtr.Zero) == (y?.ThisPtr ?? IntPtr.Zero);
        public static bool operator !=(DataReaderLoadOperation x, DataReaderLoadOperation y) => !(x == y);
        public bool Equals(DataReaderLoadOperation other) => this == other;
        public override bool Equals(object obj) => obj is DataReaderLoadOperation that && this == that;
        public override int GetHashCode() => ThisPtr.GetHashCode();


        bool IWinRTObject.HasUnwrappableNativeObject => true;
        IObjectReference IWinRTObject.NativeObject => _inner;
        private volatile global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> _queryInterfaceCache;
        private global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> MakeQueryInterfaceCache()
        {
            global::System.Threading.Interlocked.CompareExchange(ref _queryInterfaceCache, new global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference>(), null); 
            return _queryInterfaceCache;
        }
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache => _queryInterfaceCache ?? MakeQueryInterfaceCache();
        private volatile global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> _additionalTypeData;
        private global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> MakeAdditionalTypeData()
        {
            global::System.Threading.Interlocked.CompareExchange(ref _additionalTypeData, new global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object>(), null); 
            return _additionalTypeData;
        }
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData => _additionalTypeData ?? MakeAdditionalTypeData();

        private struct InterfaceTag<I>{};


        public uint GetResults() => global::ABI.Windows.Foundation.IAsyncOperationMethods<uint>.GetResults(_objRef_global__Windows_Foundation_IAsyncOperation_uint_);

        public void Cancel() => global::ABI.Windows.Foundation.IAsyncInfoMethods.Cancel(_objRef_global__Windows_Foundation_IAsyncInfo);

        public void Close() => global::ABI.Windows.Foundation.IAsyncInfoMethods.Close(_objRef_global__Windows_Foundation_IAsyncInfo);

        public global::Windows.Foundation.AsyncOperationCompletedHandler<uint> Completed
        {
            get => global::ABI.Windows.Foundation.IAsyncOperationMethods<uint>.get_Completed(_objRef_global__Windows_Foundation_IAsyncOperation_uint_);
            set => global::ABI.Windows.Foundation.IAsyncOperationMethods<uint>.set_Completed(_objRef_global__Windows_Foundation_IAsyncOperation_uint_, value);
        }

        public global::System.Exception ErrorCode => global::ABI.Windows.Foundation.IAsyncInfoMethods.get_ErrorCode(_objRef_global__Windows_Foundation_IAsyncInfo);

        public uint Id => global::ABI.Windows.Foundation.IAsyncInfoMethods.get_Id(_objRef_global__Windows_Foundation_IAsyncInfo);

        public global::Windows.Foundation.AsyncStatus Status => global::ABI.Windows.Foundation.IAsyncInfoMethods.get_Status(_objRef_global__Windows_Foundation_IAsyncInfo);

        private bool IsOverridableInterface(Guid iid) => false;

        global::System.Runtime.InteropServices.CustomQueryInterfaceResult global::System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(ref Guid iid, out IntPtr ppv)
        {
            ppv = IntPtr.Zero;
            if (IsOverridableInterface(iid) || global::WinRT.Interop.IID.IID_IInspectable == iid || global::WinRT.Interop.IID.IID_IWeakReferenceSource == iid)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
            }

            if (((IWinRTObject)this).NativeObject.TryAs(iid, out ppv) >= 0)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.Handled;
            }

            return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
        }
    }
    [global::WinRT.WindowsRuntimeType("Windows.Foundation.UniversalApiContract")]
    [global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Windows.Storage.Streams.DataWriter))]
    [global::ABI.Windows.Storage.Streams.DataWriterRcwFactory]
    [global::WinRT.ProjectedRuntimeClass(typeof(IDataWriter))]
    [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    public sealed class DataWriter : IDataWriter, global::System.IDisposable, global::System.Runtime.InteropServices.ICustomQueryInterface, IWinRTObject, IEquatable<DataWriter>
    {
        private IntPtr ThisPtr => _inner == null ? (((IWinRTObject)this).NativeObject).ThisPtr : _inner.ThisPtr;

        private readonly IObjectReference _inner = null;



        private IObjectReference _objRef_global__Windows_Storage_Streams_IDataWriter => _inner;
        private volatile IObjectReference ___objRef_global__System_IDisposable;
        private IObjectReference Make___objRef_global__System_IDisposable()
        {
            global::System.Threading.Interlocked.CompareExchange(ref ___objRef_global__System_IDisposable, ((IWinRTObject)this).NativeObject.As<IUnknownVftbl>(global::ABI.System.IDisposableMethods.IID), null);
            return ___objRef_global__System_IDisposable;
        }
        private IObjectReference _objRef_global__System_IDisposable => ___objRef_global__System_IDisposable ?? Make___objRef_global__System_IDisposable();



        private static volatile IObjectReference ___objRef_global__Windows_Storage_Streams_DataWriter;
        private static IObjectReference _objRef_global__Windows_Storage_Streams_DataWriter
        {
            get
            { 
                var factory = ___objRef_global__Windows_Storage_Streams_DataWriter;
                if (factory != null && factory.IsInCurrentContext)
                {
                    return factory;
                }
                else
                {
                    return ___objRef_global__Windows_Storage_Streams_DataWriter = ActivationFactory.Get("Windows.Storage.Streams.DataWriter");
                }
            }
        }

        public DataWriter() 
        {
            _inner = global::ABI.WinRT.Interop.IActivationFactoryMethods.ActivateInstanceUnsafe(_objRef_global__Windows_Storage_Streams_DataWriter, global::ABI.Windows.Storage.Streams.IDataWriterMethods.IID);
            ComWrappersSupport.RegisterObjectForInterface(this, ThisPtr);
            ComWrappersHelper.Init(_inner, false);

        }

        private static class _IDataWriterFactoryMethods
        {
            public static unsafe IntPtr CreateDataWriter(IObjectReference _obj, IOutputStream outputStream)
            {
                var ThisPtr = _obj.ThisPtr;

                ObjectReferenceValue __outputStream = default;
                IntPtr __retval = default;
                try
                {
                    __outputStream = MarshalInterface<IOutputStream>.CreateMarshaler2(outputStream, global::ABI.Windows.Storage.Streams.IOutputStreamMethods.IID);
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr*, int>**)ThisPtr)[6](ThisPtr, MarshalInspectable<object>.GetAbi(__outputStream), &__retval));
                    global::System.GC.KeepAlive(_obj);
                    return __retval;
                }
                finally
                {
                    MarshalInspectable<object>.DisposeMarshaler(__outputStream);
                }
            }
        }

        private static volatile IObjectReference ___objRef_global__Windows_Storage_Streams_IDataWriterFactory;
        private static IObjectReference _objRef_global__Windows_Storage_Streams_IDataWriterFactory
        {
            get
            { 
                var factory = ___objRef_global__Windows_Storage_Streams_IDataWriterFactory;
                if (factory != null && factory.IsInCurrentContext)
                {
                    return factory;
                }
                else
                {
                    return ___objRef_global__Windows_Storage_Streams_IDataWriterFactory = ActivationFactory.Get("Windows.Storage.Streams.DataWriter", global::ABI.Windows.Storage.Streams.IDataWriterFactoryMethods.IID);
                }
            }
        }

        public DataWriter(IOutputStream outputStream) 
        { 
        IntPtr ptr = (_IDataWriterFactoryMethods.CreateDataWriter(_objRef_global__Windows_Storage_Streams_IDataWriterFactory, outputStream)); 
        try 
        { 
        _inner = ComWrappersSupport.GetObjectReferenceForInterface(ptr, global::ABI.Windows.Storage.Streams.IDataWriterMethods.IID, false); 

        } 
        finally 
        { 
        MarshalInspectable<object>.DisposeAbi(ptr); 
        }

        ComWrappersSupport.RegisterObjectForInterface(this, ThisPtr);
        ComWrappersHelper.Init(_inner, false);
        }

        public static DataWriter FromAbi(IntPtr thisPtr)
        {
            if (thisPtr == IntPtr.Zero) return null;
            return MarshalInspectable<DataWriter>.FromAbi(thisPtr);
        }

        internal DataWriter(IObjectReference objRef)
        {
            _inner = objRef.As(global::ABI.Windows.Storage.Streams.IDataWriterMethods.IID);

        }


        public static bool operator ==(DataWriter x, DataWriter y) => (x?.ThisPtr ?? IntPtr.Zero) == (y?.ThisPtr ?? IntPtr.Zero);
        public static bool operator !=(DataWriter x, DataWriter y) => !(x == y);
        public bool Equals(DataWriter other) => this == other;
        public override bool Equals(object obj) => obj is DataWriter that && this == that;
        public override int GetHashCode() => ThisPtr.GetHashCode();


        bool IWinRTObject.HasUnwrappableNativeObject => true;
        IObjectReference IWinRTObject.NativeObject => _inner;
        private volatile global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> _queryInterfaceCache;
        private global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> MakeQueryInterfaceCache()
        {
            global::System.Threading.Interlocked.CompareExchange(ref _queryInterfaceCache, new global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference>(), null); 
            return _queryInterfaceCache;
        }
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache => _queryInterfaceCache ?? MakeQueryInterfaceCache();
        private volatile global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> _additionalTypeData;
        private global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> MakeAdditionalTypeData()
        {
            global::System.Threading.Interlocked.CompareExchange(ref _additionalTypeData, new global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object>(), null); 
            return _additionalTypeData;
        }
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData => _additionalTypeData ?? MakeAdditionalTypeData();

        private struct InterfaceTag<I>{};


        public void WriteByte(byte value) => global::ABI.Windows.Storage.Streams.IDataWriterMethods.WriteByte(_objRef_global__Windows_Storage_Streams_IDataWriter, value);

        public void WriteBytes(byte[] value) => global::ABI.Windows.Storage.Streams.IDataWriterMethods.WriteBytes(_objRef_global__Windows_Storage_Streams_IDataWriter, value);

        public void WriteBuffer(IBuffer buffer) => global::ABI.Windows.Storage.Streams.IDataWriterMethods.WriteBuffer(_objRef_global__Windows_Storage_Streams_IDataWriter, buffer);

        public void WriteBuffer(IBuffer buffer, uint start, uint count) => global::ABI.Windows.Storage.Streams.IDataWriterMethods.WriteBuffer(_objRef_global__Windows_Storage_Streams_IDataWriter, buffer, start, count);

        public void WriteBoolean(bool value) => global::ABI.Windows.Storage.Streams.IDataWriterMethods.WriteBoolean(_objRef_global__Windows_Storage_Streams_IDataWriter, value);

        public void WriteGuid(Guid value) => global::ABI.Windows.Storage.Streams.IDataWriterMethods.WriteGuid(_objRef_global__Windows_Storage_Streams_IDataWriter, value);

        public void WriteInt16(short value) => global::ABI.Windows.Storage.Streams.IDataWriterMethods.WriteInt16(_objRef_global__Windows_Storage_Streams_IDataWriter, value);

        public void WriteInt32(int value) => global::ABI.Windows.Storage.Streams.IDataWriterMethods.WriteInt32(_objRef_global__Windows_Storage_Streams_IDataWriter, value);

        public void WriteInt64(long value) => global::ABI.Windows.Storage.Streams.IDataWriterMethods.WriteInt64(_objRef_global__Windows_Storage_Streams_IDataWriter, value);

        public void WriteUInt16(ushort value) => global::ABI.Windows.Storage.Streams.IDataWriterMethods.WriteUInt16(_objRef_global__Windows_Storage_Streams_IDataWriter, value);

        public void WriteUInt32(uint value) => global::ABI.Windows.Storage.Streams.IDataWriterMethods.WriteUInt32(_objRef_global__Windows_Storage_Streams_IDataWriter, value);

        public void WriteUInt64(ulong value) => global::ABI.Windows.Storage.Streams.IDataWriterMethods.WriteUInt64(_objRef_global__Windows_Storage_Streams_IDataWriter, value);

        public void WriteSingle(float value) => global::ABI.Windows.Storage.Streams.IDataWriterMethods.WriteSingle(_objRef_global__Windows_Storage_Streams_IDataWriter, value);

        public void WriteDouble(double value) => global::ABI.Windows.Storage.Streams.IDataWriterMethods.WriteDouble(_objRef_global__Windows_Storage_Streams_IDataWriter, value);

        public void WriteDateTime(global::System.DateTimeOffset value) => global::ABI.Windows.Storage.Streams.IDataWriterMethods.WriteDateTime(_objRef_global__Windows_Storage_Streams_IDataWriter, value);

        public void WriteTimeSpan(global::System.TimeSpan value) => global::ABI.Windows.Storage.Streams.IDataWriterMethods.WriteTimeSpan(_objRef_global__Windows_Storage_Streams_IDataWriter, value);

        public uint WriteString(string value) => global::ABI.Windows.Storage.Streams.IDataWriterMethods.WriteString(_objRef_global__Windows_Storage_Streams_IDataWriter, value);

        public uint MeasureString(string value) => global::ABI.Windows.Storage.Streams.IDataWriterMethods.MeasureString(_objRef_global__Windows_Storage_Streams_IDataWriter, value);

        public DataWriterStoreOperation StoreAsync() => global::ABI.Windows.Storage.Streams.IDataWriterMethods.StoreAsync(_objRef_global__Windows_Storage_Streams_IDataWriter);

        public global::Windows.Foundation.IAsyncOperation<bool> FlushAsync() => global::ABI.Windows.Storage.Streams.IDataWriterMethods.FlushAsync(_objRef_global__Windows_Storage_Streams_IDataWriter);

        public IBuffer DetachBuffer() => global::ABI.Windows.Storage.Streams.IDataWriterMethods.DetachBuffer(_objRef_global__Windows_Storage_Streams_IDataWriter);

        public IOutputStream DetachStream() => global::ABI.Windows.Storage.Streams.IDataWriterMethods.DetachStream(_objRef_global__Windows_Storage_Streams_IDataWriter);

        public void Dispose() => global::ABI.System.IDisposableMethods.Dispose(_objRef_global__System_IDisposable);

        public ByteOrder ByteOrder
        {
            get => global::ABI.Windows.Storage.Streams.IDataWriterMethods.get_ByteOrder(_objRef_global__Windows_Storage_Streams_IDataWriter);
            set => global::ABI.Windows.Storage.Streams.IDataWriterMethods.set_ByteOrder(_objRef_global__Windows_Storage_Streams_IDataWriter, value);
        }

        public UnicodeEncoding UnicodeEncoding
        {
            get => global::ABI.Windows.Storage.Streams.IDataWriterMethods.get_UnicodeEncoding(_objRef_global__Windows_Storage_Streams_IDataWriter);
            set => global::ABI.Windows.Storage.Streams.IDataWriterMethods.set_UnicodeEncoding(_objRef_global__Windows_Storage_Streams_IDataWriter, value);
        }

        public uint UnstoredBufferLength => global::ABI.Windows.Storage.Streams.IDataWriterMethods.get_UnstoredBufferLength(_objRef_global__Windows_Storage_Streams_IDataWriter);

        private bool IsOverridableInterface(Guid iid) => false;

        global::System.Runtime.InteropServices.CustomQueryInterfaceResult global::System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(ref Guid iid, out IntPtr ppv)
        {
            ppv = IntPtr.Zero;
            if (IsOverridableInterface(iid) || global::WinRT.Interop.IID.IID_IInspectable == iid || global::WinRT.Interop.IID.IID_IWeakReferenceSource == iid)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
            }

            if (((IWinRTObject)this).NativeObject.TryAs(iid, out ppv) >= 0)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.Handled;
            }

            return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
        }
    }
    [global::WinRT.WindowsRuntimeType("Windows.Foundation.UniversalApiContract")]
    [global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Windows.Storage.Streams.DataWriterStoreOperation))]
    [global::ABI.Windows.Storage.Streams.DataWriterStoreOperationRcwFactory]
    [global::WinRT.ProjectedRuntimeClass(typeof(global::Windows.Foundation.IAsyncOperation<uint>))]
    [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    public sealed class DataWriterStoreOperation : global::Windows.Foundation.IAsyncOperation<uint>, global::Windows.Foundation.IAsyncInfo, global::System.Runtime.InteropServices.ICustomQueryInterface, IWinRTObject, IEquatable<DataWriterStoreOperation>
    {
        private IntPtr ThisPtr => _inner == null ? (((IWinRTObject)this).NativeObject).ThisPtr : _inner.ThisPtr;

        private readonly IObjectReference _inner = null;




        private volatile IObjectReference ___objRef_global__Windows_Foundation_IAsyncOperation_uint_;
        private IObjectReference Make___objRef_global__Windows_Foundation_IAsyncOperation_uint_()
        {
            _ = global::WinRT.GenericTypeInstantiations.Windows_Foundation_IAsyncOperation_1_UInt32.EnsureInitialized();
            global::System.Threading.Interlocked.CompareExchange(ref ___objRef_global__Windows_Foundation_IAsyncOperation_uint_, ((IWinRTObject)this).NativeObject.As<IUnknownVftbl>(global::ABI.Windows.Foundation.IAsyncOperationMethods<uint>.IID), null);
            return ___objRef_global__Windows_Foundation_IAsyncOperation_uint_;
        }
        private IObjectReference _objRef_global__Windows_Foundation_IAsyncOperation_uint_ => ___objRef_global__Windows_Foundation_IAsyncOperation_uint_ ?? Make___objRef_global__Windows_Foundation_IAsyncOperation_uint_();

        private volatile IObjectReference ___objRef_global__Windows_Foundation_IAsyncInfo;
        private IObjectReference Make___objRef_global__Windows_Foundation_IAsyncInfo()
        {
            global::System.Threading.Interlocked.CompareExchange(ref ___objRef_global__Windows_Foundation_IAsyncInfo, ((IWinRTObject)this).NativeObject.As<IUnknownVftbl>(global::ABI.Windows.Foundation.IAsyncInfoMethods.IID), null);
            return ___objRef_global__Windows_Foundation_IAsyncInfo;
        }
        private IObjectReference _objRef_global__Windows_Foundation_IAsyncInfo => ___objRef_global__Windows_Foundation_IAsyncInfo ?? Make___objRef_global__Windows_Foundation_IAsyncInfo();



        public static DataWriterStoreOperation FromAbi(IntPtr thisPtr)
        {
            if (thisPtr == IntPtr.Zero) return null;
            return MarshalInspectable<DataWriterStoreOperation>.FromAbi(thisPtr);
        }

        internal DataWriterStoreOperation(IObjectReference objRef)
        {
            _inner = objRef.As(global::ABI.Windows.Foundation.IAsyncOperationMethods<uint>.IID);

        }


        public static bool operator ==(DataWriterStoreOperation x, DataWriterStoreOperation y) => (x?.ThisPtr ?? IntPtr.Zero) == (y?.ThisPtr ?? IntPtr.Zero);
        public static bool operator !=(DataWriterStoreOperation x, DataWriterStoreOperation y) => !(x == y);
        public bool Equals(DataWriterStoreOperation other) => this == other;
        public override bool Equals(object obj) => obj is DataWriterStoreOperation that && this == that;
        public override int GetHashCode() => ThisPtr.GetHashCode();


        bool IWinRTObject.HasUnwrappableNativeObject => true;
        IObjectReference IWinRTObject.NativeObject => _inner;
        private volatile global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> _queryInterfaceCache;
        private global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> MakeQueryInterfaceCache()
        {
            global::System.Threading.Interlocked.CompareExchange(ref _queryInterfaceCache, new global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference>(), null); 
            return _queryInterfaceCache;
        }
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache => _queryInterfaceCache ?? MakeQueryInterfaceCache();
        private volatile global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> _additionalTypeData;
        private global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> MakeAdditionalTypeData()
        {
            global::System.Threading.Interlocked.CompareExchange(ref _additionalTypeData, new global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object>(), null); 
            return _additionalTypeData;
        }
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData => _additionalTypeData ?? MakeAdditionalTypeData();

        private struct InterfaceTag<I>{};


        public uint GetResults() => global::ABI.Windows.Foundation.IAsyncOperationMethods<uint>.GetResults(_objRef_global__Windows_Foundation_IAsyncOperation_uint_);

        public void Cancel() => global::ABI.Windows.Foundation.IAsyncInfoMethods.Cancel(_objRef_global__Windows_Foundation_IAsyncInfo);

        public void Close() => global::ABI.Windows.Foundation.IAsyncInfoMethods.Close(_objRef_global__Windows_Foundation_IAsyncInfo);

        public global::Windows.Foundation.AsyncOperationCompletedHandler<uint> Completed
        {
            get => global::ABI.Windows.Foundation.IAsyncOperationMethods<uint>.get_Completed(_objRef_global__Windows_Foundation_IAsyncOperation_uint_);
            set => global::ABI.Windows.Foundation.IAsyncOperationMethods<uint>.set_Completed(_objRef_global__Windows_Foundation_IAsyncOperation_uint_, value);
        }

        public global::System.Exception ErrorCode => global::ABI.Windows.Foundation.IAsyncInfoMethods.get_ErrorCode(_objRef_global__Windows_Foundation_IAsyncInfo);

        public uint Id => global::ABI.Windows.Foundation.IAsyncInfoMethods.get_Id(_objRef_global__Windows_Foundation_IAsyncInfo);

        public global::Windows.Foundation.AsyncStatus Status => global::ABI.Windows.Foundation.IAsyncInfoMethods.get_Status(_objRef_global__Windows_Foundation_IAsyncInfo);

        private bool IsOverridableInterface(Guid iid) => false;

        global::System.Runtime.InteropServices.CustomQueryInterfaceResult global::System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(ref Guid iid, out IntPtr ppv)
        {
            ppv = IntPtr.Zero;
            if (IsOverridableInterface(iid) || global::WinRT.Interop.IID.IID_IInspectable == iid || global::WinRT.Interop.IID.IID_IWeakReferenceSource == iid)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
            }

            if (((IWinRTObject)this).NativeObject.TryAs(iid, out ppv) >= 0)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.Handled;
            }

            return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
        }
    }
    [global::WinRT.WindowsRuntimeType("Windows.Foundation.UniversalApiContract")]
    [global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Windows.Storage.Streams.FileInputStream))]
    [global::ABI.Windows.Storage.Streams.FileInputStreamRcwFactory]
    [global::WinRT.ProjectedRuntimeClass(typeof(IInputStream))]
    [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    public sealed class FileInputStream : IInputStream, global::System.IDisposable, global::System.Runtime.InteropServices.ICustomQueryInterface, IWinRTObject, IEquatable<FileInputStream>
    {
        private IntPtr ThisPtr => _inner == null ? (((IWinRTObject)this).NativeObject).ThisPtr : _inner.ThisPtr;

        private readonly IObjectReference _inner = null;



        private IObjectReference _objRef_global__Windows_Storage_Streams_IInputStream => _inner;
        private volatile IObjectReference ___objRef_global__System_IDisposable;
        private IObjectReference Make___objRef_global__System_IDisposable()
        {
            global::System.Threading.Interlocked.CompareExchange(ref ___objRef_global__System_IDisposable, ((IWinRTObject)this).NativeObject.As<IUnknownVftbl>(global::ABI.System.IDisposableMethods.IID), null);
            return ___objRef_global__System_IDisposable;
        }
        private IObjectReference _objRef_global__System_IDisposable => ___objRef_global__System_IDisposable ?? Make___objRef_global__System_IDisposable();



        public static FileInputStream FromAbi(IntPtr thisPtr)
        {
            if (thisPtr == IntPtr.Zero) return null;
            return MarshalInspectable<FileInputStream>.FromAbi(thisPtr);
        }

        internal FileInputStream(IObjectReference objRef)
        {
            _inner = objRef.As(global::ABI.Windows.Storage.Streams.IInputStreamMethods.IID);

        }


        public static bool operator ==(FileInputStream x, FileInputStream y) => (x?.ThisPtr ?? IntPtr.Zero) == (y?.ThisPtr ?? IntPtr.Zero);
        public static bool operator !=(FileInputStream x, FileInputStream y) => !(x == y);
        public bool Equals(FileInputStream other) => this == other;
        public override bool Equals(object obj) => obj is FileInputStream that && this == that;
        public override int GetHashCode() => ThisPtr.GetHashCode();


        bool IWinRTObject.HasUnwrappableNativeObject => true;
        IObjectReference IWinRTObject.NativeObject => _inner;
        private volatile global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> _queryInterfaceCache;
        private global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> MakeQueryInterfaceCache()
        {
            global::System.Threading.Interlocked.CompareExchange(ref _queryInterfaceCache, new global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference>(), null); 
            return _queryInterfaceCache;
        }
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache => _queryInterfaceCache ?? MakeQueryInterfaceCache();
        private volatile global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> _additionalTypeData;
        private global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> MakeAdditionalTypeData()
        {
            global::System.Threading.Interlocked.CompareExchange(ref _additionalTypeData, new global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object>(), null); 
            return _additionalTypeData;
        }
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData => _additionalTypeData ?? MakeAdditionalTypeData();

        private struct InterfaceTag<I>{};


        public global::Windows.Foundation.IAsyncOperationWithProgress<IBuffer, uint> ReadAsync(IBuffer buffer, uint count, InputStreamOptions options) => global::ABI.Windows.Storage.Streams.IInputStreamMethods.ReadAsync(_objRef_global__Windows_Storage_Streams_IInputStream, buffer, count, options);

        public void Dispose() => global::ABI.System.IDisposableMethods.Dispose(_objRef_global__System_IDisposable);

        private bool IsOverridableInterface(Guid iid) => false;

        global::System.Runtime.InteropServices.CustomQueryInterfaceResult global::System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(ref Guid iid, out IntPtr ppv)
        {
            ppv = IntPtr.Zero;
            if (IsOverridableInterface(iid) || global::WinRT.Interop.IID.IID_IInspectable == iid || global::WinRT.Interop.IID.IID_IWeakReferenceSource == iid)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
            }

            if (((IWinRTObject)this).NativeObject.TryAs(iid, out ppv) >= 0)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.Handled;
            }

            return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
        }
    }
    [global::WinRT.WindowsRuntimeType("Windows.Foundation.UniversalApiContract")][global::WinRT.WinRTExposedType(typeof(global::WinRT.EnumTypeDetails<FileOpenDisposition>))][global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.16299.0")]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 327680u)]
    public enum FileOpenDisposition : int
    {
        OpenExisting = unchecked((int)0),
        OpenAlways = unchecked((int)0x1),
        CreateNew = unchecked((int)0x2),
        CreateAlways = unchecked((int)0x3),
        TruncateExisting = unchecked((int)0x4),
    }
    [global::WinRT.WindowsRuntimeType("Windows.Foundation.UniversalApiContract")]
    [global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Windows.Storage.Streams.FileOutputStream))]
    [global::ABI.Windows.Storage.Streams.FileOutputStreamRcwFactory]
    [global::WinRT.ProjectedRuntimeClass(typeof(IOutputStream))]
    [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    public sealed class FileOutputStream : IOutputStream, global::System.IDisposable, global::System.Runtime.InteropServices.ICustomQueryInterface, IWinRTObject, IEquatable<FileOutputStream>
    {
        private IntPtr ThisPtr => _inner == null ? (((IWinRTObject)this).NativeObject).ThisPtr : _inner.ThisPtr;

        private readonly IObjectReference _inner = null;



        private IObjectReference _objRef_global__Windows_Storage_Streams_IOutputStream => _inner;
        private volatile IObjectReference ___objRef_global__System_IDisposable;
        private IObjectReference Make___objRef_global__System_IDisposable()
        {
            global::System.Threading.Interlocked.CompareExchange(ref ___objRef_global__System_IDisposable, ((IWinRTObject)this).NativeObject.As<IUnknownVftbl>(global::ABI.System.IDisposableMethods.IID), null);
            return ___objRef_global__System_IDisposable;
        }
        private IObjectReference _objRef_global__System_IDisposable => ___objRef_global__System_IDisposable ?? Make___objRef_global__System_IDisposable();



        public static FileOutputStream FromAbi(IntPtr thisPtr)
        {
            if (thisPtr == IntPtr.Zero) return null;
            return MarshalInspectable<FileOutputStream>.FromAbi(thisPtr);
        }

        internal FileOutputStream(IObjectReference objRef)
        {
            _inner = objRef.As(global::ABI.Windows.Storage.Streams.IOutputStreamMethods.IID);

        }


        public static bool operator ==(FileOutputStream x, FileOutputStream y) => (x?.ThisPtr ?? IntPtr.Zero) == (y?.ThisPtr ?? IntPtr.Zero);
        public static bool operator !=(FileOutputStream x, FileOutputStream y) => !(x == y);
        public bool Equals(FileOutputStream other) => this == other;
        public override bool Equals(object obj) => obj is FileOutputStream that && this == that;
        public override int GetHashCode() => ThisPtr.GetHashCode();


        bool IWinRTObject.HasUnwrappableNativeObject => true;
        IObjectReference IWinRTObject.NativeObject => _inner;
        private volatile global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> _queryInterfaceCache;
        private global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> MakeQueryInterfaceCache()
        {
            global::System.Threading.Interlocked.CompareExchange(ref _queryInterfaceCache, new global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference>(), null); 
            return _queryInterfaceCache;
        }
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache => _queryInterfaceCache ?? MakeQueryInterfaceCache();
        private volatile global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> _additionalTypeData;
        private global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> MakeAdditionalTypeData()
        {
            global::System.Threading.Interlocked.CompareExchange(ref _additionalTypeData, new global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object>(), null); 
            return _additionalTypeData;
        }
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData => _additionalTypeData ?? MakeAdditionalTypeData();

        private struct InterfaceTag<I>{};


        public global::Windows.Foundation.IAsyncOperationWithProgress<uint, uint> WriteAsync(IBuffer buffer) => global::ABI.Windows.Storage.Streams.IOutputStreamMethods.WriteAsync(_objRef_global__Windows_Storage_Streams_IOutputStream, buffer);

        public global::Windows.Foundation.IAsyncOperation<bool> FlushAsync() => global::ABI.Windows.Storage.Streams.IOutputStreamMethods.FlushAsync(_objRef_global__Windows_Storage_Streams_IOutputStream);

        public void Dispose() => global::ABI.System.IDisposableMethods.Dispose(_objRef_global__System_IDisposable);

        private bool IsOverridableInterface(Guid iid) => false;

        global::System.Runtime.InteropServices.CustomQueryInterfaceResult global::System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(ref Guid iid, out IntPtr ppv)
        {
            ppv = IntPtr.Zero;
            if (IsOverridableInterface(iid) || global::WinRT.Interop.IID.IID_IInspectable == iid || global::WinRT.Interop.IID.IID_IWeakReferenceSource == iid)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
            }

            if (((IWinRTObject)this).NativeObject.TryAs(iid, out ppv) >= 0)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.Handled;
            }

            return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
        }
    }
    [global::WinRT.WindowsRuntimeType("Windows.Foundation.UniversalApiContract")]
    [global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Windows.Storage.Streams.FileRandomAccessStream))]
    [global::ABI.Windows.Storage.Streams.FileRandomAccessStreamRcwFactory]
    [global::WinRT.ProjectedRuntimeClass(typeof(IRandomAccessStream))]
    [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    public sealed class FileRandomAccessStream : IRandomAccessStream, IOutputStream, global::System.IDisposable, IInputStream, global::System.Runtime.InteropServices.ICustomQueryInterface, IWinRTObject, IEquatable<FileRandomAccessStream>
    {
        private IntPtr ThisPtr => _inner == null ? (((IWinRTObject)this).NativeObject).ThisPtr : _inner.ThisPtr;

        private readonly IObjectReference _inner = null;



        private IObjectReference _objRef_global__Windows_Storage_Streams_IRandomAccessStream => _inner;
        private volatile IObjectReference ___objRef_global__Windows_Storage_Streams_IOutputStream;
        private IObjectReference Make___objRef_global__Windows_Storage_Streams_IOutputStream()
        {
            global::System.Threading.Interlocked.CompareExchange(ref ___objRef_global__Windows_Storage_Streams_IOutputStream, ((IWinRTObject)this).NativeObject.As<IUnknownVftbl>(global::ABI.Windows.Storage.Streams.IOutputStreamMethods.IID), null);
            return ___objRef_global__Windows_Storage_Streams_IOutputStream;
        }
        private IObjectReference _objRef_global__Windows_Storage_Streams_IOutputStream => ___objRef_global__Windows_Storage_Streams_IOutputStream ?? Make___objRef_global__Windows_Storage_Streams_IOutputStream();

        private volatile IObjectReference ___objRef_global__System_IDisposable;
        private IObjectReference Make___objRef_global__System_IDisposable()
        {
            global::System.Threading.Interlocked.CompareExchange(ref ___objRef_global__System_IDisposable, ((IWinRTObject)this).NativeObject.As<IUnknownVftbl>(global::ABI.System.IDisposableMethods.IID), null);
            return ___objRef_global__System_IDisposable;
        }
        private IObjectReference _objRef_global__System_IDisposable => ___objRef_global__System_IDisposable ?? Make___objRef_global__System_IDisposable();

        private volatile IObjectReference ___objRef_global__Windows_Storage_Streams_IInputStream;
        private IObjectReference Make___objRef_global__Windows_Storage_Streams_IInputStream()
        {
            global::System.Threading.Interlocked.CompareExchange(ref ___objRef_global__Windows_Storage_Streams_IInputStream, ((IWinRTObject)this).NativeObject.As<IUnknownVftbl>(global::ABI.Windows.Storage.Streams.IInputStreamMethods.IID), null);
            return ___objRef_global__Windows_Storage_Streams_IInputStream;
        }
        private IObjectReference _objRef_global__Windows_Storage_Streams_IInputStream => ___objRef_global__Windows_Storage_Streams_IInputStream ?? Make___objRef_global__Windows_Storage_Streams_IInputStream();



        public static I As<I>() => ActivationFactory.Get("Windows.Storage.Streams.FileRandomAccessStream").AsInterface<I>();

        private static volatile IObjectReference ___objRef_global__Windows_Storage_Streams_IFileRandomAccessStreamStatics;
        private static IObjectReference _objRef_global__Windows_Storage_Streams_IFileRandomAccessStreamStatics
        {
            get
            { 
                var factory = ___objRef_global__Windows_Storage_Streams_IFileRandomAccessStreamStatics;
                if (factory != null && factory.IsInCurrentContext)
                {
                    return factory;
                }
                else
                {
                    return ___objRef_global__Windows_Storage_Streams_IFileRandomAccessStreamStatics = ActivationFactory.Get("Windows.Storage.Streams.FileRandomAccessStream", global::ABI.Windows.Storage.Streams.IFileRandomAccessStreamStaticsMethods.IID);
                }
            }
        }

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.16299.0")]
        public static global::Windows.Foundation.IAsyncOperation<IRandomAccessStream> OpenAsync(string filePath, global::Windows.Storage.FileAccessMode accessMode) => global::ABI.Windows.Storage.Streams.IFileRandomAccessStreamStaticsMethods.OpenAsync(_objRef_global__Windows_Storage_Streams_IFileRandomAccessStreamStatics, filePath, accessMode);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.16299.0")]
        public static global::Windows.Foundation.IAsyncOperation<IRandomAccessStream> OpenAsync(string filePath, global::Windows.Storage.FileAccessMode accessMode, global::Windows.Storage.StorageOpenOptions sharingOptions, FileOpenDisposition openDisposition) => global::ABI.Windows.Storage.Streams.IFileRandomAccessStreamStaticsMethods.OpenAsync(_objRef_global__Windows_Storage_Streams_IFileRandomAccessStreamStatics, filePath, accessMode, sharingOptions, openDisposition);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.16299.0")]
        public static global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.StorageStreamTransaction> OpenTransactedWriteAsync(string filePath) => global::ABI.Windows.Storage.Streams.IFileRandomAccessStreamStaticsMethods.OpenTransactedWriteAsync(_objRef_global__Windows_Storage_Streams_IFileRandomAccessStreamStatics, filePath);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.16299.0")]
        public static global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.StorageStreamTransaction> OpenTransactedWriteAsync(string filePath, global::Windows.Storage.StorageOpenOptions openOptions, FileOpenDisposition openDisposition) => global::ABI.Windows.Storage.Streams.IFileRandomAccessStreamStaticsMethods.OpenTransactedWriteAsync(_objRef_global__Windows_Storage_Streams_IFileRandomAccessStreamStatics, filePath, openOptions, openDisposition);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.16299.0")]
        public static global::Windows.Foundation.IAsyncOperation<IRandomAccessStream> OpenForUserAsync(global::Windows.System.User user, string filePath, global::Windows.Storage.FileAccessMode accessMode) => global::ABI.Windows.Storage.Streams.IFileRandomAccessStreamStaticsMethods.OpenForUserAsync(_objRef_global__Windows_Storage_Streams_IFileRandomAccessStreamStatics, user, filePath, accessMode);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.16299.0")]
        public static global::Windows.Foundation.IAsyncOperation<IRandomAccessStream> OpenForUserAsync(global::Windows.System.User user, string filePath, global::Windows.Storage.FileAccessMode accessMode, global::Windows.Storage.StorageOpenOptions sharingOptions, FileOpenDisposition openDisposition) => global::ABI.Windows.Storage.Streams.IFileRandomAccessStreamStaticsMethods.OpenForUserAsync(_objRef_global__Windows_Storage_Streams_IFileRandomAccessStreamStatics, user, filePath, accessMode, sharingOptions, openDisposition);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.16299.0")]
        public static global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.StorageStreamTransaction> OpenTransactedWriteForUserAsync(global::Windows.System.User user, string filePath) => global::ABI.Windows.Storage.Streams.IFileRandomAccessStreamStaticsMethods.OpenTransactedWriteForUserAsync(_objRef_global__Windows_Storage_Streams_IFileRandomAccessStreamStatics, user, filePath);

        [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.16299.0")]
        public static global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.StorageStreamTransaction> OpenTransactedWriteForUserAsync(global::Windows.System.User user, string filePath, global::Windows.Storage.StorageOpenOptions openOptions, FileOpenDisposition openDisposition) => global::ABI.Windows.Storage.Streams.IFileRandomAccessStreamStaticsMethods.OpenTransactedWriteForUserAsync(_objRef_global__Windows_Storage_Streams_IFileRandomAccessStreamStatics, user, filePath, openOptions, openDisposition);

        public static FileRandomAccessStream FromAbi(IntPtr thisPtr)
        {
            if (thisPtr == IntPtr.Zero) return null;
            return MarshalInspectable<FileRandomAccessStream>.FromAbi(thisPtr);
        }

        internal FileRandomAccessStream(IObjectReference objRef)
        {
            _inner = objRef.As(global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.IID);

        }


        public static bool operator ==(FileRandomAccessStream x, FileRandomAccessStream y) => (x?.ThisPtr ?? IntPtr.Zero) == (y?.ThisPtr ?? IntPtr.Zero);
        public static bool operator !=(FileRandomAccessStream x, FileRandomAccessStream y) => !(x == y);
        public bool Equals(FileRandomAccessStream other) => this == other;
        public override bool Equals(object obj) => obj is FileRandomAccessStream that && this == that;
        public override int GetHashCode() => ThisPtr.GetHashCode();


        bool IWinRTObject.HasUnwrappableNativeObject => true;
        IObjectReference IWinRTObject.NativeObject => _inner;
        private volatile global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> _queryInterfaceCache;
        private global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> MakeQueryInterfaceCache()
        {
            global::System.Threading.Interlocked.CompareExchange(ref _queryInterfaceCache, new global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference>(), null); 
            return _queryInterfaceCache;
        }
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache => _queryInterfaceCache ?? MakeQueryInterfaceCache();
        private volatile global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> _additionalTypeData;
        private global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> MakeAdditionalTypeData()
        {
            global::System.Threading.Interlocked.CompareExchange(ref _additionalTypeData, new global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object>(), null); 
            return _additionalTypeData;
        }
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData => _additionalTypeData ?? MakeAdditionalTypeData();

        private struct InterfaceTag<I>{};


        public IInputStream GetInputStreamAt(ulong position) => global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.GetInputStreamAt(_objRef_global__Windows_Storage_Streams_IRandomAccessStream, position);

        public IOutputStream GetOutputStreamAt(ulong position) => global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.GetOutputStreamAt(_objRef_global__Windows_Storage_Streams_IRandomAccessStream, position);

        public void Seek(ulong position) => global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.Seek(_objRef_global__Windows_Storage_Streams_IRandomAccessStream, position);

        public IRandomAccessStream CloneStream() => global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.CloneStream(_objRef_global__Windows_Storage_Streams_IRandomAccessStream);

        public global::Windows.Foundation.IAsyncOperationWithProgress<uint, uint> WriteAsync(IBuffer buffer) => global::ABI.Windows.Storage.Streams.IOutputStreamMethods.WriteAsync(_objRef_global__Windows_Storage_Streams_IOutputStream, buffer);

        public global::Windows.Foundation.IAsyncOperation<bool> FlushAsync() => global::ABI.Windows.Storage.Streams.IOutputStreamMethods.FlushAsync(_objRef_global__Windows_Storage_Streams_IOutputStream);

        public void Dispose() => global::ABI.System.IDisposableMethods.Dispose(_objRef_global__System_IDisposable);

        public global::Windows.Foundation.IAsyncOperationWithProgress<IBuffer, uint> ReadAsync(IBuffer buffer, uint count, InputStreamOptions options) => global::ABI.Windows.Storage.Streams.IInputStreamMethods.ReadAsync(_objRef_global__Windows_Storage_Streams_IInputStream, buffer, count, options);

        public bool CanRead => global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.get_CanRead(_objRef_global__Windows_Storage_Streams_IRandomAccessStream);

        public bool CanWrite => global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.get_CanWrite(_objRef_global__Windows_Storage_Streams_IRandomAccessStream);

        public ulong Position => global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.get_Position(_objRef_global__Windows_Storage_Streams_IRandomAccessStream);

        public ulong Size
        {
            get => global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.get_Size(_objRef_global__Windows_Storage_Streams_IRandomAccessStream);
            set => global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.set_Size(_objRef_global__Windows_Storage_Streams_IRandomAccessStream, value);
        }

        private bool IsOverridableInterface(Guid iid) => false;

        global::System.Runtime.InteropServices.CustomQueryInterfaceResult global::System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(ref Guid iid, out IntPtr ppv)
        {
            ppv = IntPtr.Zero;
            if (IsOverridableInterface(iid) || global::WinRT.Interop.IID.IID_IInspectable == iid || global::WinRT.Interop.IID.IID_IWeakReferenceSource == iid)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
            }

            if (((IWinRTObject)this).NativeObject.TryAs(iid, out ppv) >= 0)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.Handled;
            }

            return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
        }
    }
    [global::WinRT.WindowsRuntimeType("Windows.Foundation.UniversalApiContract")][Guid("905A0FE0-BC53-11DF-8C49-001E4FC686DA")][global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Windows.Storage.Streams.IBuffer))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    public interface IBuffer
    {
        uint Capacity { get; }
        uint Length { get; set; }
    }
    [global::WinRT.WindowsRuntimeType("Windows.Foundation.UniversalApiContract")][Guid("71AF914D-C10F-484B-BC50-14BC623B3A27")][global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Windows.Storage.Streams.IBufferFactory))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    internal interface IBufferFactory
    {
        Buffer Create(uint capacity);
    }
    [global::WinRT.WindowsRuntimeType("Windows.Foundation.UniversalApiContract")][Guid("E901E65B-D716-475A-A90A-AF7229B1E741")][global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Windows.Storage.Streams.IBufferStatics))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    internal interface IBufferStatics
    {
        Buffer CreateCopyFromMemoryBuffer(global::Windows.Foundation.IMemoryBuffer input);
        global::Windows.Foundation.MemoryBuffer CreateMemoryBufferOverIBuffer(IBuffer input);
    }
    [global::WinRT.WindowsRuntimeType("Windows.Foundation.UniversalApiContract")][Guid("97D098A5-3B99-4DE9-88A5-E11D2F50C795")][global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Windows.Storage.Streams.IContentTypeProvider))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    public interface IContentTypeProvider
    {
        string ContentType { get; }
    }
    [global::WinRT.WindowsRuntimeType("Windows.Foundation.UniversalApiContract")][Guid("E2B50029-B4C1-4314-A4B8-FB813A2F275E")][global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Windows.Storage.Streams.IDataReader))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    public interface IDataReader
    {
        byte ReadByte();
        void ReadBytes(byte[] value);
        IBuffer ReadBuffer(uint length);
        bool ReadBoolean();
        Guid ReadGuid();
        short ReadInt16();
        int ReadInt32();
        long ReadInt64();
        ushort ReadUInt16();
        uint ReadUInt32();
        ulong ReadUInt64();
        float ReadSingle();
        double ReadDouble();
        string ReadString(uint codeUnitCount);
        global::System.DateTimeOffset ReadDateTime();
        global::System.TimeSpan ReadTimeSpan();
        DataReaderLoadOperation LoadAsync(uint count);
        IBuffer DetachBuffer();
        IInputStream DetachStream();
        ByteOrder ByteOrder { get; set; }
        InputStreamOptions InputStreamOptions { get; set; }
        uint UnconsumedBufferLength { get; }
        UnicodeEncoding UnicodeEncoding { get; set; }
    }
    [global::WinRT.WindowsRuntimeType("Windows.Foundation.UniversalApiContract")][Guid("D7527847-57DA-4E15-914C-06806699A098")][global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Windows.Storage.Streams.IDataReaderFactory))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    internal interface IDataReaderFactory
    {
        DataReader CreateDataReader(IInputStream inputStream);
    }
    [global::WinRT.WindowsRuntimeType("Windows.Foundation.UniversalApiContract")][Guid("11FCBFC8-F93A-471B-B121-F379E349313C")][global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Windows.Storage.Streams.IDataReaderStatics))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    internal interface IDataReaderStatics
    {
        DataReader FromBuffer(IBuffer buffer);
    }
    [global::WinRT.WindowsRuntimeType("Windows.Foundation.UniversalApiContract")][Guid("64B89265-D341-4922-B38A-DD4AF8808C4E")][global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Windows.Storage.Streams.IDataWriter))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    public interface IDataWriter
    {
        void WriteByte(byte value);
        void WriteBytes(byte[] value);
        [global::Windows.Foundation.Metadata.Overload(@"WriteBuffer")]
        void WriteBuffer(IBuffer buffer);
        [global::Windows.Foundation.Metadata.Overload(@"WriteBufferRange")]
        void WriteBuffer(IBuffer buffer, uint start, uint count);
        void WriteBoolean(bool value);
        void WriteGuid(Guid value);
        void WriteInt16(short value);
        void WriteInt32(int value);
        void WriteInt64(long value);
        void WriteUInt16(ushort value);
        void WriteUInt32(uint value);
        void WriteUInt64(ulong value);
        void WriteSingle(float value);
        void WriteDouble(double value);
        void WriteDateTime(global::System.DateTimeOffset value);
        void WriteTimeSpan(global::System.TimeSpan value);
        uint WriteString(string value);
        uint MeasureString(string value);
        DataWriterStoreOperation StoreAsync();
        global::Windows.Foundation.IAsyncOperation<bool> FlushAsync();
        IBuffer DetachBuffer();
        IOutputStream DetachStream();
        ByteOrder ByteOrder { get; set; }
        UnicodeEncoding UnicodeEncoding { get; set; }
        uint UnstoredBufferLength { get; }
    }
    [global::WinRT.WindowsRuntimeType("Windows.Foundation.UniversalApiContract")][Guid("338C67C2-8B84-4C2B-9C50-7B8767847A1F")][global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Windows.Storage.Streams.IDataWriterFactory))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    internal interface IDataWriterFactory
    {
        DataWriter CreateDataWriter(IOutputStream outputStream);
    }
    [global::WinRT.WindowsRuntimeType("Windows.Foundation.UniversalApiContract")][Guid("73550107-3B57-4B5D-8345-554D2FC621F0")][global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Windows.Storage.Streams.IFileRandomAccessStreamStatics))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 327680u)]
    internal interface IFileRandomAccessStreamStatics
    {
        [global::Windows.Foundation.Metadata.Overload(@"OpenAsync")]
        global::Windows.Foundation.IAsyncOperation<IRandomAccessStream> OpenAsync(string filePath, global::Windows.Storage.FileAccessMode accessMode);
        [global::Windows.Foundation.Metadata.Overload(@"OpenWithOptionsAsync")]
        global::Windows.Foundation.IAsyncOperation<IRandomAccessStream> OpenAsync(string filePath, global::Windows.Storage.FileAccessMode accessMode, global::Windows.Storage.StorageOpenOptions sharingOptions, FileOpenDisposition openDisposition);
        [global::Windows.Foundation.Metadata.Overload(@"OpenTransactedWriteAsync")]
        global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.StorageStreamTransaction> OpenTransactedWriteAsync(string filePath);
        [global::Windows.Foundation.Metadata.Overload(@"OpenTransactedWriteWithOptionsAsync")]
        global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.StorageStreamTransaction> OpenTransactedWriteAsync(string filePath, global::Windows.Storage.StorageOpenOptions openOptions, FileOpenDisposition openDisposition);
        [global::Windows.Foundation.Metadata.Overload(@"OpenForUserAsync")]
        global::Windows.Foundation.IAsyncOperation<IRandomAccessStream> OpenForUserAsync(global::Windows.System.User user, string filePath, global::Windows.Storage.FileAccessMode accessMode);
        [global::Windows.Foundation.Metadata.Overload(@"OpenForUserWithOptionsAsync")]
        global::Windows.Foundation.IAsyncOperation<IRandomAccessStream> OpenForUserAsync(global::Windows.System.User user, string filePath, global::Windows.Storage.FileAccessMode accessMode, global::Windows.Storage.StorageOpenOptions sharingOptions, FileOpenDisposition openDisposition);
        [global::Windows.Foundation.Metadata.Overload(@"OpenTransactedWriteForUserAsync")]
        global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.StorageStreamTransaction> OpenTransactedWriteForUserAsync(global::Windows.System.User user, string filePath);
        [global::Windows.Foundation.Metadata.Overload(@"OpenTransactedWriteForUserWithOptionsAsync")]
        global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.StorageStreamTransaction> OpenTransactedWriteForUserAsync(global::Windows.System.User user, string filePath, global::Windows.Storage.StorageOpenOptions openOptions, FileOpenDisposition openDisposition);
    }
    [global::WinRT.WindowsRuntimeType("Windows.Foundation.UniversalApiContract")][Guid("905A0FE2-BC53-11DF-8C49-001E4FC686DA")][global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Windows.Storage.Streams.IInputStream))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    public interface IInputStream : global::System.IDisposable
    {
        global::Windows.Foundation.IAsyncOperationWithProgress<IBuffer, uint> ReadAsync(IBuffer buffer, uint count, InputStreamOptions options);
    }
    [global::WinRT.WindowsRuntimeType("Windows.Foundation.UniversalApiContract")][Guid("43929D18-5EC9-4B5A-919C-4205B0C804B6")][global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Windows.Storage.Streams.IInputStreamReference))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    public interface IInputStreamReference
    {
        global::Windows.Foundation.IAsyncOperation<IInputStream> OpenSequentialReadAsync();
    }
    [global::WinRT.WindowsRuntimeType("Windows.Foundation.UniversalApiContract")][Guid("905A0FE6-BC53-11DF-8C49-001E4FC686DA")][global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Windows.Storage.Streams.IOutputStream))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    public interface IOutputStream : global::System.IDisposable
    {
        global::Windows.Foundation.IAsyncOperationWithProgress<uint, uint> WriteAsync(IBuffer buffer);
        global::Windows.Foundation.IAsyncOperation<bool> FlushAsync();
    }
    [global::WinRT.WindowsRuntimeType("Windows.Foundation.UniversalApiContract")][Guid("6E8EBF1C-EF3D-4376-B20E-5BE638AEAC77")][global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Windows.Storage.Streams.IPropertySetSerializer))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 851968u)]
    public interface IPropertySetSerializer
    {
        IBuffer Serialize(global::Windows.Foundation.Collections.IPropertySet propertySet);
        void Deserialize(global::Windows.Foundation.Collections.IPropertySet propertySet, IBuffer buffer);
    }
    [global::WinRT.WindowsRuntimeType("Windows.Foundation.UniversalApiContract")][Guid("905A0FE1-BC53-11DF-8C49-001E4FC686DA")][global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Windows.Storage.Streams.IRandomAccessStream))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    public interface IRandomAccessStream : global::System.IDisposable, IInputStream, IOutputStream
    {
        IInputStream GetInputStreamAt(ulong position);
        IOutputStream GetOutputStreamAt(ulong position);
        void Seek(ulong position);
        IRandomAccessStream CloneStream();
        bool CanRead { get; }
        bool CanWrite { get; }
        ulong Position { get; }
        ulong Size { get; set; }
    }
    [global::WinRT.WindowsRuntimeType("Windows.Foundation.UniversalApiContract")][Guid("33EE3134-1DD6-4E3A-8067-D1C162E8642B")][global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Windows.Storage.Streams.IRandomAccessStreamReference))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    public interface IRandomAccessStreamReference
    {
        global::Windows.Foundation.IAsyncOperation<IRandomAccessStreamWithContentType> OpenReadAsync();
    }
    [global::WinRT.WindowsRuntimeType("Windows.Foundation.UniversalApiContract")][Guid("857309DC-3FBF-4E7D-986F-EF3B1A07A964")][global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Windows.Storage.Streams.IRandomAccessStreamReferenceStatics))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    internal interface IRandomAccessStreamReferenceStatics
    {
        RandomAccessStreamReference CreateFromFile(global::Windows.Storage.IStorageFile file);
        RandomAccessStreamReference CreateFromUri(global::System.Uri uri);
        RandomAccessStreamReference CreateFromStream(IRandomAccessStream stream);
    }
    [global::WinRT.WindowsRuntimeType("Windows.Foundation.UniversalApiContract")][Guid("524CEDCF-6E29-4CE5-9573-6B753DB66C3A")][global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Windows.Storage.Streams.IRandomAccessStreamStatics))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    internal interface IRandomAccessStreamStatics
    {
        [global::Windows.Foundation.Metadata.Overload(@"CopyAsync")]
        global::Windows.Foundation.IAsyncOperationWithProgress<ulong, ulong> CopyAsync(IInputStream source, IOutputStream destination);
        [global::Windows.Foundation.Metadata.Overload(@"CopySizeAsync")]
        global::Windows.Foundation.IAsyncOperationWithProgress<ulong, ulong> CopyAsync(IInputStream source, IOutputStream destination, ulong bytesToCopy);
        global::Windows.Foundation.IAsyncOperationWithProgress<ulong, ulong> CopyAndCloseAsync(IInputStream source, IOutputStream destination);
    }
    [global::WinRT.WindowsRuntimeType("Windows.Foundation.UniversalApiContract")][Guid("CC254827-4B3D-438F-9232-10C76BC7E038")][global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Windows.Storage.Streams.IRandomAccessStreamWithContentType))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    public interface IRandomAccessStreamWithContentType : IRandomAccessStream, global::System.IDisposable, IInputStream, IOutputStream, IContentTypeProvider
    {
    }
    [global::WinRT.WindowsRuntimeType("Windows.Foundation.UniversalApiContract")]
    [global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Windows.Storage.Streams.InMemoryRandomAccessStream))]
    [global::ABI.Windows.Storage.Streams.InMemoryRandomAccessStreamRcwFactory]
    [global::WinRT.ProjectedRuntimeClass(typeof(IRandomAccessStream))]
    [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    public sealed class InMemoryRandomAccessStream : IRandomAccessStream, IOutputStream, global::System.IDisposable, IInputStream, global::System.Runtime.InteropServices.ICustomQueryInterface, IWinRTObject, IEquatable<InMemoryRandomAccessStream>
    {
        private IntPtr ThisPtr => _inner == null ? (((IWinRTObject)this).NativeObject).ThisPtr : _inner.ThisPtr;

        private readonly IObjectReference _inner = null;



        private IObjectReference _objRef_global__Windows_Storage_Streams_IRandomAccessStream => _inner;
        private volatile IObjectReference ___objRef_global__Windows_Storage_Streams_IOutputStream;
        private IObjectReference Make___objRef_global__Windows_Storage_Streams_IOutputStream()
        {
            global::System.Threading.Interlocked.CompareExchange(ref ___objRef_global__Windows_Storage_Streams_IOutputStream, ((IWinRTObject)this).NativeObject.As<IUnknownVftbl>(global::ABI.Windows.Storage.Streams.IOutputStreamMethods.IID), null);
            return ___objRef_global__Windows_Storage_Streams_IOutputStream;
        }
        private IObjectReference _objRef_global__Windows_Storage_Streams_IOutputStream => ___objRef_global__Windows_Storage_Streams_IOutputStream ?? Make___objRef_global__Windows_Storage_Streams_IOutputStream();

        private volatile IObjectReference ___objRef_global__System_IDisposable;
        private IObjectReference Make___objRef_global__System_IDisposable()
        {
            global::System.Threading.Interlocked.CompareExchange(ref ___objRef_global__System_IDisposable, ((IWinRTObject)this).NativeObject.As<IUnknownVftbl>(global::ABI.System.IDisposableMethods.IID), null);
            return ___objRef_global__System_IDisposable;
        }
        private IObjectReference _objRef_global__System_IDisposable => ___objRef_global__System_IDisposable ?? Make___objRef_global__System_IDisposable();

        private volatile IObjectReference ___objRef_global__Windows_Storage_Streams_IInputStream;
        private IObjectReference Make___objRef_global__Windows_Storage_Streams_IInputStream()
        {
            global::System.Threading.Interlocked.CompareExchange(ref ___objRef_global__Windows_Storage_Streams_IInputStream, ((IWinRTObject)this).NativeObject.As<IUnknownVftbl>(global::ABI.Windows.Storage.Streams.IInputStreamMethods.IID), null);
            return ___objRef_global__Windows_Storage_Streams_IInputStream;
        }
        private IObjectReference _objRef_global__Windows_Storage_Streams_IInputStream => ___objRef_global__Windows_Storage_Streams_IInputStream ?? Make___objRef_global__Windows_Storage_Streams_IInputStream();



        private static volatile IObjectReference ___objRef_global__Windows_Storage_Streams_InMemoryRandomAccessStream;
        private static IObjectReference _objRef_global__Windows_Storage_Streams_InMemoryRandomAccessStream
        {
            get
            { 
                var factory = ___objRef_global__Windows_Storage_Streams_InMemoryRandomAccessStream;
                if (factory != null && factory.IsInCurrentContext)
                {
                    return factory;
                }
                else
                {
                    return ___objRef_global__Windows_Storage_Streams_InMemoryRandomAccessStream = ActivationFactory.Get("Windows.Storage.Streams.InMemoryRandomAccessStream");
                }
            }
        }

        public InMemoryRandomAccessStream() 
        {
            _inner = global::ABI.WinRT.Interop.IActivationFactoryMethods.ActivateInstanceUnsafe(_objRef_global__Windows_Storage_Streams_InMemoryRandomAccessStream, global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.IID);
            ComWrappersSupport.RegisterObjectForInterface(this, ThisPtr);
            ComWrappersHelper.Init(_inner, false);

        }

        public static InMemoryRandomAccessStream FromAbi(IntPtr thisPtr)
        {
            if (thisPtr == IntPtr.Zero) return null;
            return MarshalInspectable<InMemoryRandomAccessStream>.FromAbi(thisPtr);
        }

        internal InMemoryRandomAccessStream(IObjectReference objRef)
        {
            _inner = objRef.As(global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.IID);

        }


        public static bool operator ==(InMemoryRandomAccessStream x, InMemoryRandomAccessStream y) => (x?.ThisPtr ?? IntPtr.Zero) == (y?.ThisPtr ?? IntPtr.Zero);
        public static bool operator !=(InMemoryRandomAccessStream x, InMemoryRandomAccessStream y) => !(x == y);
        public bool Equals(InMemoryRandomAccessStream other) => this == other;
        public override bool Equals(object obj) => obj is InMemoryRandomAccessStream that && this == that;
        public override int GetHashCode() => ThisPtr.GetHashCode();


        bool IWinRTObject.HasUnwrappableNativeObject => true;
        IObjectReference IWinRTObject.NativeObject => _inner;
        private volatile global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> _queryInterfaceCache;
        private global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> MakeQueryInterfaceCache()
        {
            global::System.Threading.Interlocked.CompareExchange(ref _queryInterfaceCache, new global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference>(), null); 
            return _queryInterfaceCache;
        }
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache => _queryInterfaceCache ?? MakeQueryInterfaceCache();
        private volatile global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> _additionalTypeData;
        private global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> MakeAdditionalTypeData()
        {
            global::System.Threading.Interlocked.CompareExchange(ref _additionalTypeData, new global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object>(), null); 
            return _additionalTypeData;
        }
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData => _additionalTypeData ?? MakeAdditionalTypeData();

        private struct InterfaceTag<I>{};


        public IInputStream GetInputStreamAt(ulong position) => global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.GetInputStreamAt(_objRef_global__Windows_Storage_Streams_IRandomAccessStream, position);

        public IOutputStream GetOutputStreamAt(ulong position) => global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.GetOutputStreamAt(_objRef_global__Windows_Storage_Streams_IRandomAccessStream, position);

        public void Seek(ulong position) => global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.Seek(_objRef_global__Windows_Storage_Streams_IRandomAccessStream, position);

        public IRandomAccessStream CloneStream() => global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.CloneStream(_objRef_global__Windows_Storage_Streams_IRandomAccessStream);

        public global::Windows.Foundation.IAsyncOperationWithProgress<uint, uint> WriteAsync(IBuffer buffer) => global::ABI.Windows.Storage.Streams.IOutputStreamMethods.WriteAsync(_objRef_global__Windows_Storage_Streams_IOutputStream, buffer);

        public global::Windows.Foundation.IAsyncOperation<bool> FlushAsync() => global::ABI.Windows.Storage.Streams.IOutputStreamMethods.FlushAsync(_objRef_global__Windows_Storage_Streams_IOutputStream);

        public void Dispose() => global::ABI.System.IDisposableMethods.Dispose(_objRef_global__System_IDisposable);

        public global::Windows.Foundation.IAsyncOperationWithProgress<IBuffer, uint> ReadAsync(IBuffer buffer, uint count, InputStreamOptions options) => global::ABI.Windows.Storage.Streams.IInputStreamMethods.ReadAsync(_objRef_global__Windows_Storage_Streams_IInputStream, buffer, count, options);

        public bool CanRead => global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.get_CanRead(_objRef_global__Windows_Storage_Streams_IRandomAccessStream);

        public bool CanWrite => global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.get_CanWrite(_objRef_global__Windows_Storage_Streams_IRandomAccessStream);

        public ulong Position => global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.get_Position(_objRef_global__Windows_Storage_Streams_IRandomAccessStream);

        public ulong Size
        {
            get => global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.get_Size(_objRef_global__Windows_Storage_Streams_IRandomAccessStream);
            set => global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.set_Size(_objRef_global__Windows_Storage_Streams_IRandomAccessStream, value);
        }

        private bool IsOverridableInterface(Guid iid) => false;

        global::System.Runtime.InteropServices.CustomQueryInterfaceResult global::System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(ref Guid iid, out IntPtr ppv)
        {
            ppv = IntPtr.Zero;
            if (IsOverridableInterface(iid) || global::WinRT.Interop.IID.IID_IInspectable == iid || global::WinRT.Interop.IID.IID_IWeakReferenceSource == iid)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
            }

            if (((IWinRTObject)this).NativeObject.TryAs(iid, out ppv) >= 0)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.Handled;
            }

            return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
        }
    }
    [FlagsAttribute]
    [global::WinRT.WindowsRuntimeType("Windows.Foundation.UniversalApiContract")][global::WinRT.WinRTExposedType(typeof(global::WinRT.EnumTypeDetails<InputStreamOptions>))][global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    public enum InputStreamOptions : uint
    {
        None = unchecked((uint)0),
        Partial = unchecked((uint)0x1),
        ReadAhead = unchecked((uint)0x2),
    }
    [global::WinRT.WindowsRuntimeType("Windows.Foundation.UniversalApiContract")]
    [global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Windows.Storage.Streams.InputStreamOverStream))]
    [global::ABI.Windows.Storage.Streams.InputStreamOverStreamRcwFactory]
    [global::WinRT.ProjectedRuntimeClass(typeof(IInputStream))]
    [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    public sealed class InputStreamOverStream : IInputStream, global::System.IDisposable, global::System.Runtime.InteropServices.ICustomQueryInterface, IWinRTObject, IEquatable<InputStreamOverStream>
    {
        private IntPtr ThisPtr => _inner == null ? (((IWinRTObject)this).NativeObject).ThisPtr : _inner.ThisPtr;

        private readonly IObjectReference _inner = null;



        private IObjectReference _objRef_global__Windows_Storage_Streams_IInputStream => _inner;
        private volatile IObjectReference ___objRef_global__System_IDisposable;
        private IObjectReference Make___objRef_global__System_IDisposable()
        {
            global::System.Threading.Interlocked.CompareExchange(ref ___objRef_global__System_IDisposable, ((IWinRTObject)this).NativeObject.As<IUnknownVftbl>(global::ABI.System.IDisposableMethods.IID), null);
            return ___objRef_global__System_IDisposable;
        }
        private IObjectReference _objRef_global__System_IDisposable => ___objRef_global__System_IDisposable ?? Make___objRef_global__System_IDisposable();



        public static InputStreamOverStream FromAbi(IntPtr thisPtr)
        {
            if (thisPtr == IntPtr.Zero) return null;
            return MarshalInspectable<InputStreamOverStream>.FromAbi(thisPtr);
        }

        internal InputStreamOverStream(IObjectReference objRef)
        {
            _inner = objRef.As(global::ABI.Windows.Storage.Streams.IInputStreamMethods.IID);

        }


        public static bool operator ==(InputStreamOverStream x, InputStreamOverStream y) => (x?.ThisPtr ?? IntPtr.Zero) == (y?.ThisPtr ?? IntPtr.Zero);
        public static bool operator !=(InputStreamOverStream x, InputStreamOverStream y) => !(x == y);
        public bool Equals(InputStreamOverStream other) => this == other;
        public override bool Equals(object obj) => obj is InputStreamOverStream that && this == that;
        public override int GetHashCode() => ThisPtr.GetHashCode();


        bool IWinRTObject.HasUnwrappableNativeObject => true;
        IObjectReference IWinRTObject.NativeObject => _inner;
        private volatile global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> _queryInterfaceCache;
        private global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> MakeQueryInterfaceCache()
        {
            global::System.Threading.Interlocked.CompareExchange(ref _queryInterfaceCache, new global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference>(), null); 
            return _queryInterfaceCache;
        }
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache => _queryInterfaceCache ?? MakeQueryInterfaceCache();
        private volatile global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> _additionalTypeData;
        private global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> MakeAdditionalTypeData()
        {
            global::System.Threading.Interlocked.CompareExchange(ref _additionalTypeData, new global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object>(), null); 
            return _additionalTypeData;
        }
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData => _additionalTypeData ?? MakeAdditionalTypeData();

        private struct InterfaceTag<I>{};


        public global::Windows.Foundation.IAsyncOperationWithProgress<IBuffer, uint> ReadAsync(IBuffer buffer, uint count, InputStreamOptions options) => global::ABI.Windows.Storage.Streams.IInputStreamMethods.ReadAsync(_objRef_global__Windows_Storage_Streams_IInputStream, buffer, count, options);

        public void Dispose() => global::ABI.System.IDisposableMethods.Dispose(_objRef_global__System_IDisposable);

        private bool IsOverridableInterface(Guid iid) => false;

        global::System.Runtime.InteropServices.CustomQueryInterfaceResult global::System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(ref Guid iid, out IntPtr ppv)
        {
            ppv = IntPtr.Zero;
            if (IsOverridableInterface(iid) || global::WinRT.Interop.IID.IID_IInspectable == iid || global::WinRT.Interop.IID.IID_IWeakReferenceSource == iid)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
            }

            if (((IWinRTObject)this).NativeObject.TryAs(iid, out ppv) >= 0)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.Handled;
            }

            return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
        }
    }
    [global::WinRT.WindowsRuntimeType("Windows.Foundation.UniversalApiContract")]
    [global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Windows.Storage.Streams.OutputStreamOverStream))]
    [global::ABI.Windows.Storage.Streams.OutputStreamOverStreamRcwFactory]
    [global::WinRT.ProjectedRuntimeClass(typeof(IOutputStream))]
    [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    public sealed class OutputStreamOverStream : IOutputStream, global::System.IDisposable, global::System.Runtime.InteropServices.ICustomQueryInterface, IWinRTObject, IEquatable<OutputStreamOverStream>
    {
        private IntPtr ThisPtr => _inner == null ? (((IWinRTObject)this).NativeObject).ThisPtr : _inner.ThisPtr;

        private readonly IObjectReference _inner = null;



        private IObjectReference _objRef_global__Windows_Storage_Streams_IOutputStream => _inner;
        private volatile IObjectReference ___objRef_global__System_IDisposable;
        private IObjectReference Make___objRef_global__System_IDisposable()
        {
            global::System.Threading.Interlocked.CompareExchange(ref ___objRef_global__System_IDisposable, ((IWinRTObject)this).NativeObject.As<IUnknownVftbl>(global::ABI.System.IDisposableMethods.IID), null);
            return ___objRef_global__System_IDisposable;
        }
        private IObjectReference _objRef_global__System_IDisposable => ___objRef_global__System_IDisposable ?? Make___objRef_global__System_IDisposable();



        public static OutputStreamOverStream FromAbi(IntPtr thisPtr)
        {
            if (thisPtr == IntPtr.Zero) return null;
            return MarshalInspectable<OutputStreamOverStream>.FromAbi(thisPtr);
        }

        internal OutputStreamOverStream(IObjectReference objRef)
        {
            _inner = objRef.As(global::ABI.Windows.Storage.Streams.IOutputStreamMethods.IID);

        }


        public static bool operator ==(OutputStreamOverStream x, OutputStreamOverStream y) => (x?.ThisPtr ?? IntPtr.Zero) == (y?.ThisPtr ?? IntPtr.Zero);
        public static bool operator !=(OutputStreamOverStream x, OutputStreamOverStream y) => !(x == y);
        public bool Equals(OutputStreamOverStream other) => this == other;
        public override bool Equals(object obj) => obj is OutputStreamOverStream that && this == that;
        public override int GetHashCode() => ThisPtr.GetHashCode();


        bool IWinRTObject.HasUnwrappableNativeObject => true;
        IObjectReference IWinRTObject.NativeObject => _inner;
        private volatile global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> _queryInterfaceCache;
        private global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> MakeQueryInterfaceCache()
        {
            global::System.Threading.Interlocked.CompareExchange(ref _queryInterfaceCache, new global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference>(), null); 
            return _queryInterfaceCache;
        }
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache => _queryInterfaceCache ?? MakeQueryInterfaceCache();
        private volatile global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> _additionalTypeData;
        private global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> MakeAdditionalTypeData()
        {
            global::System.Threading.Interlocked.CompareExchange(ref _additionalTypeData, new global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object>(), null); 
            return _additionalTypeData;
        }
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData => _additionalTypeData ?? MakeAdditionalTypeData();

        private struct InterfaceTag<I>{};


        public global::Windows.Foundation.IAsyncOperationWithProgress<uint, uint> WriteAsync(IBuffer buffer) => global::ABI.Windows.Storage.Streams.IOutputStreamMethods.WriteAsync(_objRef_global__Windows_Storage_Streams_IOutputStream, buffer);

        public global::Windows.Foundation.IAsyncOperation<bool> FlushAsync() => global::ABI.Windows.Storage.Streams.IOutputStreamMethods.FlushAsync(_objRef_global__Windows_Storage_Streams_IOutputStream);

        public void Dispose() => global::ABI.System.IDisposableMethods.Dispose(_objRef_global__System_IDisposable);

        private bool IsOverridableInterface(Guid iid) => false;

        global::System.Runtime.InteropServices.CustomQueryInterfaceResult global::System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(ref Guid iid, out IntPtr ppv)
        {
            ppv = IntPtr.Zero;
            if (IsOverridableInterface(iid) || global::WinRT.Interop.IID.IID_IInspectable == iid || global::WinRT.Interop.IID.IID_IWeakReferenceSource == iid)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
            }

            if (((IWinRTObject)this).NativeObject.TryAs(iid, out ppv) >= 0)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.Handled;
            }

            return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
        }
    }
    [global::WinRT.WindowsRuntimeType("Windows.Foundation.UniversalApiContract")][global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    public static class RandomAccessStream
    {

        public static I As<I>() => ActivationFactory.Get("Windows.Storage.Streams.RandomAccessStream").AsInterface<I>();

        private static volatile IObjectReference ___objRef_global__Windows_Storage_Streams_IRandomAccessStreamStatics;
        private static IObjectReference _objRef_global__Windows_Storage_Streams_IRandomAccessStreamStatics
        {
            get
            { 
                var factory = ___objRef_global__Windows_Storage_Streams_IRandomAccessStreamStatics;
                if (factory != null && factory.IsInCurrentContext)
                {
                    return factory;
                }
                else
                {
                    return ___objRef_global__Windows_Storage_Streams_IRandomAccessStreamStatics = ActivationFactory.Get("Windows.Storage.Streams.RandomAccessStream", global::ABI.Windows.Storage.Streams.IRandomAccessStreamStaticsMethods.IID);
                }
            }
        }

        public static global::Windows.Foundation.IAsyncOperationWithProgress<ulong, ulong> CopyAsync(IInputStream source, IOutputStream destination) => global::ABI.Windows.Storage.Streams.IRandomAccessStreamStaticsMethods.CopyAsync(_objRef_global__Windows_Storage_Streams_IRandomAccessStreamStatics, source, destination);

        public static global::Windows.Foundation.IAsyncOperationWithProgress<ulong, ulong> CopyAsync(IInputStream source, IOutputStream destination, ulong bytesToCopy) => global::ABI.Windows.Storage.Streams.IRandomAccessStreamStaticsMethods.CopyAsync(_objRef_global__Windows_Storage_Streams_IRandomAccessStreamStatics, source, destination, bytesToCopy);

        public static global::Windows.Foundation.IAsyncOperationWithProgress<ulong, ulong> CopyAndCloseAsync(IInputStream source, IOutputStream destination) => global::ABI.Windows.Storage.Streams.IRandomAccessStreamStaticsMethods.CopyAndCloseAsync(_objRef_global__Windows_Storage_Streams_IRandomAccessStreamStatics, source, destination);
    }
    [global::WinRT.WindowsRuntimeType("Windows.Foundation.UniversalApiContract")]
    [global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Windows.Storage.Streams.RandomAccessStreamOverStream))]
    [global::ABI.Windows.Storage.Streams.RandomAccessStreamOverStreamRcwFactory]
    [global::WinRT.ProjectedRuntimeClass(typeof(IRandomAccessStream))]
    [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    public sealed class RandomAccessStreamOverStream : IRandomAccessStream, IOutputStream, global::System.IDisposable, IInputStream, global::System.Runtime.InteropServices.ICustomQueryInterface, IWinRTObject, IEquatable<RandomAccessStreamOverStream>
    {
        private IntPtr ThisPtr => _inner == null ? (((IWinRTObject)this).NativeObject).ThisPtr : _inner.ThisPtr;

        private readonly IObjectReference _inner = null;



        private IObjectReference _objRef_global__Windows_Storage_Streams_IRandomAccessStream => _inner;
        private volatile IObjectReference ___objRef_global__Windows_Storage_Streams_IOutputStream;
        private IObjectReference Make___objRef_global__Windows_Storage_Streams_IOutputStream()
        {
            global::System.Threading.Interlocked.CompareExchange(ref ___objRef_global__Windows_Storage_Streams_IOutputStream, ((IWinRTObject)this).NativeObject.As<IUnknownVftbl>(global::ABI.Windows.Storage.Streams.IOutputStreamMethods.IID), null);
            return ___objRef_global__Windows_Storage_Streams_IOutputStream;
        }
        private IObjectReference _objRef_global__Windows_Storage_Streams_IOutputStream => ___objRef_global__Windows_Storage_Streams_IOutputStream ?? Make___objRef_global__Windows_Storage_Streams_IOutputStream();

        private volatile IObjectReference ___objRef_global__System_IDisposable;
        private IObjectReference Make___objRef_global__System_IDisposable()
        {
            global::System.Threading.Interlocked.CompareExchange(ref ___objRef_global__System_IDisposable, ((IWinRTObject)this).NativeObject.As<IUnknownVftbl>(global::ABI.System.IDisposableMethods.IID), null);
            return ___objRef_global__System_IDisposable;
        }
        private IObjectReference _objRef_global__System_IDisposable => ___objRef_global__System_IDisposable ?? Make___objRef_global__System_IDisposable();

        private volatile IObjectReference ___objRef_global__Windows_Storage_Streams_IInputStream;
        private IObjectReference Make___objRef_global__Windows_Storage_Streams_IInputStream()
        {
            global::System.Threading.Interlocked.CompareExchange(ref ___objRef_global__Windows_Storage_Streams_IInputStream, ((IWinRTObject)this).NativeObject.As<IUnknownVftbl>(global::ABI.Windows.Storage.Streams.IInputStreamMethods.IID), null);
            return ___objRef_global__Windows_Storage_Streams_IInputStream;
        }
        private IObjectReference _objRef_global__Windows_Storage_Streams_IInputStream => ___objRef_global__Windows_Storage_Streams_IInputStream ?? Make___objRef_global__Windows_Storage_Streams_IInputStream();



        public static RandomAccessStreamOverStream FromAbi(IntPtr thisPtr)
        {
            if (thisPtr == IntPtr.Zero) return null;
            return MarshalInspectable<RandomAccessStreamOverStream>.FromAbi(thisPtr);
        }

        internal RandomAccessStreamOverStream(IObjectReference objRef)
        {
            _inner = objRef.As(global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.IID);

        }


        public static bool operator ==(RandomAccessStreamOverStream x, RandomAccessStreamOverStream y) => (x?.ThisPtr ?? IntPtr.Zero) == (y?.ThisPtr ?? IntPtr.Zero);
        public static bool operator !=(RandomAccessStreamOverStream x, RandomAccessStreamOverStream y) => !(x == y);
        public bool Equals(RandomAccessStreamOverStream other) => this == other;
        public override bool Equals(object obj) => obj is RandomAccessStreamOverStream that && this == that;
        public override int GetHashCode() => ThisPtr.GetHashCode();


        bool IWinRTObject.HasUnwrappableNativeObject => true;
        IObjectReference IWinRTObject.NativeObject => _inner;
        private volatile global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> _queryInterfaceCache;
        private global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> MakeQueryInterfaceCache()
        {
            global::System.Threading.Interlocked.CompareExchange(ref _queryInterfaceCache, new global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference>(), null); 
            return _queryInterfaceCache;
        }
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache => _queryInterfaceCache ?? MakeQueryInterfaceCache();
        private volatile global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> _additionalTypeData;
        private global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> MakeAdditionalTypeData()
        {
            global::System.Threading.Interlocked.CompareExchange(ref _additionalTypeData, new global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object>(), null); 
            return _additionalTypeData;
        }
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData => _additionalTypeData ?? MakeAdditionalTypeData();

        private struct InterfaceTag<I>{};


        public IInputStream GetInputStreamAt(ulong position) => global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.GetInputStreamAt(_objRef_global__Windows_Storage_Streams_IRandomAccessStream, position);

        public IOutputStream GetOutputStreamAt(ulong position) => global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.GetOutputStreamAt(_objRef_global__Windows_Storage_Streams_IRandomAccessStream, position);

        public void Seek(ulong position) => global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.Seek(_objRef_global__Windows_Storage_Streams_IRandomAccessStream, position);

        public IRandomAccessStream CloneStream() => global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.CloneStream(_objRef_global__Windows_Storage_Streams_IRandomAccessStream);

        public global::Windows.Foundation.IAsyncOperationWithProgress<uint, uint> WriteAsync(IBuffer buffer) => global::ABI.Windows.Storage.Streams.IOutputStreamMethods.WriteAsync(_objRef_global__Windows_Storage_Streams_IOutputStream, buffer);

        public global::Windows.Foundation.IAsyncOperation<bool> FlushAsync() => global::ABI.Windows.Storage.Streams.IOutputStreamMethods.FlushAsync(_objRef_global__Windows_Storage_Streams_IOutputStream);

        public void Dispose() => global::ABI.System.IDisposableMethods.Dispose(_objRef_global__System_IDisposable);

        public global::Windows.Foundation.IAsyncOperationWithProgress<IBuffer, uint> ReadAsync(IBuffer buffer, uint count, InputStreamOptions options) => global::ABI.Windows.Storage.Streams.IInputStreamMethods.ReadAsync(_objRef_global__Windows_Storage_Streams_IInputStream, buffer, count, options);

        public bool CanRead => global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.get_CanRead(_objRef_global__Windows_Storage_Streams_IRandomAccessStream);

        public bool CanWrite => global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.get_CanWrite(_objRef_global__Windows_Storage_Streams_IRandomAccessStream);

        public ulong Position => global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.get_Position(_objRef_global__Windows_Storage_Streams_IRandomAccessStream);

        public ulong Size
        {
            get => global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.get_Size(_objRef_global__Windows_Storage_Streams_IRandomAccessStream);
            set => global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.set_Size(_objRef_global__Windows_Storage_Streams_IRandomAccessStream, value);
        }

        private bool IsOverridableInterface(Guid iid) => false;

        global::System.Runtime.InteropServices.CustomQueryInterfaceResult global::System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(ref Guid iid, out IntPtr ppv)
        {
            ppv = IntPtr.Zero;
            if (IsOverridableInterface(iid) || global::WinRT.Interop.IID.IID_IInspectable == iid || global::WinRT.Interop.IID.IID_IWeakReferenceSource == iid)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
            }

            if (((IWinRTObject)this).NativeObject.TryAs(iid, out ppv) >= 0)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.Handled;
            }

            return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
        }
    }
    [global::WinRT.WindowsRuntimeType("Windows.Foundation.UniversalApiContract")]
    [global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Windows.Storage.Streams.RandomAccessStreamReference))]
    [global::ABI.Windows.Storage.Streams.RandomAccessStreamReferenceRcwFactory]
    [global::WinRT.ProjectedRuntimeClass(typeof(IRandomAccessStreamReference))]
    [global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    public sealed class RandomAccessStreamReference : IRandomAccessStreamReference, global::System.Runtime.InteropServices.ICustomQueryInterface, IWinRTObject, IEquatable<RandomAccessStreamReference>
    {
        private IntPtr ThisPtr => _inner == null ? (((IWinRTObject)this).NativeObject).ThisPtr : _inner.ThisPtr;

        private readonly IObjectReference _inner = null;



        private IObjectReference _objRef_global__Windows_Storage_Streams_IRandomAccessStreamReference => _inner;


        public static I As<I>() => ActivationFactory.Get("Windows.Storage.Streams.RandomAccessStreamReference").AsInterface<I>();

        private static volatile IObjectReference ___objRef_global__Windows_Storage_Streams_IRandomAccessStreamReferenceStatics;
        private static IObjectReference _objRef_global__Windows_Storage_Streams_IRandomAccessStreamReferenceStatics
        {
            get
            { 
                var factory = ___objRef_global__Windows_Storage_Streams_IRandomAccessStreamReferenceStatics;
                if (factory != null && factory.IsInCurrentContext)
                {
                    return factory;
                }
                else
                {
                    return ___objRef_global__Windows_Storage_Streams_IRandomAccessStreamReferenceStatics = ActivationFactory.Get("Windows.Storage.Streams.RandomAccessStreamReference", global::ABI.Windows.Storage.Streams.IRandomAccessStreamReferenceStaticsMethods.IID);
                }
            }
        }

        public static RandomAccessStreamReference CreateFromFile(global::Windows.Storage.IStorageFile file) => global::ABI.Windows.Storage.Streams.IRandomAccessStreamReferenceStaticsMethods.CreateFromFile(_objRef_global__Windows_Storage_Streams_IRandomAccessStreamReferenceStatics, file);

        public static RandomAccessStreamReference CreateFromUri(global::System.Uri uri) => global::ABI.Windows.Storage.Streams.IRandomAccessStreamReferenceStaticsMethods.CreateFromUri(_objRef_global__Windows_Storage_Streams_IRandomAccessStreamReferenceStatics, uri);

        public static RandomAccessStreamReference CreateFromStream(IRandomAccessStream stream) => global::ABI.Windows.Storage.Streams.IRandomAccessStreamReferenceStaticsMethods.CreateFromStream(_objRef_global__Windows_Storage_Streams_IRandomAccessStreamReferenceStatics, stream);

        public static RandomAccessStreamReference FromAbi(IntPtr thisPtr)
        {
            if (thisPtr == IntPtr.Zero) return null;
            return MarshalInspectable<RandomAccessStreamReference>.FromAbi(thisPtr);
        }

        internal RandomAccessStreamReference(IObjectReference objRef)
        {
            _inner = objRef.As(global::ABI.Windows.Storage.Streams.IRandomAccessStreamReferenceMethods.IID);

        }


        public static bool operator ==(RandomAccessStreamReference x, RandomAccessStreamReference y) => (x?.ThisPtr ?? IntPtr.Zero) == (y?.ThisPtr ?? IntPtr.Zero);
        public static bool operator !=(RandomAccessStreamReference x, RandomAccessStreamReference y) => !(x == y);
        public bool Equals(RandomAccessStreamReference other) => this == other;
        public override bool Equals(object obj) => obj is RandomAccessStreamReference that && this == that;
        public override int GetHashCode() => ThisPtr.GetHashCode();


        bool IWinRTObject.HasUnwrappableNativeObject => true;
        IObjectReference IWinRTObject.NativeObject => _inner;
        private volatile global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> _queryInterfaceCache;
        private global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> MakeQueryInterfaceCache()
        {
            global::System.Threading.Interlocked.CompareExchange(ref _queryInterfaceCache, new global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference>(), null); 
            return _queryInterfaceCache;
        }
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache => _queryInterfaceCache ?? MakeQueryInterfaceCache();
        private volatile global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> _additionalTypeData;
        private global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> MakeAdditionalTypeData()
        {
            global::System.Threading.Interlocked.CompareExchange(ref _additionalTypeData, new global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object>(), null); 
            return _additionalTypeData;
        }
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData => _additionalTypeData ?? MakeAdditionalTypeData();

        private struct InterfaceTag<I>{};


        public global::Windows.Foundation.IAsyncOperation<IRandomAccessStreamWithContentType> OpenReadAsync() => global::ABI.Windows.Storage.Streams.IRandomAccessStreamReferenceMethods.OpenReadAsync(_objRef_global__Windows_Storage_Streams_IRandomAccessStreamReference);

        private bool IsOverridableInterface(Guid iid) => false;

        global::System.Runtime.InteropServices.CustomQueryInterfaceResult global::System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(ref Guid iid, out IntPtr ppv)
        {
            ppv = IntPtr.Zero;
            if (IsOverridableInterface(iid) || global::WinRT.Interop.IID.IID_IInspectable == iid || global::WinRT.Interop.IID.IID_IWeakReferenceSource == iid)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
            }

            if (((IWinRTObject)this).NativeObject.TryAs(iid, out ppv) >= 0)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.Handled;
            }

            return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
        }
    }
    [global::WinRT.WindowsRuntimeType("Windows.Foundation.UniversalApiContract")][global::WinRT.WinRTExposedType(typeof(global::WinRT.EnumTypeDetails<UnicodeEncoding>))][global::System.Runtime.Versioning.SupportedOSPlatform("Windows10.0.10240.0")]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(global::Windows.Foundation.UniversalApiContract), 65536u)]
    public enum UnicodeEncoding : int
    {
        Utf8 = unchecked((int)0),
        Utf16LE = unchecked((int)0x1),
        Utf16BE = unchecked((int)0x2),
    }
}

#pragma warning disable CA1416
namespace ABI.Windows.Storage.Streams
{
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public struct Buffer
    {

        public static IObjectReference CreateMarshaler(global::Windows.Storage.Streams.Buffer obj) => obj is null ? null : MarshalInterface<global::Windows.Storage.Streams.IBuffer>.CreateMarshaler(obj);
        public static ObjectReferenceValue CreateMarshaler2(global::Windows.Storage.Streams.Buffer obj) => MarshalInterface<global::Windows.Storage.Streams.IBuffer>.CreateMarshaler2(obj, global::ABI.Windows.Storage.Streams.IBufferMethods.IID);
        public static IntPtr GetAbi(IObjectReference value) => value is null ? IntPtr.Zero : MarshalInterfaceHelper<object>.GetAbi(value);
        public static global::Windows.Storage.Streams.Buffer FromAbi(IntPtr thisPtr) => global::Windows.Storage.Streams.Buffer.FromAbi(thisPtr);
        public static IntPtr FromManaged(global::Windows.Storage.Streams.Buffer obj) => obj is null ? IntPtr.Zero : CreateMarshaler2(obj).Detach();
        public static unsafe MarshalInterfaceHelper<global::Windows.Storage.Streams.Buffer>.MarshalerArray CreateMarshalerArray(global::Windows.Storage.Streams.Buffer[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.Buffer>.CreateMarshalerArray2(array, (o) => CreateMarshaler2(o));
        public static (int length, IntPtr data) GetAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.Buffer>.GetAbiArray(box);
        public static unsafe global::Windows.Storage.Streams.Buffer[] FromAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.Buffer>.FromAbiArray(box, FromAbi);
        public static void CopyAbiArray(global::Windows.Storage.Streams.Buffer[] array, object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.Buffer>.CopyAbiArray(array, box, FromAbi);
        public static (int length, IntPtr data) FromManagedArray(global::Windows.Storage.Streams.Buffer[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.Buffer>.FromManagedArray(array, (o) => FromManaged(o));
        public static void DisposeMarshaler(IObjectReference value) => MarshalInspectable<object>.DisposeMarshaler(value);
        public static void DisposeMarshalerArray(MarshalInterfaceHelper<global::Windows.Storage.Streams.Buffer>.MarshalerArray array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.Buffer>.DisposeMarshalerArray(array);
        public static void DisposeAbi(IntPtr abi) => MarshalInspectable<object>.DisposeAbi(abi);
        public static unsafe void DisposeAbiArray(object box) => MarshalInspectable<object>.DisposeAbiArray(box);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    internal sealed class BufferRcwFactoryAttribute : global::WinRT.WinRTImplementationTypeRcwFactoryAttribute
    {
        public override object CreateInstance(global::WinRT.IInspectable inspectable)
            => new global::Windows.Storage.Streams.Buffer(inspectable.ObjRef);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public struct DataReader
    {

        public static IObjectReference CreateMarshaler(global::Windows.Storage.Streams.DataReader obj) => obj is null ? null : MarshalInterface<global::Windows.Storage.Streams.IDataReader>.CreateMarshaler(obj);
        public static ObjectReferenceValue CreateMarshaler2(global::Windows.Storage.Streams.DataReader obj) => MarshalInterface<global::Windows.Storage.Streams.IDataReader>.CreateMarshaler2(obj, global::ABI.Windows.Storage.Streams.IDataReaderMethods.IID);
        public static IntPtr GetAbi(IObjectReference value) => value is null ? IntPtr.Zero : MarshalInterfaceHelper<object>.GetAbi(value);
        public static global::Windows.Storage.Streams.DataReader FromAbi(IntPtr thisPtr) => global::Windows.Storage.Streams.DataReader.FromAbi(thisPtr);
        public static IntPtr FromManaged(global::Windows.Storage.Streams.DataReader obj) => obj is null ? IntPtr.Zero : CreateMarshaler2(obj).Detach();
        public static unsafe MarshalInterfaceHelper<global::Windows.Storage.Streams.DataReader>.MarshalerArray CreateMarshalerArray(global::Windows.Storage.Streams.DataReader[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataReader>.CreateMarshalerArray2(array, (o) => CreateMarshaler2(o));
        public static (int length, IntPtr data) GetAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataReader>.GetAbiArray(box);
        public static unsafe global::Windows.Storage.Streams.DataReader[] FromAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataReader>.FromAbiArray(box, FromAbi);
        public static void CopyAbiArray(global::Windows.Storage.Streams.DataReader[] array, object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataReader>.CopyAbiArray(array, box, FromAbi);
        public static (int length, IntPtr data) FromManagedArray(global::Windows.Storage.Streams.DataReader[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataReader>.FromManagedArray(array, (o) => FromManaged(o));
        public static void DisposeMarshaler(IObjectReference value) => MarshalInspectable<object>.DisposeMarshaler(value);
        public static void DisposeMarshalerArray(MarshalInterfaceHelper<global::Windows.Storage.Streams.DataReader>.MarshalerArray array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataReader>.DisposeMarshalerArray(array);
        public static void DisposeAbi(IntPtr abi) => MarshalInspectable<object>.DisposeAbi(abi);
        public static unsafe void DisposeAbiArray(object box) => MarshalInspectable<object>.DisposeAbiArray(box);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    internal sealed class DataReaderRcwFactoryAttribute : global::WinRT.WinRTImplementationTypeRcwFactoryAttribute
    {
        public override object CreateInstance(global::WinRT.IInspectable inspectable)
            => new global::Windows.Storage.Streams.DataReader(inspectable.ObjRef);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public struct DataReaderLoadOperation
    {

        public static IObjectReference CreateMarshaler(global::Windows.Storage.Streams.DataReaderLoadOperation obj) => obj is null ? null : MarshalInterface<global::Windows.Foundation.IAsyncOperation<uint>>.CreateMarshaler(obj);
        public static ObjectReferenceValue CreateMarshaler2(global::Windows.Storage.Streams.DataReaderLoadOperation obj) => MarshalInterface<global::Windows.Foundation.IAsyncOperation<uint>>.CreateMarshaler2(obj, global::ABI.Windows.Foundation.IAsyncOperationMethods<uint>.IID);
        public static IntPtr GetAbi(IObjectReference value) => value is null ? IntPtr.Zero : MarshalInterfaceHelper<object>.GetAbi(value);
        public static global::Windows.Storage.Streams.DataReaderLoadOperation FromAbi(IntPtr thisPtr) => global::Windows.Storage.Streams.DataReaderLoadOperation.FromAbi(thisPtr);
        public static IntPtr FromManaged(global::Windows.Storage.Streams.DataReaderLoadOperation obj) => obj is null ? IntPtr.Zero : CreateMarshaler2(obj).Detach();
        public static unsafe MarshalInterfaceHelper<global::Windows.Storage.Streams.DataReaderLoadOperation>.MarshalerArray CreateMarshalerArray(global::Windows.Storage.Streams.DataReaderLoadOperation[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataReaderLoadOperation>.CreateMarshalerArray2(array, (o) => CreateMarshaler2(o));
        public static (int length, IntPtr data) GetAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataReaderLoadOperation>.GetAbiArray(box);
        public static unsafe global::Windows.Storage.Streams.DataReaderLoadOperation[] FromAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataReaderLoadOperation>.FromAbiArray(box, FromAbi);
        public static void CopyAbiArray(global::Windows.Storage.Streams.DataReaderLoadOperation[] array, object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataReaderLoadOperation>.CopyAbiArray(array, box, FromAbi);
        public static (int length, IntPtr data) FromManagedArray(global::Windows.Storage.Streams.DataReaderLoadOperation[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataReaderLoadOperation>.FromManagedArray(array, (o) => FromManaged(o));
        public static void DisposeMarshaler(IObjectReference value) => MarshalInspectable<object>.DisposeMarshaler(value);
        public static void DisposeMarshalerArray(MarshalInterfaceHelper<global::Windows.Storage.Streams.DataReaderLoadOperation>.MarshalerArray array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataReaderLoadOperation>.DisposeMarshalerArray(array);
        public static void DisposeAbi(IntPtr abi) => MarshalInspectable<object>.DisposeAbi(abi);
        public static unsafe void DisposeAbiArray(object box) => MarshalInspectable<object>.DisposeAbiArray(box);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    internal sealed class DataReaderLoadOperationRcwFactoryAttribute : global::WinRT.WinRTImplementationTypeRcwFactoryAttribute
    {
        public override object CreateInstance(global::WinRT.IInspectable inspectable)
            => new global::Windows.Storage.Streams.DataReaderLoadOperation(inspectable.ObjRef);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public struct DataWriter
    {

        public static IObjectReference CreateMarshaler(global::Windows.Storage.Streams.DataWriter obj) => obj is null ? null : MarshalInterface<global::Windows.Storage.Streams.IDataWriter>.CreateMarshaler(obj);
        public static ObjectReferenceValue CreateMarshaler2(global::Windows.Storage.Streams.DataWriter obj) => MarshalInterface<global::Windows.Storage.Streams.IDataWriter>.CreateMarshaler2(obj, global::ABI.Windows.Storage.Streams.IDataWriterMethods.IID);
        public static IntPtr GetAbi(IObjectReference value) => value is null ? IntPtr.Zero : MarshalInterfaceHelper<object>.GetAbi(value);
        public static global::Windows.Storage.Streams.DataWriter FromAbi(IntPtr thisPtr) => global::Windows.Storage.Streams.DataWriter.FromAbi(thisPtr);
        public static IntPtr FromManaged(global::Windows.Storage.Streams.DataWriter obj) => obj is null ? IntPtr.Zero : CreateMarshaler2(obj).Detach();
        public static unsafe MarshalInterfaceHelper<global::Windows.Storage.Streams.DataWriter>.MarshalerArray CreateMarshalerArray(global::Windows.Storage.Streams.DataWriter[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataWriter>.CreateMarshalerArray2(array, (o) => CreateMarshaler2(o));
        public static (int length, IntPtr data) GetAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataWriter>.GetAbiArray(box);
        public static unsafe global::Windows.Storage.Streams.DataWriter[] FromAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataWriter>.FromAbiArray(box, FromAbi);
        public static void CopyAbiArray(global::Windows.Storage.Streams.DataWriter[] array, object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataWriter>.CopyAbiArray(array, box, FromAbi);
        public static (int length, IntPtr data) FromManagedArray(global::Windows.Storage.Streams.DataWriter[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataWriter>.FromManagedArray(array, (o) => FromManaged(o));
        public static void DisposeMarshaler(IObjectReference value) => MarshalInspectable<object>.DisposeMarshaler(value);
        public static void DisposeMarshalerArray(MarshalInterfaceHelper<global::Windows.Storage.Streams.DataWriter>.MarshalerArray array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataWriter>.DisposeMarshalerArray(array);
        public static void DisposeAbi(IntPtr abi) => MarshalInspectable<object>.DisposeAbi(abi);
        public static unsafe void DisposeAbiArray(object box) => MarshalInspectable<object>.DisposeAbiArray(box);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    internal sealed class DataWriterRcwFactoryAttribute : global::WinRT.WinRTImplementationTypeRcwFactoryAttribute
    {
        public override object CreateInstance(global::WinRT.IInspectable inspectable)
            => new global::Windows.Storage.Streams.DataWriter(inspectable.ObjRef);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public struct DataWriterStoreOperation
    {

        public static IObjectReference CreateMarshaler(global::Windows.Storage.Streams.DataWriterStoreOperation obj) => obj is null ? null : MarshalInterface<global::Windows.Foundation.IAsyncOperation<uint>>.CreateMarshaler(obj);
        public static ObjectReferenceValue CreateMarshaler2(global::Windows.Storage.Streams.DataWriterStoreOperation obj) => MarshalInterface<global::Windows.Foundation.IAsyncOperation<uint>>.CreateMarshaler2(obj, global::ABI.Windows.Foundation.IAsyncOperationMethods<uint>.IID);
        public static IntPtr GetAbi(IObjectReference value) => value is null ? IntPtr.Zero : MarshalInterfaceHelper<object>.GetAbi(value);
        public static global::Windows.Storage.Streams.DataWriterStoreOperation FromAbi(IntPtr thisPtr) => global::Windows.Storage.Streams.DataWriterStoreOperation.FromAbi(thisPtr);
        public static IntPtr FromManaged(global::Windows.Storage.Streams.DataWriterStoreOperation obj) => obj is null ? IntPtr.Zero : CreateMarshaler2(obj).Detach();
        public static unsafe MarshalInterfaceHelper<global::Windows.Storage.Streams.DataWriterStoreOperation>.MarshalerArray CreateMarshalerArray(global::Windows.Storage.Streams.DataWriterStoreOperation[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataWriterStoreOperation>.CreateMarshalerArray2(array, (o) => CreateMarshaler2(o));
        public static (int length, IntPtr data) GetAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataWriterStoreOperation>.GetAbiArray(box);
        public static unsafe global::Windows.Storage.Streams.DataWriterStoreOperation[] FromAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataWriterStoreOperation>.FromAbiArray(box, FromAbi);
        public static void CopyAbiArray(global::Windows.Storage.Streams.DataWriterStoreOperation[] array, object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataWriterStoreOperation>.CopyAbiArray(array, box, FromAbi);
        public static (int length, IntPtr data) FromManagedArray(global::Windows.Storage.Streams.DataWriterStoreOperation[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataWriterStoreOperation>.FromManagedArray(array, (o) => FromManaged(o));
        public static void DisposeMarshaler(IObjectReference value) => MarshalInspectable<object>.DisposeMarshaler(value);
        public static void DisposeMarshalerArray(MarshalInterfaceHelper<global::Windows.Storage.Streams.DataWriterStoreOperation>.MarshalerArray array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.DataWriterStoreOperation>.DisposeMarshalerArray(array);
        public static void DisposeAbi(IntPtr abi) => MarshalInspectable<object>.DisposeAbi(abi);
        public static unsafe void DisposeAbiArray(object box) => MarshalInspectable<object>.DisposeAbiArray(box);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    internal sealed class DataWriterStoreOperationRcwFactoryAttribute : global::WinRT.WinRTImplementationTypeRcwFactoryAttribute
    {
        public override object CreateInstance(global::WinRT.IInspectable inspectable)
            => new global::Windows.Storage.Streams.DataWriterStoreOperation(inspectable.ObjRef);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public struct FileInputStream
    {

        public static IObjectReference CreateMarshaler(global::Windows.Storage.Streams.FileInputStream obj) => obj is null ? null : MarshalInterface<global::Windows.Storage.Streams.IInputStream>.CreateMarshaler(obj);
        public static ObjectReferenceValue CreateMarshaler2(global::Windows.Storage.Streams.FileInputStream obj) => MarshalInterface<global::Windows.Storage.Streams.IInputStream>.CreateMarshaler2(obj, global::ABI.Windows.Storage.Streams.IInputStreamMethods.IID);
        public static IntPtr GetAbi(IObjectReference value) => value is null ? IntPtr.Zero : MarshalInterfaceHelper<object>.GetAbi(value);
        public static global::Windows.Storage.Streams.FileInputStream FromAbi(IntPtr thisPtr) => global::Windows.Storage.Streams.FileInputStream.FromAbi(thisPtr);
        public static IntPtr FromManaged(global::Windows.Storage.Streams.FileInputStream obj) => obj is null ? IntPtr.Zero : CreateMarshaler2(obj).Detach();
        public static unsafe MarshalInterfaceHelper<global::Windows.Storage.Streams.FileInputStream>.MarshalerArray CreateMarshalerArray(global::Windows.Storage.Streams.FileInputStream[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.FileInputStream>.CreateMarshalerArray2(array, (o) => CreateMarshaler2(o));
        public static (int length, IntPtr data) GetAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.FileInputStream>.GetAbiArray(box);
        public static unsafe global::Windows.Storage.Streams.FileInputStream[] FromAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.FileInputStream>.FromAbiArray(box, FromAbi);
        public static void CopyAbiArray(global::Windows.Storage.Streams.FileInputStream[] array, object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.FileInputStream>.CopyAbiArray(array, box, FromAbi);
        public static (int length, IntPtr data) FromManagedArray(global::Windows.Storage.Streams.FileInputStream[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.FileInputStream>.FromManagedArray(array, (o) => FromManaged(o));
        public static void DisposeMarshaler(IObjectReference value) => MarshalInspectable<object>.DisposeMarshaler(value);
        public static void DisposeMarshalerArray(MarshalInterfaceHelper<global::Windows.Storage.Streams.FileInputStream>.MarshalerArray array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.FileInputStream>.DisposeMarshalerArray(array);
        public static void DisposeAbi(IntPtr abi) => MarshalInspectable<object>.DisposeAbi(abi);
        public static unsafe void DisposeAbiArray(object box) => MarshalInspectable<object>.DisposeAbiArray(box);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    internal sealed class FileInputStreamRcwFactoryAttribute : global::WinRT.WinRTImplementationTypeRcwFactoryAttribute
    {
        public override object CreateInstance(global::WinRT.IInspectable inspectable)
            => new global::Windows.Storage.Streams.FileInputStream(inspectable.ObjRef);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public struct FileOutputStream
    {

        public static IObjectReference CreateMarshaler(global::Windows.Storage.Streams.FileOutputStream obj) => obj is null ? null : MarshalInterface<global::Windows.Storage.Streams.IOutputStream>.CreateMarshaler(obj);
        public static ObjectReferenceValue CreateMarshaler2(global::Windows.Storage.Streams.FileOutputStream obj) => MarshalInterface<global::Windows.Storage.Streams.IOutputStream>.CreateMarshaler2(obj, global::ABI.Windows.Storage.Streams.IOutputStreamMethods.IID);
        public static IntPtr GetAbi(IObjectReference value) => value is null ? IntPtr.Zero : MarshalInterfaceHelper<object>.GetAbi(value);
        public static global::Windows.Storage.Streams.FileOutputStream FromAbi(IntPtr thisPtr) => global::Windows.Storage.Streams.FileOutputStream.FromAbi(thisPtr);
        public static IntPtr FromManaged(global::Windows.Storage.Streams.FileOutputStream obj) => obj is null ? IntPtr.Zero : CreateMarshaler2(obj).Detach();
        public static unsafe MarshalInterfaceHelper<global::Windows.Storage.Streams.FileOutputStream>.MarshalerArray CreateMarshalerArray(global::Windows.Storage.Streams.FileOutputStream[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.FileOutputStream>.CreateMarshalerArray2(array, (o) => CreateMarshaler2(o));
        public static (int length, IntPtr data) GetAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.FileOutputStream>.GetAbiArray(box);
        public static unsafe global::Windows.Storage.Streams.FileOutputStream[] FromAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.FileOutputStream>.FromAbiArray(box, FromAbi);
        public static void CopyAbiArray(global::Windows.Storage.Streams.FileOutputStream[] array, object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.FileOutputStream>.CopyAbiArray(array, box, FromAbi);
        public static (int length, IntPtr data) FromManagedArray(global::Windows.Storage.Streams.FileOutputStream[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.FileOutputStream>.FromManagedArray(array, (o) => FromManaged(o));
        public static void DisposeMarshaler(IObjectReference value) => MarshalInspectable<object>.DisposeMarshaler(value);
        public static void DisposeMarshalerArray(MarshalInterfaceHelper<global::Windows.Storage.Streams.FileOutputStream>.MarshalerArray array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.FileOutputStream>.DisposeMarshalerArray(array);
        public static void DisposeAbi(IntPtr abi) => MarshalInspectable<object>.DisposeAbi(abi);
        public static unsafe void DisposeAbiArray(object box) => MarshalInspectable<object>.DisposeAbiArray(box);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    internal sealed class FileOutputStreamRcwFactoryAttribute : global::WinRT.WinRTImplementationTypeRcwFactoryAttribute
    {
        public override object CreateInstance(global::WinRT.IInspectable inspectable)
            => new global::Windows.Storage.Streams.FileOutputStream(inspectable.ObjRef);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public struct FileRandomAccessStream
    {

        public static IObjectReference CreateMarshaler(global::Windows.Storage.Streams.FileRandomAccessStream obj) => obj is null ? null : MarshalInterface<global::Windows.Storage.Streams.IRandomAccessStream>.CreateMarshaler(obj);
        public static ObjectReferenceValue CreateMarshaler2(global::Windows.Storage.Streams.FileRandomAccessStream obj) => MarshalInterface<global::Windows.Storage.Streams.IRandomAccessStream>.CreateMarshaler2(obj, global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.IID);
        public static IntPtr GetAbi(IObjectReference value) => value is null ? IntPtr.Zero : MarshalInterfaceHelper<object>.GetAbi(value);
        public static global::Windows.Storage.Streams.FileRandomAccessStream FromAbi(IntPtr thisPtr) => global::Windows.Storage.Streams.FileRandomAccessStream.FromAbi(thisPtr);
        public static IntPtr FromManaged(global::Windows.Storage.Streams.FileRandomAccessStream obj) => obj is null ? IntPtr.Zero : CreateMarshaler2(obj).Detach();
        public static unsafe MarshalInterfaceHelper<global::Windows.Storage.Streams.FileRandomAccessStream>.MarshalerArray CreateMarshalerArray(global::Windows.Storage.Streams.FileRandomAccessStream[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.FileRandomAccessStream>.CreateMarshalerArray2(array, (o) => CreateMarshaler2(o));
        public static (int length, IntPtr data) GetAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.FileRandomAccessStream>.GetAbiArray(box);
        public static unsafe global::Windows.Storage.Streams.FileRandomAccessStream[] FromAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.FileRandomAccessStream>.FromAbiArray(box, FromAbi);
        public static void CopyAbiArray(global::Windows.Storage.Streams.FileRandomAccessStream[] array, object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.FileRandomAccessStream>.CopyAbiArray(array, box, FromAbi);
        public static (int length, IntPtr data) FromManagedArray(global::Windows.Storage.Streams.FileRandomAccessStream[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.FileRandomAccessStream>.FromManagedArray(array, (o) => FromManaged(o));
        public static void DisposeMarshaler(IObjectReference value) => MarshalInspectable<object>.DisposeMarshaler(value);
        public static void DisposeMarshalerArray(MarshalInterfaceHelper<global::Windows.Storage.Streams.FileRandomAccessStream>.MarshalerArray array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.FileRandomAccessStream>.DisposeMarshalerArray(array);
        public static void DisposeAbi(IntPtr abi) => MarshalInspectable<object>.DisposeAbi(abi);
        public static unsafe void DisposeAbiArray(object box) => MarshalInspectable<object>.DisposeAbiArray(box);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    internal sealed class FileRandomAccessStreamRcwFactoryAttribute : global::WinRT.WinRTImplementationTypeRcwFactoryAttribute
    {
        public override object CreateInstance(global::WinRT.IInspectable inspectable)
            => new global::Windows.Storage.Streams.FileRandomAccessStream(inspectable.ObjRef);
    }
    public static class IBufferMethods
    {

        public static unsafe uint get_Capacity(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            uint __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, uint*, int>**)ThisPtr)[6](ThisPtr, &__retval));
            global::System.GC.KeepAlive(_obj);
            return __retval;
        }

        public static unsafe uint get_Length(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            uint __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, uint*, int>**)ThisPtr)[7](ThisPtr, &__retval));
            global::System.GC.KeepAlive(_obj);
            return __retval;
        }
        public static unsafe void set_Length(IObjectReference _obj, uint value)
        {
            var ThisPtr = _obj.ThisPtr;

            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, uint, int>**)ThisPtr)[8](ThisPtr, value));
            global::System.GC.KeepAlive(_obj);
        }



        public static ref readonly global::System.Guid IID
        {
            [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            get
            {
                global::System.ReadOnlySpan<byte> data = new byte[] { 0xE0, 0xF, 0x5A, 0x90, 0x53, 0xBC, 0xDF, 0x11, 0x8C, 0x49, 0x0, 0x1E, 0x4F, 0xC6, 0x86, 0xDA };
                return ref global::System.Runtime.CompilerServices.Unsafe.As<byte, global::System.Guid>(ref global::System.Runtime.InteropServices.MemoryMarshal.GetReference(data));
            }
        }

        public static global::System.IntPtr AbiToProjectionVftablePtr => IBuffer.AbiToProjectionVftablePtr;

    }
    [DynamicInterfaceCastableImplementation]
    [Guid("905A0FE0-BC53-11DF-8C49-001E4FC686DA")]
    internal unsafe interface IBuffer : global::Windows.Storage.Streams.IBuffer
    {

        public static readonly IntPtr AbiToProjectionVftablePtr;
        static unsafe IBuffer()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IBuffer), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 3);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;
            ((delegate* unmanaged[Stdcall]<IntPtr, uint*, int>*)AbiToProjectionVftablePtr)[6] = &Do_Abi_get_Capacity_0;
            ((delegate* unmanaged[Stdcall]<IntPtr, uint*, int>*)AbiToProjectionVftablePtr)[7] = &Do_Abi_get_Length_1;
            ((delegate* unmanaged[Stdcall]<IntPtr, uint, int>*)AbiToProjectionVftablePtr)[8] = &Do_Abi_put_Length_2;
        }

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_Capacity_0(IntPtr thisPtr, uint* value)
        {

            uint __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IBuffer>(thisPtr).Capacity;
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_put_Length_2(IntPtr thisPtr, uint value)
        {



            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IBuffer>(thisPtr).Length = value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_Length_1(IntPtr thisPtr, uint* value)
        {

            uint __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IBuffer>(thisPtr).Length;
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }

        unsafe uint global::Windows.Storage.Streams.IBuffer.Capacity
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IBuffer).TypeHandle));
                return global::ABI.Windows.Storage.Streams.IBufferMethods.get_Capacity(_obj);
            }
        }

        unsafe uint global::Windows.Storage.Streams.IBuffer.Length
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IBuffer).TypeHandle));
                return global::ABI.Windows.Storage.Streams.IBufferMethods.get_Length(_obj);
            }
            set
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IBuffer).TypeHandle));
                global::ABI.Windows.Storage.Streams.IBufferMethods.set_Length(_obj, value);
            }
        }
    }

    internal static class IBufferFactoryMethods
    {


        internal static unsafe global::Windows.Storage.Streams.Buffer Create(IObjectReference _obj, uint capacity)
        {
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, uint, IntPtr*, int>**)ThisPtr)[6](ThisPtr, capacity, &__retval));
                global::System.GC.KeepAlive(_obj);
                return global::ABI.Windows.Storage.Streams.Buffer.FromAbi(__retval);
            }
            finally
            {
                global::ABI.Windows.Storage.Streams.Buffer.DisposeAbi(__retval);
            }
        }


        public static ref readonly global::System.Guid IID
        {
            [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            get
            {
                global::System.ReadOnlySpan<byte> data = new byte[] { 0x4D, 0x91, 0xAF, 0x71, 0xF, 0xC1, 0x4B, 0x48, 0xBC, 0x50, 0x14, 0xBC, 0x62, 0x3B, 0x3A, 0x27 };
                return ref global::System.Runtime.CompilerServices.Unsafe.As<byte, global::System.Guid>(ref global::System.Runtime.InteropServices.MemoryMarshal.GetReference(data));
            }
        }

    }
    [Guid("71AF914D-C10F-484B-BC50-14BC623B3A27")]
    internal interface IBufferFactory : global::Windows.Storage.Streams.IBufferFactory
    {
    }
    internal static class IBufferStaticsMethods
    {


        internal static unsafe global::Windows.Storage.Streams.Buffer CreateCopyFromMemoryBuffer(IObjectReference _obj, global::Windows.Foundation.IMemoryBuffer input)
        {
            var ThisPtr = _obj.ThisPtr;

            ObjectReferenceValue __input = default;
            IntPtr __retval = default;
            try
            {
                __input = MarshalInterface<global::Windows.Foundation.IMemoryBuffer>.CreateMarshaler2(input, global::ABI.Windows.Foundation.IMemoryBufferMethods.IID);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr*, int>**)ThisPtr)[6](ThisPtr, MarshalInspectable<object>.GetAbi(__input), &__retval));
                global::System.GC.KeepAlive(_obj);
                return global::ABI.Windows.Storage.Streams.Buffer.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeMarshaler(__input);
                global::ABI.Windows.Storage.Streams.Buffer.DisposeAbi(__retval);
            }
        }

        internal static unsafe global::Windows.Foundation.MemoryBuffer CreateMemoryBufferOverIBuffer(IObjectReference _obj, global::Windows.Storage.Streams.IBuffer input)
        {
            var ThisPtr = _obj.ThisPtr;

            ObjectReferenceValue __input = default;
            IntPtr __retval = default;
            try
            {
                __input = MarshalInterface<global::Windows.Storage.Streams.IBuffer>.CreateMarshaler2(input, global::ABI.Windows.Storage.Streams.IBufferMethods.IID);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr*, int>**)ThisPtr)[7](ThisPtr, MarshalInspectable<object>.GetAbi(__input), &__retval));
                global::System.GC.KeepAlive(_obj);
                return global::ABI.Windows.Foundation.MemoryBuffer.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeMarshaler(__input);
                global::ABI.Windows.Foundation.MemoryBuffer.DisposeAbi(__retval);
            }
        }


        public static ref readonly global::System.Guid IID
        {
            [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            get
            {
                global::System.ReadOnlySpan<byte> data = new byte[] { 0x5B, 0xE6, 0x1, 0xE9, 0x16, 0xD7, 0x5A, 0x47, 0xA9, 0xA, 0xAF, 0x72, 0x29, 0xB1, 0xE7, 0x41 };
                return ref global::System.Runtime.CompilerServices.Unsafe.As<byte, global::System.Guid>(ref global::System.Runtime.InteropServices.MemoryMarshal.GetReference(data));
            }
        }

    }
    [Guid("E901E65B-D716-475A-A90A-AF7229B1E741")]
    internal interface IBufferStatics : global::Windows.Storage.Streams.IBufferStatics
    {
    }
    public static class IContentTypeProviderMethods
    {

        public static unsafe string get_ContentType(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>**)ThisPtr)[6](ThisPtr, &__retval));
                global::System.GC.KeepAlive(_obj);
                return MarshalString.FromAbi(__retval);
            }
            finally
            {
                MarshalString.DisposeAbi(__retval);
            }
        }



        public static ref readonly global::System.Guid IID
        {
            [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            get
            {
                global::System.ReadOnlySpan<byte> data = new byte[] { 0xA5, 0x98, 0xD0, 0x97, 0x99, 0x3B, 0xE9, 0x4D, 0x88, 0xA5, 0xE1, 0x1D, 0x2F, 0x50, 0xC7, 0x95 };
                return ref global::System.Runtime.CompilerServices.Unsafe.As<byte, global::System.Guid>(ref global::System.Runtime.InteropServices.MemoryMarshal.GetReference(data));
            }
        }

        public static global::System.IntPtr AbiToProjectionVftablePtr => IContentTypeProvider.AbiToProjectionVftablePtr;

    }
    [DynamicInterfaceCastableImplementation]
    [Guid("97D098A5-3B99-4DE9-88A5-E11D2F50C795")]
    internal unsafe interface IContentTypeProvider : global::Windows.Storage.Streams.IContentTypeProvider
    {

        public static readonly IntPtr AbiToProjectionVftablePtr;
        static unsafe IContentTypeProvider()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IContentTypeProvider), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 1);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[6] = &Do_Abi_get_ContentType_0;
        }

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_ContentType_0(IntPtr thisPtr, IntPtr* value)
        {

            string __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IContentTypeProvider>(thisPtr).ContentType;
                *value = MarshalString.FromManaged(__value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }

        unsafe string global::Windows.Storage.Streams.IContentTypeProvider.ContentType
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IContentTypeProvider).TypeHandle));
                return global::ABI.Windows.Storage.Streams.IContentTypeProviderMethods.get_ContentType(_obj);
            }
        }
    }

    public static class IDataReaderMethods
    {


        public static unsafe byte ReadByte(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            byte __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, byte*, int>**)ThisPtr)[13](ThisPtr, &__retval));
            global::System.GC.KeepAlive(_obj);
            return __retval;
        }

        public static unsafe void ReadBytes(IObjectReference _obj, byte[] value)
        {
            var ThisPtr = _obj.ThisPtr;

            MarshalBlittable<byte>.MarshalerArray __value = default;
            int __value_length = default;
            IntPtr __value_data = default;
            try
            {
                __value = MarshalBlittable<byte>.CreateMarshalerArray(value);
                (__value_length, __value_data) = MarshalBlittable<byte>.GetAbiArray(__value);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, int>**)ThisPtr)[14](ThisPtr, __value_length, __value_data));
                global::System.GC.KeepAlive(_obj);
            }
            finally
            {
                MarshalBlittable<byte>.DisposeMarshalerArray(__value);
            }
        }

        public static unsafe global::Windows.Storage.Streams.IBuffer ReadBuffer(IObjectReference _obj, uint length)
        {
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, uint, IntPtr*, int>**)ThisPtr)[15](ThisPtr, length, &__retval));
                global::System.GC.KeepAlive(_obj);
                return MarshalInterface<global::Windows.Storage.Streams.IBuffer>.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::Windows.Storage.Streams.IBuffer>.DisposeAbi(__retval);
            }
        }

        public static unsafe bool ReadBoolean(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            byte __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, byte*, int>**)ThisPtr)[16](ThisPtr, &__retval));
            global::System.GC.KeepAlive(_obj);
            return __retval != 0;
        }

        public static unsafe Guid ReadGuid(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            Guid __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, Guid*, int>**)ThisPtr)[17](ThisPtr, &__retval));
            global::System.GC.KeepAlive(_obj);
            return __retval;
        }

        public static unsafe short ReadInt16(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            short __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, short*, int>**)ThisPtr)[18](ThisPtr, &__retval));
            global::System.GC.KeepAlive(_obj);
            return __retval;
        }

        public static unsafe int ReadInt32(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            int __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, int*, int>**)ThisPtr)[19](ThisPtr, &__retval));
            global::System.GC.KeepAlive(_obj);
            return __retval;
        }

        public static unsafe long ReadInt64(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            long __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, long*, int>**)ThisPtr)[20](ThisPtr, &__retval));
            global::System.GC.KeepAlive(_obj);
            return __retval;
        }

        public static unsafe ushort ReadUInt16(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            ushort __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, ushort*, int>**)ThisPtr)[21](ThisPtr, &__retval));
            global::System.GC.KeepAlive(_obj);
            return __retval;
        }

        public static unsafe uint ReadUInt32(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            uint __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, uint*, int>**)ThisPtr)[22](ThisPtr, &__retval));
            global::System.GC.KeepAlive(_obj);
            return __retval;
        }

        public static unsafe ulong ReadUInt64(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            ulong __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, ulong*, int>**)ThisPtr)[23](ThisPtr, &__retval));
            global::System.GC.KeepAlive(_obj);
            return __retval;
        }

        public static unsafe float ReadSingle(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            float __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, float*, int>**)ThisPtr)[24](ThisPtr, &__retval));
            global::System.GC.KeepAlive(_obj);
            return __retval;
        }

        public static unsafe double ReadDouble(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            double __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, double*, int>**)ThisPtr)[25](ThisPtr, &__retval));
            global::System.GC.KeepAlive(_obj);
            return __retval;
        }

        public static unsafe string ReadString(IObjectReference _obj, uint codeUnitCount)
        {
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, uint, IntPtr*, int>**)ThisPtr)[26](ThisPtr, codeUnitCount, &__retval));
                global::System.GC.KeepAlive(_obj);
                return MarshalString.FromAbi(__retval);
            }
            finally
            {
                MarshalString.DisposeAbi(__retval);
            }
        }

        public static unsafe global::System.DateTimeOffset ReadDateTime(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            global::ABI.System.DateTimeOffset __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, global::ABI.System.DateTimeOffset*, int>**)ThisPtr)[27](ThisPtr, &__retval));
                global::System.GC.KeepAlive(_obj);
                return global::ABI.System.DateTimeOffset.FromAbi(__retval);
            }
            finally
            {
                global::ABI.System.DateTimeOffset.DisposeAbi(__retval);
            }
        }

        public static unsafe global::System.TimeSpan ReadTimeSpan(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            global::ABI.System.TimeSpan __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, global::ABI.System.TimeSpan*, int>**)ThisPtr)[28](ThisPtr, &__retval));
                global::System.GC.KeepAlive(_obj);
                return global::ABI.System.TimeSpan.FromAbi(__retval);
            }
            finally
            {
                global::ABI.System.TimeSpan.DisposeAbi(__retval);
            }
        }

        public static unsafe global::Windows.Storage.Streams.DataReaderLoadOperation LoadAsync(IObjectReference _obj, uint count)
        {
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, uint, IntPtr*, int>**)ThisPtr)[29](ThisPtr, count, &__retval));
                global::System.GC.KeepAlive(_obj);
                return global::ABI.Windows.Storage.Streams.DataReaderLoadOperation.FromAbi(__retval);
            }
            finally
            {
                global::ABI.Windows.Storage.Streams.DataReaderLoadOperation.DisposeAbi(__retval);
            }
        }

        public static unsafe global::Windows.Storage.Streams.IBuffer DetachBuffer(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>**)ThisPtr)[30](ThisPtr, &__retval));
                global::System.GC.KeepAlive(_obj);
                return MarshalInterface<global::Windows.Storage.Streams.IBuffer>.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::Windows.Storage.Streams.IBuffer>.DisposeAbi(__retval);
            }
        }

        public static unsafe global::Windows.Storage.Streams.IInputStream DetachStream(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>**)ThisPtr)[31](ThisPtr, &__retval));
                global::System.GC.KeepAlive(_obj);
                return MarshalInterface<global::Windows.Storage.Streams.IInputStream>.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::Windows.Storage.Streams.IInputStream>.DisposeAbi(__retval);
            }
        }
        public static unsafe global::Windows.Storage.Streams.ByteOrder get_ByteOrder(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            global::Windows.Storage.Streams.ByteOrder __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, global::Windows.Storage.Streams.ByteOrder*, int>**)ThisPtr)[9](ThisPtr, &__retval));
            global::System.GC.KeepAlive(_obj);
            return __retval;
        }
        public static unsafe void set_ByteOrder(IObjectReference _obj, global::Windows.Storage.Streams.ByteOrder value)
        {
            var ThisPtr = _obj.ThisPtr;

            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, global::Windows.Storage.Streams.ByteOrder, int>**)ThisPtr)[10](ThisPtr, value));
            global::System.GC.KeepAlive(_obj);
        }

        public static unsafe global::Windows.Storage.Streams.InputStreamOptions get_InputStreamOptions(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            global::Windows.Storage.Streams.InputStreamOptions __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, global::Windows.Storage.Streams.InputStreamOptions*, int>**)ThisPtr)[11](ThisPtr, &__retval));
            global::System.GC.KeepAlive(_obj);
            return __retval;
        }
        public static unsafe void set_InputStreamOptions(IObjectReference _obj, global::Windows.Storage.Streams.InputStreamOptions value)
        {
            var ThisPtr = _obj.ThisPtr;

            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, global::Windows.Storage.Streams.InputStreamOptions, int>**)ThisPtr)[12](ThisPtr, value));
            global::System.GC.KeepAlive(_obj);
        }

        public static unsafe uint get_UnconsumedBufferLength(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            uint __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, uint*, int>**)ThisPtr)[6](ThisPtr, &__retval));
            global::System.GC.KeepAlive(_obj);
            return __retval;
        }

        public static unsafe global::Windows.Storage.Streams.UnicodeEncoding get_UnicodeEncoding(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            global::Windows.Storage.Streams.UnicodeEncoding __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, global::Windows.Storage.Streams.UnicodeEncoding*, int>**)ThisPtr)[7](ThisPtr, &__retval));
            global::System.GC.KeepAlive(_obj);
            return __retval;
        }
        public static unsafe void set_UnicodeEncoding(IObjectReference _obj, global::Windows.Storage.Streams.UnicodeEncoding value)
        {
            var ThisPtr = _obj.ThisPtr;

            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, global::Windows.Storage.Streams.UnicodeEncoding, int>**)ThisPtr)[8](ThisPtr, value));
            global::System.GC.KeepAlive(_obj);
        }



        public static ref readonly global::System.Guid IID
        {
            [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            get
            {
                global::System.ReadOnlySpan<byte> data = new byte[] { 0x29, 0x0, 0xB5, 0xE2, 0xC1, 0xB4, 0x14, 0x43, 0xA4, 0xB8, 0xFB, 0x81, 0x3A, 0x2F, 0x27, 0x5E };
                return ref global::System.Runtime.CompilerServices.Unsafe.As<byte, global::System.Guid>(ref global::System.Runtime.InteropServices.MemoryMarshal.GetReference(data));
            }
        }

        public static global::System.IntPtr AbiToProjectionVftablePtr => IDataReader.AbiToProjectionVftablePtr;

    }
    [DynamicInterfaceCastableImplementation]
    [Guid("E2B50029-B4C1-4314-A4B8-FB813A2F275E")]
    internal unsafe interface IDataReader : global::Windows.Storage.Streams.IDataReader
    {

        public static readonly IntPtr AbiToProjectionVftablePtr;
        static unsafe IDataReader()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IDataReader), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 26);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;
            ((delegate* unmanaged[Stdcall]<IntPtr, uint*, int>*)AbiToProjectionVftablePtr)[6] = &Do_Abi_get_UnconsumedBufferLength_0;
            ((delegate* unmanaged[Stdcall]<IntPtr, global::Windows.Storage.Streams.UnicodeEncoding*, int>*)AbiToProjectionVftablePtr)[7] = &Do_Abi_get_UnicodeEncoding_1;
            ((delegate* unmanaged[Stdcall]<IntPtr, global::Windows.Storage.Streams.UnicodeEncoding, int>*)AbiToProjectionVftablePtr)[8] = &Do_Abi_put_UnicodeEncoding_2;
            ((delegate* unmanaged[Stdcall]<IntPtr, global::Windows.Storage.Streams.ByteOrder*, int>*)AbiToProjectionVftablePtr)[9] = &Do_Abi_get_ByteOrder_3;
            ((delegate* unmanaged[Stdcall]<IntPtr, global::Windows.Storage.Streams.ByteOrder, int>*)AbiToProjectionVftablePtr)[10] = &Do_Abi_put_ByteOrder_4;
            ((delegate* unmanaged[Stdcall]<IntPtr, global::Windows.Storage.Streams.InputStreamOptions*, int>*)AbiToProjectionVftablePtr)[11] = &Do_Abi_get_InputStreamOptions_5;
            ((delegate* unmanaged[Stdcall]<IntPtr, global::Windows.Storage.Streams.InputStreamOptions, int>*)AbiToProjectionVftablePtr)[12] = &Do_Abi_put_InputStreamOptions_6;
            ((delegate* unmanaged[Stdcall]<IntPtr, byte*, int>*)AbiToProjectionVftablePtr)[13] = &Do_Abi_ReadByte_7;
            ((delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, int>*)AbiToProjectionVftablePtr)[14] = &Do_Abi_ReadBytes_8;
            ((delegate* unmanaged[Stdcall]<IntPtr, uint, IntPtr*, int>*)AbiToProjectionVftablePtr)[15] = &Do_Abi_ReadBuffer_9;
            ((delegate* unmanaged[Stdcall]<IntPtr, byte*, int>*)AbiToProjectionVftablePtr)[16] = &Do_Abi_ReadBoolean_10;
            ((delegate* unmanaged[Stdcall]<IntPtr, Guid*, int>*)AbiToProjectionVftablePtr)[17] = &Do_Abi_ReadGuid_11;
            ((delegate* unmanaged[Stdcall]<IntPtr, short*, int>*)AbiToProjectionVftablePtr)[18] = &Do_Abi_ReadInt16_12;
            ((delegate* unmanaged[Stdcall]<IntPtr, int*, int>*)AbiToProjectionVftablePtr)[19] = &Do_Abi_ReadInt32_13;
            ((delegate* unmanaged[Stdcall]<IntPtr, long*, int>*)AbiToProjectionVftablePtr)[20] = &Do_Abi_ReadInt64_14;
            ((delegate* unmanaged[Stdcall]<IntPtr, ushort*, int>*)AbiToProjectionVftablePtr)[21] = &Do_Abi_ReadUInt16_15;
            ((delegate* unmanaged[Stdcall]<IntPtr, uint*, int>*)AbiToProjectionVftablePtr)[22] = &Do_Abi_ReadUInt32_16;
            ((delegate* unmanaged[Stdcall]<IntPtr, ulong*, int>*)AbiToProjectionVftablePtr)[23] = &Do_Abi_ReadUInt64_17;
            ((delegate* unmanaged[Stdcall]<IntPtr, float*, int>*)AbiToProjectionVftablePtr)[24] = &Do_Abi_ReadSingle_18;
            ((delegate* unmanaged[Stdcall]<IntPtr, double*, int>*)AbiToProjectionVftablePtr)[25] = &Do_Abi_ReadDouble_19;
            ((delegate* unmanaged[Stdcall]<IntPtr, uint, IntPtr*, int>*)AbiToProjectionVftablePtr)[26] = &Do_Abi_ReadString_20;
            ((delegate* unmanaged[Stdcall]<IntPtr, global::ABI.System.DateTimeOffset*, int>*)AbiToProjectionVftablePtr)[27] = &Do_Abi_ReadDateTime_21;
            ((delegate* unmanaged[Stdcall]<IntPtr, global::ABI.System.TimeSpan*, int>*)AbiToProjectionVftablePtr)[28] = &Do_Abi_ReadTimeSpan_22;
            ((delegate* unmanaged[Stdcall]<IntPtr, uint, IntPtr*, int>*)AbiToProjectionVftablePtr)[29] = &Do_Abi_LoadAsync_23;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[30] = &Do_Abi_DetachBuffer_24;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[31] = &Do_Abi_DetachStream_25;
        }

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_ReadByte_7(IntPtr thisPtr, byte* value)
        {

            byte __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).ReadByte();
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_ReadBytes_8(IntPtr thisPtr, int __valueSize, IntPtr value)
        {


            byte[] __value = MarshalBlittable<byte>.FromAbiArray((__valueSize, value));

            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).ReadBytes( __value);
                MarshalBlittable<byte>.CopyManagedArray(__value, value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_ReadBuffer_9(IntPtr thisPtr, uint length, IntPtr* buffer)
        {

            global::Windows.Storage.Streams.IBuffer __buffer = default;

            *buffer = default;

            try
            {
                __buffer = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).ReadBuffer(length);
                *buffer = MarshalInterface<global::Windows.Storage.Streams.IBuffer>.FromManaged(__buffer);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_ReadBoolean_10(IntPtr thisPtr, byte* value)
        {

            bool __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).ReadBoolean();
                *value = (byte)(__value ? 1 : 0);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_ReadGuid_11(IntPtr thisPtr, Guid* value)
        {

            Guid __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).ReadGuid();
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_ReadInt16_12(IntPtr thisPtr, short* value)
        {

            short __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).ReadInt16();
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_ReadInt32_13(IntPtr thisPtr, int* value)
        {

            int __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).ReadInt32();
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_ReadInt64_14(IntPtr thisPtr, long* value)
        {

            long __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).ReadInt64();
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_ReadUInt16_15(IntPtr thisPtr, ushort* value)
        {

            ushort __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).ReadUInt16();
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_ReadUInt32_16(IntPtr thisPtr, uint* value)
        {

            uint __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).ReadUInt32();
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_ReadUInt64_17(IntPtr thisPtr, ulong* value)
        {

            ulong __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).ReadUInt64();
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_ReadSingle_18(IntPtr thisPtr, float* value)
        {

            float __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).ReadSingle();
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_ReadDouble_19(IntPtr thisPtr, double* value)
        {

            double __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).ReadDouble();
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_ReadString_20(IntPtr thisPtr, uint codeUnitCount, IntPtr* value)
        {

            string __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).ReadString(codeUnitCount);
                *value = MarshalString.FromManaged(__value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_ReadDateTime_21(IntPtr thisPtr, global::ABI.System.DateTimeOffset* value)
        {

            global::System.DateTimeOffset __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).ReadDateTime();
                *value = global::ABI.System.DateTimeOffset.FromManaged(__value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_ReadTimeSpan_22(IntPtr thisPtr, global::ABI.System.TimeSpan* value)
        {

            global::System.TimeSpan __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).ReadTimeSpan();
                *value = global::ABI.System.TimeSpan.FromManaged(__value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_LoadAsync_23(IntPtr thisPtr, uint count, IntPtr* operation)
        {

            global::Windows.Storage.Streams.DataReaderLoadOperation __operation = default;

            *operation = default;

            try
            {
                __operation = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).LoadAsync(count);
                *operation = global::ABI.Windows.Storage.Streams.DataReaderLoadOperation.FromManaged(__operation);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_DetachBuffer_24(IntPtr thisPtr, IntPtr* buffer)
        {

            global::Windows.Storage.Streams.IBuffer __buffer = default;

            *buffer = default;

            try
            {
                __buffer = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).DetachBuffer();
                *buffer = MarshalInterface<global::Windows.Storage.Streams.IBuffer>.FromManaged(__buffer);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_DetachStream_25(IntPtr thisPtr, IntPtr* stream)
        {

            global::Windows.Storage.Streams.IInputStream __stream = default;

            *stream = default;

            try
            {
                __stream = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).DetachStream();
                *stream = MarshalInterface<global::Windows.Storage.Streams.IInputStream>.FromManaged(__stream);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_put_ByteOrder_4(IntPtr thisPtr, global::Windows.Storage.Streams.ByteOrder value)
        {



            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).ByteOrder = value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_ByteOrder_3(IntPtr thisPtr, global::Windows.Storage.Streams.ByteOrder* value)
        {

            global::Windows.Storage.Streams.ByteOrder __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).ByteOrder;
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_put_InputStreamOptions_6(IntPtr thisPtr, global::Windows.Storage.Streams.InputStreamOptions value)
        {



            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).InputStreamOptions = value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_InputStreamOptions_5(IntPtr thisPtr, global::Windows.Storage.Streams.InputStreamOptions* value)
        {

            global::Windows.Storage.Streams.InputStreamOptions __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).InputStreamOptions;
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_UnconsumedBufferLength_0(IntPtr thisPtr, uint* value)
        {

            uint __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).UnconsumedBufferLength;
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_put_UnicodeEncoding_2(IntPtr thisPtr, global::Windows.Storage.Streams.UnicodeEncoding value)
        {



            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).UnicodeEncoding = value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_UnicodeEncoding_1(IntPtr thisPtr, global::Windows.Storage.Streams.UnicodeEncoding* value)
        {

            global::Windows.Storage.Streams.UnicodeEncoding __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataReader>(thisPtr).UnicodeEncoding;
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }

        unsafe byte global::Windows.Storage.Streams.IDataReader.ReadByte()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
            return global::ABI.Windows.Storage.Streams.IDataReaderMethods.ReadByte(_obj);
        }

        unsafe void global::Windows.Storage.Streams.IDataReader.ReadBytes(byte[] value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
            global::ABI.Windows.Storage.Streams.IDataReaderMethods.ReadBytes(_obj, value);
        }

        unsafe global::Windows.Storage.Streams.IBuffer global::Windows.Storage.Streams.IDataReader.ReadBuffer(uint length)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
            return global::ABI.Windows.Storage.Streams.IDataReaderMethods.ReadBuffer(_obj, length);
        }

        unsafe bool global::Windows.Storage.Streams.IDataReader.ReadBoolean()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
            return global::ABI.Windows.Storage.Streams.IDataReaderMethods.ReadBoolean(_obj);
        }

        unsafe Guid global::Windows.Storage.Streams.IDataReader.ReadGuid()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
            return global::ABI.Windows.Storage.Streams.IDataReaderMethods.ReadGuid(_obj);
        }

        unsafe short global::Windows.Storage.Streams.IDataReader.ReadInt16()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
            return global::ABI.Windows.Storage.Streams.IDataReaderMethods.ReadInt16(_obj);
        }

        unsafe int global::Windows.Storage.Streams.IDataReader.ReadInt32()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
            return global::ABI.Windows.Storage.Streams.IDataReaderMethods.ReadInt32(_obj);
        }

        unsafe long global::Windows.Storage.Streams.IDataReader.ReadInt64()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
            return global::ABI.Windows.Storage.Streams.IDataReaderMethods.ReadInt64(_obj);
        }

        unsafe ushort global::Windows.Storage.Streams.IDataReader.ReadUInt16()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
            return global::ABI.Windows.Storage.Streams.IDataReaderMethods.ReadUInt16(_obj);
        }

        unsafe uint global::Windows.Storage.Streams.IDataReader.ReadUInt32()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
            return global::ABI.Windows.Storage.Streams.IDataReaderMethods.ReadUInt32(_obj);
        }

        unsafe ulong global::Windows.Storage.Streams.IDataReader.ReadUInt64()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
            return global::ABI.Windows.Storage.Streams.IDataReaderMethods.ReadUInt64(_obj);
        }

        unsafe float global::Windows.Storage.Streams.IDataReader.ReadSingle()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
            return global::ABI.Windows.Storage.Streams.IDataReaderMethods.ReadSingle(_obj);
        }

        unsafe double global::Windows.Storage.Streams.IDataReader.ReadDouble()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
            return global::ABI.Windows.Storage.Streams.IDataReaderMethods.ReadDouble(_obj);
        }

        unsafe string global::Windows.Storage.Streams.IDataReader.ReadString(uint codeUnitCount)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
            return global::ABI.Windows.Storage.Streams.IDataReaderMethods.ReadString(_obj, codeUnitCount);
        }

        unsafe global::System.DateTimeOffset global::Windows.Storage.Streams.IDataReader.ReadDateTime()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
            return global::ABI.Windows.Storage.Streams.IDataReaderMethods.ReadDateTime(_obj);
        }

        unsafe global::System.TimeSpan global::Windows.Storage.Streams.IDataReader.ReadTimeSpan()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
            return global::ABI.Windows.Storage.Streams.IDataReaderMethods.ReadTimeSpan(_obj);
        }

        unsafe global::Windows.Storage.Streams.DataReaderLoadOperation global::Windows.Storage.Streams.IDataReader.LoadAsync(uint count)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
            return global::ABI.Windows.Storage.Streams.IDataReaderMethods.LoadAsync(_obj, count);
        }

        unsafe global::Windows.Storage.Streams.IBuffer global::Windows.Storage.Streams.IDataReader.DetachBuffer()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
            return global::ABI.Windows.Storage.Streams.IDataReaderMethods.DetachBuffer(_obj);
        }

        unsafe global::Windows.Storage.Streams.IInputStream global::Windows.Storage.Streams.IDataReader.DetachStream()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
            return global::ABI.Windows.Storage.Streams.IDataReaderMethods.DetachStream(_obj);
        }

        unsafe global::Windows.Storage.Streams.ByteOrder global::Windows.Storage.Streams.IDataReader.ByteOrder
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
                return global::ABI.Windows.Storage.Streams.IDataReaderMethods.get_ByteOrder(_obj);
            }
            set
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
                global::ABI.Windows.Storage.Streams.IDataReaderMethods.set_ByteOrder(_obj, value);
            }
        }

        unsafe global::Windows.Storage.Streams.InputStreamOptions global::Windows.Storage.Streams.IDataReader.InputStreamOptions
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
                return global::ABI.Windows.Storage.Streams.IDataReaderMethods.get_InputStreamOptions(_obj);
            }
            set
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
                global::ABI.Windows.Storage.Streams.IDataReaderMethods.set_InputStreamOptions(_obj, value);
            }
        }

        unsafe uint global::Windows.Storage.Streams.IDataReader.UnconsumedBufferLength
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
                return global::ABI.Windows.Storage.Streams.IDataReaderMethods.get_UnconsumedBufferLength(_obj);
            }
        }

        unsafe global::Windows.Storage.Streams.UnicodeEncoding global::Windows.Storage.Streams.IDataReader.UnicodeEncoding
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
                return global::ABI.Windows.Storage.Streams.IDataReaderMethods.get_UnicodeEncoding(_obj);
            }
            set
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataReader).TypeHandle));
                global::ABI.Windows.Storage.Streams.IDataReaderMethods.set_UnicodeEncoding(_obj, value);
            }
        }
    }

    internal static class IDataReaderFactoryMethods
    {


        internal static unsafe global::Windows.Storage.Streams.DataReader CreateDataReader(IObjectReference _obj, global::Windows.Storage.Streams.IInputStream inputStream)
        {
            var ThisPtr = _obj.ThisPtr;

            ObjectReferenceValue __inputStream = default;
            IntPtr __retval = default;
            try
            {
                __inputStream = MarshalInterface<global::Windows.Storage.Streams.IInputStream>.CreateMarshaler2(inputStream, global::ABI.Windows.Storage.Streams.IInputStreamMethods.IID);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr*, int>**)ThisPtr)[6](ThisPtr, MarshalInspectable<object>.GetAbi(__inputStream), &__retval));
                global::System.GC.KeepAlive(_obj);
                return global::ABI.Windows.Storage.Streams.DataReader.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeMarshaler(__inputStream);
                global::ABI.Windows.Storage.Streams.DataReader.DisposeAbi(__retval);
            }
        }


        public static ref readonly global::System.Guid IID
        {
            [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            get
            {
                global::System.ReadOnlySpan<byte> data = new byte[] { 0x47, 0x78, 0x52, 0xD7, 0xDA, 0x57, 0x15, 0x4E, 0x91, 0x4C, 0x6, 0x80, 0x66, 0x99, 0xA0, 0x98 };
                return ref global::System.Runtime.CompilerServices.Unsafe.As<byte, global::System.Guid>(ref global::System.Runtime.InteropServices.MemoryMarshal.GetReference(data));
            }
        }

    }
    [Guid("D7527847-57DA-4E15-914C-06806699A098")]
    internal interface IDataReaderFactory : global::Windows.Storage.Streams.IDataReaderFactory
    {
    }
    internal static class IDataReaderStaticsMethods
    {


        internal static unsafe global::Windows.Storage.Streams.DataReader FromBuffer(IObjectReference _obj, global::Windows.Storage.Streams.IBuffer buffer)
        {
            var ThisPtr = _obj.ThisPtr;

            ObjectReferenceValue __buffer = default;
            IntPtr __retval = default;
            try
            {
                __buffer = MarshalInterface<global::Windows.Storage.Streams.IBuffer>.CreateMarshaler2(buffer, global::ABI.Windows.Storage.Streams.IBufferMethods.IID);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr*, int>**)ThisPtr)[6](ThisPtr, MarshalInspectable<object>.GetAbi(__buffer), &__retval));
                global::System.GC.KeepAlive(_obj);
                return global::ABI.Windows.Storage.Streams.DataReader.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeMarshaler(__buffer);
                global::ABI.Windows.Storage.Streams.DataReader.DisposeAbi(__retval);
            }
        }


        public static ref readonly global::System.Guid IID
        {
            [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            get
            {
                global::System.ReadOnlySpan<byte> data = new byte[] { 0xC8, 0xBF, 0xFC, 0x11, 0x3A, 0xF9, 0x1B, 0x47, 0xB1, 0x21, 0xF3, 0x79, 0xE3, 0x49, 0x31, 0x3C };
                return ref global::System.Runtime.CompilerServices.Unsafe.As<byte, global::System.Guid>(ref global::System.Runtime.InteropServices.MemoryMarshal.GetReference(data));
            }
        }

    }
    [Guid("11FCBFC8-F93A-471B-B121-F379E349313C")]
    internal interface IDataReaderStatics : global::Windows.Storage.Streams.IDataReaderStatics
    {
    }
    public static class IDataWriterMethods
    {


        public static unsafe void WriteByte(IObjectReference _obj, byte value)
        {
            var ThisPtr = _obj.ThisPtr;

            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, byte, int>**)ThisPtr)[11](ThisPtr, value));
            global::System.GC.KeepAlive(_obj);
        }

        public static unsafe void WriteBytes(IObjectReference _obj, byte[] value)
        {
            var ThisPtr = _obj.ThisPtr;

            MarshalBlittable<byte>.MarshalerArray __value = default;
            int __value_length = default;
            IntPtr __value_data = default;
            try
            {
                __value = MarshalBlittable<byte>.CreateMarshalerArray(value);
                (__value_length, __value_data) = MarshalBlittable<byte>.GetAbiArray(__value);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, int>**)ThisPtr)[12](ThisPtr, __value_length, __value_data));
                global::System.GC.KeepAlive(_obj);
            }
            finally
            {
                MarshalBlittable<byte>.DisposeMarshalerArray(__value);
            }
        }

        public static unsafe void WriteBuffer(IObjectReference _obj, global::Windows.Storage.Streams.IBuffer buffer)
        {
            var ThisPtr = _obj.ThisPtr;

            ObjectReferenceValue __buffer = default;
            try
            {
                __buffer = MarshalInterface<global::Windows.Storage.Streams.IBuffer>.CreateMarshaler2(buffer, global::ABI.Windows.Storage.Streams.IBufferMethods.IID);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, int>**)ThisPtr)[13](ThisPtr, MarshalInspectable<object>.GetAbi(__buffer)));
                global::System.GC.KeepAlive(_obj);
            }
            finally
            {
                MarshalInspectable<object>.DisposeMarshaler(__buffer);
            }
        }

        public static unsafe void WriteBuffer(IObjectReference _obj, global::Windows.Storage.Streams.IBuffer buffer, uint start, uint count)
        {
            var ThisPtr = _obj.ThisPtr;

            ObjectReferenceValue __buffer = default;
            try
            {
                __buffer = MarshalInterface<global::Windows.Storage.Streams.IBuffer>.CreateMarshaler2(buffer, global::ABI.Windows.Storage.Streams.IBufferMethods.IID);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, uint, uint, int>**)ThisPtr)[14](ThisPtr, MarshalInspectable<object>.GetAbi(__buffer), start, count));
                global::System.GC.KeepAlive(_obj);
            }
            finally
            {
                MarshalInspectable<object>.DisposeMarshaler(__buffer);
            }
        }

        public static unsafe void WriteBoolean(IObjectReference _obj, bool value)
        {
            var ThisPtr = _obj.ThisPtr;

            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, byte, int>**)ThisPtr)[15](ThisPtr, (byte)(value ? 1 : 0)));
            global::System.GC.KeepAlive(_obj);
        }

        public static unsafe void WriteGuid(IObjectReference _obj, Guid value)
        {
            var ThisPtr = _obj.ThisPtr;

            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, Guid, int>**)ThisPtr)[16](ThisPtr, value));
            global::System.GC.KeepAlive(_obj);
        }

        public static unsafe void WriteInt16(IObjectReference _obj, short value)
        {
            var ThisPtr = _obj.ThisPtr;

            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, short, int>**)ThisPtr)[17](ThisPtr, value));
            global::System.GC.KeepAlive(_obj);
        }

        public static unsafe void WriteInt32(IObjectReference _obj, int value)
        {
            var ThisPtr = _obj.ThisPtr;

            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, int, int>**)ThisPtr)[18](ThisPtr, value));
            global::System.GC.KeepAlive(_obj);
        }

        public static unsafe void WriteInt64(IObjectReference _obj, long value)
        {
            var ThisPtr = _obj.ThisPtr;

            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, long, int>**)ThisPtr)[19](ThisPtr, value));
            global::System.GC.KeepAlive(_obj);
        }

        public static unsafe void WriteUInt16(IObjectReference _obj, ushort value)
        {
            var ThisPtr = _obj.ThisPtr;

            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, ushort, int>**)ThisPtr)[20](ThisPtr, value));
            global::System.GC.KeepAlive(_obj);
        }

        public static unsafe void WriteUInt32(IObjectReference _obj, uint value)
        {
            var ThisPtr = _obj.ThisPtr;

            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, uint, int>**)ThisPtr)[21](ThisPtr, value));
            global::System.GC.KeepAlive(_obj);
        }

        public static unsafe void WriteUInt64(IObjectReference _obj, ulong value)
        {
            var ThisPtr = _obj.ThisPtr;

            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, ulong, int>**)ThisPtr)[22](ThisPtr, value));
            global::System.GC.KeepAlive(_obj);
        }

        public static unsafe void WriteSingle(IObjectReference _obj, float value)
        {
            var ThisPtr = _obj.ThisPtr;

            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, float, int>**)ThisPtr)[23](ThisPtr, value));
            global::System.GC.KeepAlive(_obj);
        }

        public static unsafe void WriteDouble(IObjectReference _obj, double value)
        {
            var ThisPtr = _obj.ThisPtr;

            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, double, int>**)ThisPtr)[24](ThisPtr, value));
            global::System.GC.KeepAlive(_obj);
        }

        public static unsafe void WriteDateTime(IObjectReference _obj, global::System.DateTimeOffset value)
        {
            var ThisPtr = _obj.ThisPtr;

            global::ABI.System.DateTimeOffset.Marshaler __value = default;
            try
            {
                __value = global::ABI.System.DateTimeOffset.CreateMarshaler(value);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, global::ABI.System.DateTimeOffset, int>**)ThisPtr)[25](ThisPtr, global::ABI.System.DateTimeOffset.GetAbi(__value)));
                global::System.GC.KeepAlive(_obj);
            }
            finally
            {
                global::ABI.System.DateTimeOffset.DisposeMarshaler(__value);
            }
        }

        public static unsafe void WriteTimeSpan(IObjectReference _obj, global::System.TimeSpan value)
        {
            var ThisPtr = _obj.ThisPtr;

            global::ABI.System.TimeSpan.Marshaler __value = default;
            try
            {
                __value = global::ABI.System.TimeSpan.CreateMarshaler(value);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, global::ABI.System.TimeSpan, int>**)ThisPtr)[26](ThisPtr, global::ABI.System.TimeSpan.GetAbi(__value)));
                global::System.GC.KeepAlive(_obj);
            }
            finally
            {
                global::ABI.System.TimeSpan.DisposeMarshaler(__value);
            }
        }

        public static unsafe uint WriteString(IObjectReference _obj, string value)
        {
            var ThisPtr = _obj.ThisPtr;

            uint __retval = default;
            MarshalString.Pinnable __value = new(value);
            fixed(void* ___value = __value)
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, uint*, int>**)ThisPtr)[27](ThisPtr, MarshalString.GetAbi(ref __value), &__retval));
                global::System.GC.KeepAlive(_obj);
                return __retval;
            }
        }

        public static unsafe uint MeasureString(IObjectReference _obj, string value)
        {
            var ThisPtr = _obj.ThisPtr;

            uint __retval = default;
            MarshalString.Pinnable __value = new(value);
            fixed(void* ___value = __value)
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, uint*, int>**)ThisPtr)[28](ThisPtr, MarshalString.GetAbi(ref __value), &__retval));
                global::System.GC.KeepAlive(_obj);
                return __retval;
            }
        }

        public static unsafe global::Windows.Storage.Streams.DataWriterStoreOperation StoreAsync(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>**)ThisPtr)[29](ThisPtr, &__retval));
                global::System.GC.KeepAlive(_obj);
                return global::ABI.Windows.Storage.Streams.DataWriterStoreOperation.FromAbi(__retval);
            }
            finally
            {
                global::ABI.Windows.Storage.Streams.DataWriterStoreOperation.DisposeAbi(__retval);
            }
        }

        public static unsafe global::Windows.Foundation.IAsyncOperation<bool> FlushAsync(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>**)ThisPtr)[30](ThisPtr, &__retval));
                global::System.GC.KeepAlive(_obj);
                _ = global::WinRT.GenericTypeInstantiations.Windows_Foundation_IAsyncOperation_1_Boolean.EnsureInitialized();
                return MarshalInterface<global::Windows.Foundation.IAsyncOperation<bool>>.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::Windows.Foundation.IAsyncOperation<bool>>.DisposeAbi(__retval);
            }
        }

        public static unsafe global::Windows.Storage.Streams.IBuffer DetachBuffer(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>**)ThisPtr)[31](ThisPtr, &__retval));
                global::System.GC.KeepAlive(_obj);
                return MarshalInterface<global::Windows.Storage.Streams.IBuffer>.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::Windows.Storage.Streams.IBuffer>.DisposeAbi(__retval);
            }
        }

        public static unsafe global::Windows.Storage.Streams.IOutputStream DetachStream(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>**)ThisPtr)[32](ThisPtr, &__retval));
                global::System.GC.KeepAlive(_obj);
                return MarshalInterface<global::Windows.Storage.Streams.IOutputStream>.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::Windows.Storage.Streams.IOutputStream>.DisposeAbi(__retval);
            }
        }
        public static unsafe global::Windows.Storage.Streams.ByteOrder get_ByteOrder(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            global::Windows.Storage.Streams.ByteOrder __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, global::Windows.Storage.Streams.ByteOrder*, int>**)ThisPtr)[9](ThisPtr, &__retval));
            global::System.GC.KeepAlive(_obj);
            return __retval;
        }
        public static unsafe void set_ByteOrder(IObjectReference _obj, global::Windows.Storage.Streams.ByteOrder value)
        {
            var ThisPtr = _obj.ThisPtr;

            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, global::Windows.Storage.Streams.ByteOrder, int>**)ThisPtr)[10](ThisPtr, value));
            global::System.GC.KeepAlive(_obj);
        }

        public static unsafe global::Windows.Storage.Streams.UnicodeEncoding get_UnicodeEncoding(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            global::Windows.Storage.Streams.UnicodeEncoding __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, global::Windows.Storage.Streams.UnicodeEncoding*, int>**)ThisPtr)[7](ThisPtr, &__retval));
            global::System.GC.KeepAlive(_obj);
            return __retval;
        }
        public static unsafe void set_UnicodeEncoding(IObjectReference _obj, global::Windows.Storage.Streams.UnicodeEncoding value)
        {
            var ThisPtr = _obj.ThisPtr;

            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, global::Windows.Storage.Streams.UnicodeEncoding, int>**)ThisPtr)[8](ThisPtr, value));
            global::System.GC.KeepAlive(_obj);
        }

        public static unsafe uint get_UnstoredBufferLength(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            uint __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, uint*, int>**)ThisPtr)[6](ThisPtr, &__retval));
            global::System.GC.KeepAlive(_obj);
            return __retval;
        }



        public static ref readonly global::System.Guid IID
        {
            [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            get
            {
                global::System.ReadOnlySpan<byte> data = new byte[] { 0x65, 0x92, 0xB8, 0x64, 0x41, 0xD3, 0x22, 0x49, 0xB3, 0x8A, 0xDD, 0x4A, 0xF8, 0x80, 0x8C, 0x4E };
                return ref global::System.Runtime.CompilerServices.Unsafe.As<byte, global::System.Guid>(ref global::System.Runtime.InteropServices.MemoryMarshal.GetReference(data));
            }
        }

        public static global::System.IntPtr AbiToProjectionVftablePtr => IDataWriter.AbiToProjectionVftablePtr;

    }
    [DynamicInterfaceCastableImplementation]
    [Guid("64B89265-D341-4922-B38A-DD4AF8808C4E")]
    internal unsafe interface IDataWriter : global::Windows.Storage.Streams.IDataWriter
    {

        public static readonly IntPtr AbiToProjectionVftablePtr;
        static unsafe IDataWriter()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IDataWriter), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 27);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;
            ((delegate* unmanaged[Stdcall]<IntPtr, uint*, int>*)AbiToProjectionVftablePtr)[6] = &Do_Abi_get_UnstoredBufferLength_0;
            ((delegate* unmanaged[Stdcall]<IntPtr, global::Windows.Storage.Streams.UnicodeEncoding*, int>*)AbiToProjectionVftablePtr)[7] = &Do_Abi_get_UnicodeEncoding_1;
            ((delegate* unmanaged[Stdcall]<IntPtr, global::Windows.Storage.Streams.UnicodeEncoding, int>*)AbiToProjectionVftablePtr)[8] = &Do_Abi_put_UnicodeEncoding_2;
            ((delegate* unmanaged[Stdcall]<IntPtr, global::Windows.Storage.Streams.ByteOrder*, int>*)AbiToProjectionVftablePtr)[9] = &Do_Abi_get_ByteOrder_3;
            ((delegate* unmanaged[Stdcall]<IntPtr, global::Windows.Storage.Streams.ByteOrder, int>*)AbiToProjectionVftablePtr)[10] = &Do_Abi_put_ByteOrder_4;
            ((delegate* unmanaged[Stdcall]<IntPtr, byte, int>*)AbiToProjectionVftablePtr)[11] = &Do_Abi_WriteByte_5;
            ((delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, int>*)AbiToProjectionVftablePtr)[12] = &Do_Abi_WriteBytes_6;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr, int>*)AbiToProjectionVftablePtr)[13] = &Do_Abi_WriteBuffer_7;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr, uint, uint, int>*)AbiToProjectionVftablePtr)[14] = &Do_Abi_WriteBuffer_8;
            ((delegate* unmanaged[Stdcall]<IntPtr, byte, int>*)AbiToProjectionVftablePtr)[15] = &Do_Abi_WriteBoolean_9;
            ((delegate* unmanaged[Stdcall]<IntPtr, Guid, int>*)AbiToProjectionVftablePtr)[16] = &Do_Abi_WriteGuid_10;
            ((delegate* unmanaged[Stdcall]<IntPtr, short, int>*)AbiToProjectionVftablePtr)[17] = &Do_Abi_WriteInt16_11;
            ((delegate* unmanaged[Stdcall]<IntPtr, int, int>*)AbiToProjectionVftablePtr)[18] = &Do_Abi_WriteInt32_12;
            ((delegate* unmanaged[Stdcall]<IntPtr, long, int>*)AbiToProjectionVftablePtr)[19] = &Do_Abi_WriteInt64_13;
            ((delegate* unmanaged[Stdcall]<IntPtr, ushort, int>*)AbiToProjectionVftablePtr)[20] = &Do_Abi_WriteUInt16_14;
            ((delegate* unmanaged[Stdcall]<IntPtr, uint, int>*)AbiToProjectionVftablePtr)[21] = &Do_Abi_WriteUInt32_15;
            ((delegate* unmanaged[Stdcall]<IntPtr, ulong, int>*)AbiToProjectionVftablePtr)[22] = &Do_Abi_WriteUInt64_16;
            ((delegate* unmanaged[Stdcall]<IntPtr, float, int>*)AbiToProjectionVftablePtr)[23] = &Do_Abi_WriteSingle_17;
            ((delegate* unmanaged[Stdcall]<IntPtr, double, int>*)AbiToProjectionVftablePtr)[24] = &Do_Abi_WriteDouble_18;
            ((delegate* unmanaged[Stdcall]<IntPtr, global::ABI.System.DateTimeOffset, int>*)AbiToProjectionVftablePtr)[25] = &Do_Abi_WriteDateTime_19;
            ((delegate* unmanaged[Stdcall]<IntPtr, global::ABI.System.TimeSpan, int>*)AbiToProjectionVftablePtr)[26] = &Do_Abi_WriteTimeSpan_20;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr, uint*, int>*)AbiToProjectionVftablePtr)[27] = &Do_Abi_WriteString_21;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr, uint*, int>*)AbiToProjectionVftablePtr)[28] = &Do_Abi_MeasureString_22;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[29] = &Do_Abi_StoreAsync_23;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[30] = &Do_Abi_FlushAsync_24;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[31] = &Do_Abi_DetachBuffer_25;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[32] = &Do_Abi_DetachStream_26;
        }

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_WriteByte_5(IntPtr thisPtr, byte value)
        {



            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).WriteByte(value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_WriteBytes_6(IntPtr thisPtr, int __valueSize, IntPtr value)
        {



            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).WriteBytes(MarshalBlittable<byte>.FromAbiArray((__valueSize, value)));

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_WriteBuffer_7(IntPtr thisPtr, IntPtr buffer)
        {



            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).WriteBuffer(MarshalInterface<global::Windows.Storage.Streams.IBuffer>.FromAbi(buffer));

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_WriteBuffer_8(IntPtr thisPtr, IntPtr buffer, uint start, uint count)
        {



            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).WriteBuffer(MarshalInterface<global::Windows.Storage.Streams.IBuffer>.FromAbi(buffer), start, count);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_WriteBoolean_9(IntPtr thisPtr, byte value)
        {



            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).WriteBoolean(value != 0);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_WriteGuid_10(IntPtr thisPtr, Guid value)
        {



            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).WriteGuid(value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_WriteInt16_11(IntPtr thisPtr, short value)
        {



            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).WriteInt16(value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_WriteInt32_12(IntPtr thisPtr, int value)
        {



            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).WriteInt32(value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_WriteInt64_13(IntPtr thisPtr, long value)
        {



            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).WriteInt64(value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_WriteUInt16_14(IntPtr thisPtr, ushort value)
        {



            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).WriteUInt16(value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_WriteUInt32_15(IntPtr thisPtr, uint value)
        {



            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).WriteUInt32(value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_WriteUInt64_16(IntPtr thisPtr, ulong value)
        {



            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).WriteUInt64(value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_WriteSingle_17(IntPtr thisPtr, float value)
        {



            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).WriteSingle(value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_WriteDouble_18(IntPtr thisPtr, double value)
        {



            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).WriteDouble(value);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_WriteDateTime_19(IntPtr thisPtr, global::ABI.System.DateTimeOffset value)
        {



            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).WriteDateTime(global::ABI.System.DateTimeOffset.FromAbi(value));

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_WriteTimeSpan_20(IntPtr thisPtr, global::ABI.System.TimeSpan value)
        {



            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).WriteTimeSpan(global::ABI.System.TimeSpan.FromAbi(value));

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_WriteString_21(IntPtr thisPtr, IntPtr value, uint* codeUnitCount)
        {

            uint __codeUnitCount = default;

            *codeUnitCount = default;

            try
            {
                __codeUnitCount = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).WriteString(MarshalString.FromAbi(value));
                *codeUnitCount = __codeUnitCount;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_MeasureString_22(IntPtr thisPtr, IntPtr value, uint* codeUnitCount)
        {

            uint __codeUnitCount = default;

            *codeUnitCount = default;

            try
            {
                __codeUnitCount = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).MeasureString(MarshalString.FromAbi(value));
                *codeUnitCount = __codeUnitCount;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_StoreAsync_23(IntPtr thisPtr, IntPtr* operation)
        {

            global::Windows.Storage.Streams.DataWriterStoreOperation __operation = default;

            *operation = default;

            try
            {
                __operation = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).StoreAsync();
                *operation = global::ABI.Windows.Storage.Streams.DataWriterStoreOperation.FromManaged(__operation);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_FlushAsync_24(IntPtr thisPtr, IntPtr* operation)
        {
            _ = global::WinRT.GenericTypeInstantiations.Windows_Foundation_IAsyncOperation_1_Boolean.EnsureInitialized();

            global::Windows.Foundation.IAsyncOperation<bool> __operation = default;

            *operation = default;

            try
            {
                __operation = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).FlushAsync();
                *operation = MarshalInterface<global::Windows.Foundation.IAsyncOperation<bool>>.FromManaged(__operation);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_DetachBuffer_25(IntPtr thisPtr, IntPtr* buffer)
        {

            global::Windows.Storage.Streams.IBuffer __buffer = default;

            *buffer = default;

            try
            {
                __buffer = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).DetachBuffer();
                *buffer = MarshalInterface<global::Windows.Storage.Streams.IBuffer>.FromManaged(__buffer);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_DetachStream_26(IntPtr thisPtr, IntPtr* outputStream)
        {

            global::Windows.Storage.Streams.IOutputStream __outputStream = default;

            *outputStream = default;

            try
            {
                __outputStream = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).DetachStream();
                *outputStream = MarshalInterface<global::Windows.Storage.Streams.IOutputStream>.FromManaged(__outputStream);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_put_ByteOrder_4(IntPtr thisPtr, global::Windows.Storage.Streams.ByteOrder value)
        {



            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).ByteOrder = value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_ByteOrder_3(IntPtr thisPtr, global::Windows.Storage.Streams.ByteOrder* value)
        {

            global::Windows.Storage.Streams.ByteOrder __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).ByteOrder;
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_put_UnicodeEncoding_2(IntPtr thisPtr, global::Windows.Storage.Streams.UnicodeEncoding value)
        {



            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).UnicodeEncoding = value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_UnicodeEncoding_1(IntPtr thisPtr, global::Windows.Storage.Streams.UnicodeEncoding* value)
        {

            global::Windows.Storage.Streams.UnicodeEncoding __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).UnicodeEncoding;
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_UnstoredBufferLength_0(IntPtr thisPtr, uint* value)
        {

            uint __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IDataWriter>(thisPtr).UnstoredBufferLength;
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }

        unsafe void global::Windows.Storage.Streams.IDataWriter.WriteByte(byte value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            global::ABI.Windows.Storage.Streams.IDataWriterMethods.WriteByte(_obj, value);
        }

        unsafe void global::Windows.Storage.Streams.IDataWriter.WriteBytes(byte[] value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            global::ABI.Windows.Storage.Streams.IDataWriterMethods.WriteBytes(_obj, value);
        }

        unsafe void global::Windows.Storage.Streams.IDataWriter.WriteBuffer(global::Windows.Storage.Streams.IBuffer buffer)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            global::ABI.Windows.Storage.Streams.IDataWriterMethods.WriteBuffer(_obj, buffer);
        }

        unsafe void global::Windows.Storage.Streams.IDataWriter.WriteBuffer(global::Windows.Storage.Streams.IBuffer buffer, uint start, uint count)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            global::ABI.Windows.Storage.Streams.IDataWriterMethods.WriteBuffer(_obj, buffer, start, count);
        }

        unsafe void global::Windows.Storage.Streams.IDataWriter.WriteBoolean(bool value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            global::ABI.Windows.Storage.Streams.IDataWriterMethods.WriteBoolean(_obj, value);
        }

        unsafe void global::Windows.Storage.Streams.IDataWriter.WriteGuid(Guid value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            global::ABI.Windows.Storage.Streams.IDataWriterMethods.WriteGuid(_obj, value);
        }

        unsafe void global::Windows.Storage.Streams.IDataWriter.WriteInt16(short value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            global::ABI.Windows.Storage.Streams.IDataWriterMethods.WriteInt16(_obj, value);
        }

        unsafe void global::Windows.Storage.Streams.IDataWriter.WriteInt32(int value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            global::ABI.Windows.Storage.Streams.IDataWriterMethods.WriteInt32(_obj, value);
        }

        unsafe void global::Windows.Storage.Streams.IDataWriter.WriteInt64(long value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            global::ABI.Windows.Storage.Streams.IDataWriterMethods.WriteInt64(_obj, value);
        }

        unsafe void global::Windows.Storage.Streams.IDataWriter.WriteUInt16(ushort value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            global::ABI.Windows.Storage.Streams.IDataWriterMethods.WriteUInt16(_obj, value);
        }

        unsafe void global::Windows.Storage.Streams.IDataWriter.WriteUInt32(uint value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            global::ABI.Windows.Storage.Streams.IDataWriterMethods.WriteUInt32(_obj, value);
        }

        unsafe void global::Windows.Storage.Streams.IDataWriter.WriteUInt64(ulong value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            global::ABI.Windows.Storage.Streams.IDataWriterMethods.WriteUInt64(_obj, value);
        }

        unsafe void global::Windows.Storage.Streams.IDataWriter.WriteSingle(float value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            global::ABI.Windows.Storage.Streams.IDataWriterMethods.WriteSingle(_obj, value);
        }

        unsafe void global::Windows.Storage.Streams.IDataWriter.WriteDouble(double value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            global::ABI.Windows.Storage.Streams.IDataWriterMethods.WriteDouble(_obj, value);
        }

        unsafe void global::Windows.Storage.Streams.IDataWriter.WriteDateTime(global::System.DateTimeOffset value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            global::ABI.Windows.Storage.Streams.IDataWriterMethods.WriteDateTime(_obj, value);
        }

        unsafe void global::Windows.Storage.Streams.IDataWriter.WriteTimeSpan(global::System.TimeSpan value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            global::ABI.Windows.Storage.Streams.IDataWriterMethods.WriteTimeSpan(_obj, value);
        }

        unsafe uint global::Windows.Storage.Streams.IDataWriter.WriteString(string value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            return global::ABI.Windows.Storage.Streams.IDataWriterMethods.WriteString(_obj, value);
        }

        unsafe uint global::Windows.Storage.Streams.IDataWriter.MeasureString(string value)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            return global::ABI.Windows.Storage.Streams.IDataWriterMethods.MeasureString(_obj, value);
        }

        unsafe global::Windows.Storage.Streams.DataWriterStoreOperation global::Windows.Storage.Streams.IDataWriter.StoreAsync()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            return global::ABI.Windows.Storage.Streams.IDataWriterMethods.StoreAsync(_obj);
        }

        unsafe global::Windows.Foundation.IAsyncOperation<bool> global::Windows.Storage.Streams.IDataWriter.FlushAsync()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            return global::ABI.Windows.Storage.Streams.IDataWriterMethods.FlushAsync(_obj);
        }

        unsafe global::Windows.Storage.Streams.IBuffer global::Windows.Storage.Streams.IDataWriter.DetachBuffer()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            return global::ABI.Windows.Storage.Streams.IDataWriterMethods.DetachBuffer(_obj);
        }

        unsafe global::Windows.Storage.Streams.IOutputStream global::Windows.Storage.Streams.IDataWriter.DetachStream()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
            return global::ABI.Windows.Storage.Streams.IDataWriterMethods.DetachStream(_obj);
        }

        unsafe global::Windows.Storage.Streams.ByteOrder global::Windows.Storage.Streams.IDataWriter.ByteOrder
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
                return global::ABI.Windows.Storage.Streams.IDataWriterMethods.get_ByteOrder(_obj);
            }
            set
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
                global::ABI.Windows.Storage.Streams.IDataWriterMethods.set_ByteOrder(_obj, value);
            }
        }

        unsafe global::Windows.Storage.Streams.UnicodeEncoding global::Windows.Storage.Streams.IDataWriter.UnicodeEncoding
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
                return global::ABI.Windows.Storage.Streams.IDataWriterMethods.get_UnicodeEncoding(_obj);
            }
            set
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
                global::ABI.Windows.Storage.Streams.IDataWriterMethods.set_UnicodeEncoding(_obj, value);
            }
        }

        unsafe uint global::Windows.Storage.Streams.IDataWriter.UnstoredBufferLength
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IDataWriter).TypeHandle));
                return global::ABI.Windows.Storage.Streams.IDataWriterMethods.get_UnstoredBufferLength(_obj);
            }
        }
    }

    internal static class IDataWriterFactoryMethods
    {


        internal static unsafe global::Windows.Storage.Streams.DataWriter CreateDataWriter(IObjectReference _obj, global::Windows.Storage.Streams.IOutputStream outputStream)
        {
            var ThisPtr = _obj.ThisPtr;

            ObjectReferenceValue __outputStream = default;
            IntPtr __retval = default;
            try
            {
                __outputStream = MarshalInterface<global::Windows.Storage.Streams.IOutputStream>.CreateMarshaler2(outputStream, global::ABI.Windows.Storage.Streams.IOutputStreamMethods.IID);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr*, int>**)ThisPtr)[6](ThisPtr, MarshalInspectable<object>.GetAbi(__outputStream), &__retval));
                global::System.GC.KeepAlive(_obj);
                return global::ABI.Windows.Storage.Streams.DataWriter.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeMarshaler(__outputStream);
                global::ABI.Windows.Storage.Streams.DataWriter.DisposeAbi(__retval);
            }
        }


        public static ref readonly global::System.Guid IID
        {
            [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            get
            {
                global::System.ReadOnlySpan<byte> data = new byte[] { 0xC2, 0x67, 0x8C, 0x33, 0x84, 0x8B, 0x2B, 0x4C, 0x9C, 0x50, 0x7B, 0x87, 0x67, 0x84, 0x7A, 0x1F };
                return ref global::System.Runtime.CompilerServices.Unsafe.As<byte, global::System.Guid>(ref global::System.Runtime.InteropServices.MemoryMarshal.GetReference(data));
            }
        }

    }
    [Guid("338C67C2-8B84-4C2B-9C50-7B8767847A1F")]
    internal interface IDataWriterFactory : global::Windows.Storage.Streams.IDataWriterFactory
    {
    }
    internal static class IFileRandomAccessStreamStaticsMethods
    {


        internal static unsafe global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.Streams.IRandomAccessStream> OpenAsync(IObjectReference _obj, string filePath, global::Windows.Storage.FileAccessMode accessMode)
        {
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                MarshalString.Pinnable __filePath = new(filePath);
                fixed(void* ___filePath = __filePath)
                {
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, global::Windows.Storage.FileAccessMode, IntPtr*, int>**)ThisPtr)[6](ThisPtr, MarshalString.GetAbi(ref __filePath), accessMode, &__retval));
                    global::System.GC.KeepAlive(_obj);
                    _ = global::WinRT.GenericTypeInstantiations.Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStream.EnsureInitialized();
                    return MarshalInterface<global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.Streams.IRandomAccessStream>>.FromAbi(__retval);
                }
            }
            finally
            {
                MarshalInterface<global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.Streams.IRandomAccessStream>>.DisposeAbi(__retval);
            }
        }

        internal static unsafe global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.Streams.IRandomAccessStream> OpenAsync(IObjectReference _obj, string filePath, global::Windows.Storage.FileAccessMode accessMode, global::Windows.Storage.StorageOpenOptions sharingOptions, global::Windows.Storage.Streams.FileOpenDisposition openDisposition)
        {
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                MarshalString.Pinnable __filePath = new(filePath);
                fixed(void* ___filePath = __filePath)
                {
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, global::Windows.Storage.FileAccessMode, global::Windows.Storage.StorageOpenOptions, global::Windows.Storage.Streams.FileOpenDisposition, IntPtr*, int>**)ThisPtr)[7](ThisPtr, MarshalString.GetAbi(ref __filePath), accessMode, sharingOptions, openDisposition, &__retval));
                    global::System.GC.KeepAlive(_obj);
                    _ = global::WinRT.GenericTypeInstantiations.Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStream.EnsureInitialized();
                    return MarshalInterface<global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.Streams.IRandomAccessStream>>.FromAbi(__retval);
                }
            }
            finally
            {
                MarshalInterface<global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.Streams.IRandomAccessStream>>.DisposeAbi(__retval);
            }
        }

        internal static unsafe global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.StorageStreamTransaction> OpenTransactedWriteAsync(IObjectReference _obj, string filePath)
        {
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                MarshalString.Pinnable __filePath = new(filePath);
                fixed(void* ___filePath = __filePath)
                {
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr*, int>**)ThisPtr)[8](ThisPtr, MarshalString.GetAbi(ref __filePath), &__retval));
                    global::System.GC.KeepAlive(_obj);
                    _ = global::WinRT.GenericTypeInstantiations.Windows_Foundation_IAsyncOperation_1_Windows_Storage_StorageStreamTransaction.EnsureInitialized();
                    return MarshalInterface<global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.StorageStreamTransaction>>.FromAbi(__retval);
                }
            }
            finally
            {
                MarshalInterface<global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.StorageStreamTransaction>>.DisposeAbi(__retval);
            }
        }

        internal static unsafe global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.StorageStreamTransaction> OpenTransactedWriteAsync(IObjectReference _obj, string filePath, global::Windows.Storage.StorageOpenOptions openOptions, global::Windows.Storage.Streams.FileOpenDisposition openDisposition)
        {
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                MarshalString.Pinnable __filePath = new(filePath);
                fixed(void* ___filePath = __filePath)
                {
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, global::Windows.Storage.StorageOpenOptions, global::Windows.Storage.Streams.FileOpenDisposition, IntPtr*, int>**)ThisPtr)[9](ThisPtr, MarshalString.GetAbi(ref __filePath), openOptions, openDisposition, &__retval));
                    global::System.GC.KeepAlive(_obj);
                    _ = global::WinRT.GenericTypeInstantiations.Windows_Foundation_IAsyncOperation_1_Windows_Storage_StorageStreamTransaction.EnsureInitialized();
                    return MarshalInterface<global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.StorageStreamTransaction>>.FromAbi(__retval);
                }
            }
            finally
            {
                MarshalInterface<global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.StorageStreamTransaction>>.DisposeAbi(__retval);
            }
        }

        internal static unsafe global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.Streams.IRandomAccessStream> OpenForUserAsync(IObjectReference _obj, global::Windows.System.User user, string filePath, global::Windows.Storage.FileAccessMode accessMode)
        {
            var ThisPtr = _obj.ThisPtr;

            ObjectReferenceValue __user = default;
            IntPtr __retval = default;
            try
            {
                __user = global::ABI.Windows.System.User.CreateMarshaler2(user);
                MarshalString.Pinnable __filePath = new(filePath);
                fixed(void* ___filePath = __filePath)
                {
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr, global::Windows.Storage.FileAccessMode, IntPtr*, int>**)ThisPtr)[10](ThisPtr, MarshalInspectable<object>.GetAbi(__user), MarshalString.GetAbi(ref __filePath), accessMode, &__retval));
                    global::System.GC.KeepAlive(_obj);
                    _ = global::WinRT.GenericTypeInstantiations.Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStream.EnsureInitialized();
                    return MarshalInterface<global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.Streams.IRandomAccessStream>>.FromAbi(__retval);
                }
            }
            finally
            {
                MarshalInspectable<object>.DisposeMarshaler(__user);
                MarshalInterface<global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.Streams.IRandomAccessStream>>.DisposeAbi(__retval);
            }
        }

        internal static unsafe global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.Streams.IRandomAccessStream> OpenForUserAsync(IObjectReference _obj, global::Windows.System.User user, string filePath, global::Windows.Storage.FileAccessMode accessMode, global::Windows.Storage.StorageOpenOptions sharingOptions, global::Windows.Storage.Streams.FileOpenDisposition openDisposition)
        {
            var ThisPtr = _obj.ThisPtr;

            ObjectReferenceValue __user = default;
            IntPtr __retval = default;
            try
            {
                __user = global::ABI.Windows.System.User.CreateMarshaler2(user);
                MarshalString.Pinnable __filePath = new(filePath);
                fixed(void* ___filePath = __filePath)
                {
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr, global::Windows.Storage.FileAccessMode, global::Windows.Storage.StorageOpenOptions, global::Windows.Storage.Streams.FileOpenDisposition, IntPtr*, int>**)ThisPtr)[11](ThisPtr, MarshalInspectable<object>.GetAbi(__user), MarshalString.GetAbi(ref __filePath), accessMode, sharingOptions, openDisposition, &__retval));
                    global::System.GC.KeepAlive(_obj);
                    _ = global::WinRT.GenericTypeInstantiations.Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStream.EnsureInitialized();
                    return MarshalInterface<global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.Streams.IRandomAccessStream>>.FromAbi(__retval);
                }
            }
            finally
            {
                MarshalInspectable<object>.DisposeMarshaler(__user);
                MarshalInterface<global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.Streams.IRandomAccessStream>>.DisposeAbi(__retval);
            }
        }

        internal static unsafe global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.StorageStreamTransaction> OpenTransactedWriteForUserAsync(IObjectReference _obj, global::Windows.System.User user, string filePath)
        {
            var ThisPtr = _obj.ThisPtr;

            ObjectReferenceValue __user = default;
            IntPtr __retval = default;
            try
            {
                __user = global::ABI.Windows.System.User.CreateMarshaler2(user);
                MarshalString.Pinnable __filePath = new(filePath);
                fixed(void* ___filePath = __filePath)
                {
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr, IntPtr*, int>**)ThisPtr)[12](ThisPtr, MarshalInspectable<object>.GetAbi(__user), MarshalString.GetAbi(ref __filePath), &__retval));
                    global::System.GC.KeepAlive(_obj);
                    _ = global::WinRT.GenericTypeInstantiations.Windows_Foundation_IAsyncOperation_1_Windows_Storage_StorageStreamTransaction.EnsureInitialized();
                    return MarshalInterface<global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.StorageStreamTransaction>>.FromAbi(__retval);
                }
            }
            finally
            {
                MarshalInspectable<object>.DisposeMarshaler(__user);
                MarshalInterface<global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.StorageStreamTransaction>>.DisposeAbi(__retval);
            }
        }

        internal static unsafe global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.StorageStreamTransaction> OpenTransactedWriteForUserAsync(IObjectReference _obj, global::Windows.System.User user, string filePath, global::Windows.Storage.StorageOpenOptions openOptions, global::Windows.Storage.Streams.FileOpenDisposition openDisposition)
        {
            var ThisPtr = _obj.ThisPtr;

            ObjectReferenceValue __user = default;
            IntPtr __retval = default;
            try
            {
                __user = global::ABI.Windows.System.User.CreateMarshaler2(user);
                MarshalString.Pinnable __filePath = new(filePath);
                fixed(void* ___filePath = __filePath)
                {
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr, global::Windows.Storage.StorageOpenOptions, global::Windows.Storage.Streams.FileOpenDisposition, IntPtr*, int>**)ThisPtr)[13](ThisPtr, MarshalInspectable<object>.GetAbi(__user), MarshalString.GetAbi(ref __filePath), openOptions, openDisposition, &__retval));
                    global::System.GC.KeepAlive(_obj);
                    _ = global::WinRT.GenericTypeInstantiations.Windows_Foundation_IAsyncOperation_1_Windows_Storage_StorageStreamTransaction.EnsureInitialized();
                    return MarshalInterface<global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.StorageStreamTransaction>>.FromAbi(__retval);
                }
            }
            finally
            {
                MarshalInspectable<object>.DisposeMarshaler(__user);
                MarshalInterface<global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.StorageStreamTransaction>>.DisposeAbi(__retval);
            }
        }


        public static ref readonly global::System.Guid IID
        {
            [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            get
            {
                global::System.ReadOnlySpan<byte> data = new byte[] { 0x7, 0x1, 0x55, 0x73, 0x57, 0x3B, 0x5D, 0x4B, 0x83, 0x45, 0x55, 0x4D, 0x2F, 0xC6, 0x21, 0xF0 };
                return ref global::System.Runtime.CompilerServices.Unsafe.As<byte, global::System.Guid>(ref global::System.Runtime.InteropServices.MemoryMarshal.GetReference(data));
            }
        }

    }
    [Guid("73550107-3B57-4B5D-8345-554D2FC621F0")]
    internal interface IFileRandomAccessStreamStatics : global::Windows.Storage.Streams.IFileRandomAccessStreamStatics
    {
    }
    public static class IInputStreamMethods
    {


        public static unsafe global::Windows.Foundation.IAsyncOperationWithProgress<global::Windows.Storage.Streams.IBuffer, uint> ReadAsync(IObjectReference _obj, global::Windows.Storage.Streams.IBuffer buffer, uint count, global::Windows.Storage.Streams.InputStreamOptions options)
        {
            var ThisPtr = _obj.ThisPtr;

            ObjectReferenceValue __buffer = default;
            IntPtr __retval = default;
            try
            {
                __buffer = MarshalInterface<global::Windows.Storage.Streams.IBuffer>.CreateMarshaler2(buffer, global::ABI.Windows.Storage.Streams.IBufferMethods.IID);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, uint, global::Windows.Storage.Streams.InputStreamOptions, IntPtr*, int>**)ThisPtr)[6](ThisPtr, MarshalInspectable<object>.GetAbi(__buffer), count, options, &__retval));
                global::System.GC.KeepAlive(_obj);
                _ = global::WinRT.GenericTypeInstantiations.Windows_Foundation_IAsyncOperationWithProgress_2_Windows_Storage_Streams_IBuffer__UInt32.EnsureInitialized();
                return MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<global::Windows.Storage.Streams.IBuffer, uint>>.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeMarshaler(__buffer);
                MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<global::Windows.Storage.Streams.IBuffer, uint>>.DisposeAbi(__retval);
            }
        }


        public static ref readonly global::System.Guid IID
        {
            [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            get
            {
                global::System.ReadOnlySpan<byte> data = new byte[] { 0xE2, 0xF, 0x5A, 0x90, 0x53, 0xBC, 0xDF, 0x11, 0x8C, 0x49, 0x0, 0x1E, 0x4F, 0xC6, 0x86, 0xDA };
                return ref global::System.Runtime.CompilerServices.Unsafe.As<byte, global::System.Guid>(ref global::System.Runtime.InteropServices.MemoryMarshal.GetReference(data));
            }
        }

        public static global::System.IntPtr AbiToProjectionVftablePtr => IInputStream.AbiToProjectionVftablePtr;

    }
    [DynamicInterfaceCastableImplementation]
    [Guid("905A0FE2-BC53-11DF-8C49-001E4FC686DA")]
    internal unsafe interface IInputStream : global::Windows.Storage.Streams.IInputStream
    {

        public static readonly IntPtr AbiToProjectionVftablePtr;
        static unsafe IInputStream()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IInputStream), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 1);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr, uint, global::Windows.Storage.Streams.InputStreamOptions, IntPtr*, int>*)AbiToProjectionVftablePtr)[6] = &Do_Abi_ReadAsync_0;
        }

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_ReadAsync_0(IntPtr thisPtr, IntPtr buffer, uint count, global::Windows.Storage.Streams.InputStreamOptions options, IntPtr* operation)
        {
            _ = global::WinRT.GenericTypeInstantiations.Windows_Foundation_IAsyncOperationWithProgress_2_Windows_Storage_Streams_IBuffer__UInt32.EnsureInitialized();

            global::Windows.Foundation.IAsyncOperationWithProgress<global::Windows.Storage.Streams.IBuffer, uint> __operation = default;

            *operation = default;

            try
            {
                __operation = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IInputStream>(thisPtr).ReadAsync(MarshalInterface<global::Windows.Storage.Streams.IBuffer>.FromAbi(buffer), count, options);
                *operation = MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<global::Windows.Storage.Streams.IBuffer, uint>>.FromManaged(__operation);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }

        unsafe global::Windows.Foundation.IAsyncOperationWithProgress<global::Windows.Storage.Streams.IBuffer, uint> global::Windows.Storage.Streams.IInputStream.ReadAsync(global::Windows.Storage.Streams.IBuffer buffer, uint count, global::Windows.Storage.Streams.InputStreamOptions options)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IInputStream).TypeHandle));
            return global::ABI.Windows.Storage.Streams.IInputStreamMethods.ReadAsync(_obj, buffer, count, options);
        }

        void global::System.IDisposable.Dispose() => ((global::System.IDisposable)(IWinRTObject)this).Dispose();
    }

    public static class IInputStreamReferenceMethods
    {


        public static unsafe global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.Streams.IInputStream> OpenSequentialReadAsync(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>**)ThisPtr)[6](ThisPtr, &__retval));
                global::System.GC.KeepAlive(_obj);
                _ = global::WinRT.GenericTypeInstantiations.Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IInputStream.EnsureInitialized();
                return MarshalInterface<global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.Streams.IInputStream>>.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.Streams.IInputStream>>.DisposeAbi(__retval);
            }
        }


        public static ref readonly global::System.Guid IID
        {
            [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            get
            {
                global::System.ReadOnlySpan<byte> data = new byte[] { 0x18, 0x9D, 0x92, 0x43, 0xC9, 0x5E, 0x5A, 0x4B, 0x91, 0x9C, 0x42, 0x5, 0xB0, 0xC8, 0x4, 0xB6 };
                return ref global::System.Runtime.CompilerServices.Unsafe.As<byte, global::System.Guid>(ref global::System.Runtime.InteropServices.MemoryMarshal.GetReference(data));
            }
        }

        public static global::System.IntPtr AbiToProjectionVftablePtr => IInputStreamReference.AbiToProjectionVftablePtr;

    }
    [DynamicInterfaceCastableImplementation]
    [Guid("43929D18-5EC9-4B5A-919C-4205B0C804B6")]
    internal unsafe interface IInputStreamReference : global::Windows.Storage.Streams.IInputStreamReference
    {

        public static readonly IntPtr AbiToProjectionVftablePtr;
        static unsafe IInputStreamReference()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IInputStreamReference), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 1);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[6] = &Do_Abi_OpenSequentialReadAsync_0;
        }

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_OpenSequentialReadAsync_0(IntPtr thisPtr, IntPtr* operation)
        {
            _ = global::WinRT.GenericTypeInstantiations.Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IInputStream.EnsureInitialized();

            global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.Streams.IInputStream> __operation = default;

            *operation = default;

            try
            {
                __operation = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IInputStreamReference>(thisPtr).OpenSequentialReadAsync();
                *operation = MarshalInterface<global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.Streams.IInputStream>>.FromManaged(__operation);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }

        unsafe global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.Streams.IInputStream> global::Windows.Storage.Streams.IInputStreamReference.OpenSequentialReadAsync()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IInputStreamReference).TypeHandle));
            return global::ABI.Windows.Storage.Streams.IInputStreamReferenceMethods.OpenSequentialReadAsync(_obj);
        }
    }

    public static class IOutputStreamMethods
    {


        public static unsafe global::Windows.Foundation.IAsyncOperationWithProgress<uint, uint> WriteAsync(IObjectReference _obj, global::Windows.Storage.Streams.IBuffer buffer)
        {
            var ThisPtr = _obj.ThisPtr;

            ObjectReferenceValue __buffer = default;
            IntPtr __retval = default;
            try
            {
                __buffer = MarshalInterface<global::Windows.Storage.Streams.IBuffer>.CreateMarshaler2(buffer, global::ABI.Windows.Storage.Streams.IBufferMethods.IID);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr*, int>**)ThisPtr)[6](ThisPtr, MarshalInspectable<object>.GetAbi(__buffer), &__retval));
                global::System.GC.KeepAlive(_obj);
                _ = global::WinRT.GenericTypeInstantiations.Windows_Foundation_IAsyncOperationWithProgress_2_UInt32__UInt32.EnsureInitialized();
                return MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<uint, uint>>.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeMarshaler(__buffer);
                MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<uint, uint>>.DisposeAbi(__retval);
            }
        }

        public static unsafe global::Windows.Foundation.IAsyncOperation<bool> FlushAsync(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>**)ThisPtr)[7](ThisPtr, &__retval));
                global::System.GC.KeepAlive(_obj);
                _ = global::WinRT.GenericTypeInstantiations.Windows_Foundation_IAsyncOperation_1_Boolean.EnsureInitialized();
                return MarshalInterface<global::Windows.Foundation.IAsyncOperation<bool>>.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::Windows.Foundation.IAsyncOperation<bool>>.DisposeAbi(__retval);
            }
        }


        public static ref readonly global::System.Guid IID
        {
            [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            get
            {
                global::System.ReadOnlySpan<byte> data = new byte[] { 0xE6, 0xF, 0x5A, 0x90, 0x53, 0xBC, 0xDF, 0x11, 0x8C, 0x49, 0x0, 0x1E, 0x4F, 0xC6, 0x86, 0xDA };
                return ref global::System.Runtime.CompilerServices.Unsafe.As<byte, global::System.Guid>(ref global::System.Runtime.InteropServices.MemoryMarshal.GetReference(data));
            }
        }

        public static global::System.IntPtr AbiToProjectionVftablePtr => IOutputStream.AbiToProjectionVftablePtr;

    }
    [DynamicInterfaceCastableImplementation]
    [Guid("905A0FE6-BC53-11DF-8C49-001E4FC686DA")]
    internal unsafe interface IOutputStream : global::Windows.Storage.Streams.IOutputStream
    {

        public static readonly IntPtr AbiToProjectionVftablePtr;
        static unsafe IOutputStream()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IOutputStream), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 2);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[6] = &Do_Abi_WriteAsync_0;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[7] = &Do_Abi_FlushAsync_1;
        }

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_WriteAsync_0(IntPtr thisPtr, IntPtr buffer, IntPtr* operation)
        {
            _ = global::WinRT.GenericTypeInstantiations.Windows_Foundation_IAsyncOperationWithProgress_2_UInt32__UInt32.EnsureInitialized();

            global::Windows.Foundation.IAsyncOperationWithProgress<uint, uint> __operation = default;

            *operation = default;

            try
            {
                __operation = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IOutputStream>(thisPtr).WriteAsync(MarshalInterface<global::Windows.Storage.Streams.IBuffer>.FromAbi(buffer));
                *operation = MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<uint, uint>>.FromManaged(__operation);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_FlushAsync_1(IntPtr thisPtr, IntPtr* operation)
        {
            _ = global::WinRT.GenericTypeInstantiations.Windows_Foundation_IAsyncOperation_1_Boolean.EnsureInitialized();

            global::Windows.Foundation.IAsyncOperation<bool> __operation = default;

            *operation = default;

            try
            {
                __operation = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IOutputStream>(thisPtr).FlushAsync();
                *operation = MarshalInterface<global::Windows.Foundation.IAsyncOperation<bool>>.FromManaged(__operation);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }

        unsafe global::Windows.Foundation.IAsyncOperationWithProgress<uint, uint> global::Windows.Storage.Streams.IOutputStream.WriteAsync(global::Windows.Storage.Streams.IBuffer buffer)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IOutputStream).TypeHandle));
            return global::ABI.Windows.Storage.Streams.IOutputStreamMethods.WriteAsync(_obj, buffer);
        }

        unsafe global::Windows.Foundation.IAsyncOperation<bool> global::Windows.Storage.Streams.IOutputStream.FlushAsync()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IOutputStream).TypeHandle));
            return global::ABI.Windows.Storage.Streams.IOutputStreamMethods.FlushAsync(_obj);
        }

        void global::System.IDisposable.Dispose() => ((global::System.IDisposable)(IWinRTObject)this).Dispose();
    }

    public static class IPropertySetSerializerMethods
    {


        public static unsafe global::Windows.Storage.Streams.IBuffer Serialize(IObjectReference _obj, global::Windows.Foundation.Collections.IPropertySet propertySet)
        {
            var ThisPtr = _obj.ThisPtr;

            ObjectReferenceValue __propertySet = default;
            IntPtr __retval = default;
            try
            {
                __propertySet = MarshalInterface<global::Windows.Foundation.Collections.IPropertySet>.CreateMarshaler2(propertySet, global::ABI.Windows.Foundation.Collections.IPropertySetMethods.IID);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr*, int>**)ThisPtr)[6](ThisPtr, MarshalInspectable<object>.GetAbi(__propertySet), &__retval));
                global::System.GC.KeepAlive(_obj);
                return MarshalInterface<global::Windows.Storage.Streams.IBuffer>.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeMarshaler(__propertySet);
                MarshalInterface<global::Windows.Storage.Streams.IBuffer>.DisposeAbi(__retval);
            }
        }

        public static unsafe void Deserialize(IObjectReference _obj, global::Windows.Foundation.Collections.IPropertySet propertySet, global::Windows.Storage.Streams.IBuffer buffer)
        {
            var ThisPtr = _obj.ThisPtr;

            ObjectReferenceValue __propertySet = default;
            ObjectReferenceValue __buffer = default;
            try
            {
                __propertySet = MarshalInterface<global::Windows.Foundation.Collections.IPropertySet>.CreateMarshaler2(propertySet, global::ABI.Windows.Foundation.Collections.IPropertySetMethods.IID);
                __buffer = MarshalInterface<global::Windows.Storage.Streams.IBuffer>.CreateMarshaler2(buffer, global::ABI.Windows.Storage.Streams.IBufferMethods.IID);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr, int>**)ThisPtr)[7](ThisPtr, MarshalInspectable<object>.GetAbi(__propertySet), MarshalInspectable<object>.GetAbi(__buffer)));
                global::System.GC.KeepAlive(_obj);
            }
            finally
            {
                MarshalInspectable<object>.DisposeMarshaler(__propertySet);
                MarshalInspectable<object>.DisposeMarshaler(__buffer);
            }
        }


        public static ref readonly global::System.Guid IID
        {
            [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            get
            {
                global::System.ReadOnlySpan<byte> data = new byte[] { 0x1C, 0xBF, 0x8E, 0x6E, 0x3D, 0xEF, 0x76, 0x43, 0xB2, 0xE, 0x5B, 0xE6, 0x38, 0xAE, 0xAC, 0x77 };
                return ref global::System.Runtime.CompilerServices.Unsafe.As<byte, global::System.Guid>(ref global::System.Runtime.InteropServices.MemoryMarshal.GetReference(data));
            }
        }

        public static global::System.IntPtr AbiToProjectionVftablePtr => IPropertySetSerializer.AbiToProjectionVftablePtr;

    }
    [DynamicInterfaceCastableImplementation]
    [Guid("6E8EBF1C-EF3D-4376-B20E-5BE638AEAC77")]
    internal unsafe interface IPropertySetSerializer : global::Windows.Storage.Streams.IPropertySetSerializer
    {

        public static readonly IntPtr AbiToProjectionVftablePtr;
        static unsafe IPropertySetSerializer()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IPropertySetSerializer), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 2);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[6] = &Do_Abi_Serialize_0;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr, int>*)AbiToProjectionVftablePtr)[7] = &Do_Abi_Deserialize_1;
        }

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_Serialize_0(IntPtr thisPtr, IntPtr propertySet, IntPtr* result)
        {

            global::Windows.Storage.Streams.IBuffer __result = default;

            *result = default;

            try
            {
                __result = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IPropertySetSerializer>(thisPtr).Serialize(MarshalInterface<global::Windows.Foundation.Collections.IPropertySet>.FromAbi(propertySet));
                *result = MarshalInterface<global::Windows.Storage.Streams.IBuffer>.FromManaged(__result);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_Deserialize_1(IntPtr thisPtr, IntPtr propertySet, IntPtr buffer)
        {



            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IPropertySetSerializer>(thisPtr).Deserialize(MarshalInterface<global::Windows.Foundation.Collections.IPropertySet>.FromAbi(propertySet), MarshalInterface<global::Windows.Storage.Streams.IBuffer>.FromAbi(buffer));

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }

        unsafe global::Windows.Storage.Streams.IBuffer global::Windows.Storage.Streams.IPropertySetSerializer.Serialize(global::Windows.Foundation.Collections.IPropertySet propertySet)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IPropertySetSerializer).TypeHandle));
            return global::ABI.Windows.Storage.Streams.IPropertySetSerializerMethods.Serialize(_obj, propertySet);
        }

        unsafe void global::Windows.Storage.Streams.IPropertySetSerializer.Deserialize(global::Windows.Foundation.Collections.IPropertySet propertySet, global::Windows.Storage.Streams.IBuffer buffer)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IPropertySetSerializer).TypeHandle));
            global::ABI.Windows.Storage.Streams.IPropertySetSerializerMethods.Deserialize(_obj, propertySet, buffer);
        }
    }

    public static class IRandomAccessStreamMethods
    {


        public static unsafe global::Windows.Storage.Streams.IInputStream GetInputStreamAt(IObjectReference _obj, ulong position)
        {
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, ulong, IntPtr*, int>**)ThisPtr)[8](ThisPtr, position, &__retval));
                global::System.GC.KeepAlive(_obj);
                return MarshalInterface<global::Windows.Storage.Streams.IInputStream>.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::Windows.Storage.Streams.IInputStream>.DisposeAbi(__retval);
            }
        }

        public static unsafe global::Windows.Storage.Streams.IOutputStream GetOutputStreamAt(IObjectReference _obj, ulong position)
        {
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, ulong, IntPtr*, int>**)ThisPtr)[9](ThisPtr, position, &__retval));
                global::System.GC.KeepAlive(_obj);
                return MarshalInterface<global::Windows.Storage.Streams.IOutputStream>.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::Windows.Storage.Streams.IOutputStream>.DisposeAbi(__retval);
            }
        }

        public static unsafe void Seek(IObjectReference _obj, ulong position)
        {
            var ThisPtr = _obj.ThisPtr;

            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, ulong, int>**)ThisPtr)[11](ThisPtr, position));
            global::System.GC.KeepAlive(_obj);
        }

        public static unsafe global::Windows.Storage.Streams.IRandomAccessStream CloneStream(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>**)ThisPtr)[12](ThisPtr, &__retval));
                global::System.GC.KeepAlive(_obj);
                return MarshalInterface<global::Windows.Storage.Streams.IRandomAccessStream>.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::Windows.Storage.Streams.IRandomAccessStream>.DisposeAbi(__retval);
            }
        }
        public static unsafe bool get_CanRead(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            byte __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, byte*, int>**)ThisPtr)[13](ThisPtr, &__retval));
            global::System.GC.KeepAlive(_obj);
            return __retval != 0;
        }

        public static unsafe bool get_CanWrite(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            byte __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, byte*, int>**)ThisPtr)[14](ThisPtr, &__retval));
            global::System.GC.KeepAlive(_obj);
            return __retval != 0;
        }

        public static unsafe ulong get_Position(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            ulong __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, ulong*, int>**)ThisPtr)[10](ThisPtr, &__retval));
            global::System.GC.KeepAlive(_obj);
            return __retval;
        }

        public static unsafe ulong get_Size(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            ulong __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, ulong*, int>**)ThisPtr)[6](ThisPtr, &__retval));
            global::System.GC.KeepAlive(_obj);
            return __retval;
        }
        public static unsafe void set_Size(IObjectReference _obj, ulong value)
        {
            var ThisPtr = _obj.ThisPtr;

            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, ulong, int>**)ThisPtr)[7](ThisPtr, value));
            global::System.GC.KeepAlive(_obj);
        }



        public static ref readonly global::System.Guid IID
        {
            [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            get
            {
                global::System.ReadOnlySpan<byte> data = new byte[] { 0xE1, 0xF, 0x5A, 0x90, 0x53, 0xBC, 0xDF, 0x11, 0x8C, 0x49, 0x0, 0x1E, 0x4F, 0xC6, 0x86, 0xDA };
                return ref global::System.Runtime.CompilerServices.Unsafe.As<byte, global::System.Guid>(ref global::System.Runtime.InteropServices.MemoryMarshal.GetReference(data));
            }
        }

        public static global::System.IntPtr AbiToProjectionVftablePtr => IRandomAccessStream.AbiToProjectionVftablePtr;

    }
    [DynamicInterfaceCastableImplementation]
    [Guid("905A0FE1-BC53-11DF-8C49-001E4FC686DA")]
    internal unsafe interface IRandomAccessStream : global::Windows.Storage.Streams.IRandomAccessStream
    {

        public static readonly IntPtr AbiToProjectionVftablePtr;
        static unsafe IRandomAccessStream()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IRandomAccessStream), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 9);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;
            ((delegate* unmanaged[Stdcall]<IntPtr, ulong*, int>*)AbiToProjectionVftablePtr)[6] = &Do_Abi_get_Size_0;
            ((delegate* unmanaged[Stdcall]<IntPtr, ulong, int>*)AbiToProjectionVftablePtr)[7] = &Do_Abi_put_Size_1;
            ((delegate* unmanaged[Stdcall]<IntPtr, ulong, IntPtr*, int>*)AbiToProjectionVftablePtr)[8] = &Do_Abi_GetInputStreamAt_2;
            ((delegate* unmanaged[Stdcall]<IntPtr, ulong, IntPtr*, int>*)AbiToProjectionVftablePtr)[9] = &Do_Abi_GetOutputStreamAt_3;
            ((delegate* unmanaged[Stdcall]<IntPtr, ulong*, int>*)AbiToProjectionVftablePtr)[10] = &Do_Abi_get_Position_4;
            ((delegate* unmanaged[Stdcall]<IntPtr, ulong, int>*)AbiToProjectionVftablePtr)[11] = &Do_Abi_Seek_5;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[12] = &Do_Abi_CloneStream_6;
            ((delegate* unmanaged[Stdcall]<IntPtr, byte*, int>*)AbiToProjectionVftablePtr)[13] = &Do_Abi_get_CanRead_7;
            ((delegate* unmanaged[Stdcall]<IntPtr, byte*, int>*)AbiToProjectionVftablePtr)[14] = &Do_Abi_get_CanWrite_8;
        }

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_GetInputStreamAt_2(IntPtr thisPtr, ulong position, IntPtr* stream)
        {

            global::Windows.Storage.Streams.IInputStream __stream = default;

            *stream = default;

            try
            {
                __stream = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IRandomAccessStream>(thisPtr).GetInputStreamAt(position);
                *stream = MarshalInterface<global::Windows.Storage.Streams.IInputStream>.FromManaged(__stream);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_GetOutputStreamAt_3(IntPtr thisPtr, ulong position, IntPtr* stream)
        {

            global::Windows.Storage.Streams.IOutputStream __stream = default;

            *stream = default;

            try
            {
                __stream = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IRandomAccessStream>(thisPtr).GetOutputStreamAt(position);
                *stream = MarshalInterface<global::Windows.Storage.Streams.IOutputStream>.FromManaged(__stream);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_Seek_5(IntPtr thisPtr, ulong position)
        {



            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IRandomAccessStream>(thisPtr).Seek(position);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_CloneStream_6(IntPtr thisPtr, IntPtr* stream)
        {

            global::Windows.Storage.Streams.IRandomAccessStream __stream = default;

            *stream = default;

            try
            {
                __stream = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IRandomAccessStream>(thisPtr).CloneStream();
                *stream = MarshalInterface<global::Windows.Storage.Streams.IRandomAccessStream>.FromManaged(__stream);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_CanRead_7(IntPtr thisPtr, byte* value)
        {

            bool __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IRandomAccessStream>(thisPtr).CanRead;
                *value = (byte)(__value ? 1 : 0);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_CanWrite_8(IntPtr thisPtr, byte* value)
        {

            bool __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IRandomAccessStream>(thisPtr).CanWrite;
                *value = (byte)(__value ? 1 : 0);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_Position_4(IntPtr thisPtr, ulong* value)
        {

            ulong __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IRandomAccessStream>(thisPtr).Position;
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_put_Size_1(IntPtr thisPtr, ulong value)
        {



            try
            {
                global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IRandomAccessStream>(thisPtr).Size = value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }
        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_get_Size_0(IntPtr thisPtr, ulong* value)
        {

            ulong __value = default;

            *value = default;

            try
            {
                __value = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IRandomAccessStream>(thisPtr).Size;
                *value = __value;

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }

        unsafe global::Windows.Storage.Streams.IInputStream global::Windows.Storage.Streams.IRandomAccessStream.GetInputStreamAt(ulong position)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IRandomAccessStream).TypeHandle));
            return global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.GetInputStreamAt(_obj, position);
        }

        unsafe global::Windows.Storage.Streams.IOutputStream global::Windows.Storage.Streams.IRandomAccessStream.GetOutputStreamAt(ulong position)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IRandomAccessStream).TypeHandle));
            return global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.GetOutputStreamAt(_obj, position);
        }

        unsafe void global::Windows.Storage.Streams.IRandomAccessStream.Seek(ulong position)
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IRandomAccessStream).TypeHandle));
            global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.Seek(_obj, position);
        }

        unsafe global::Windows.Storage.Streams.IRandomAccessStream global::Windows.Storage.Streams.IRandomAccessStream.CloneStream()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IRandomAccessStream).TypeHandle));
            return global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.CloneStream(_obj);
        }

        unsafe bool global::Windows.Storage.Streams.IRandomAccessStream.CanRead
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IRandomAccessStream).TypeHandle));
                return global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.get_CanRead(_obj);
            }
        }

        unsafe bool global::Windows.Storage.Streams.IRandomAccessStream.CanWrite
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IRandomAccessStream).TypeHandle));
                return global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.get_CanWrite(_obj);
            }
        }

        unsafe ulong global::Windows.Storage.Streams.IRandomAccessStream.Position
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IRandomAccessStream).TypeHandle));
                return global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.get_Position(_obj);
            }
        }

        unsafe ulong global::Windows.Storage.Streams.IRandomAccessStream.Size
        {
            get
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IRandomAccessStream).TypeHandle));
                return global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.get_Size(_obj);
            }
            set
            {
                var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IRandomAccessStream).TypeHandle));
                global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.set_Size(_obj, value);
            }
        }

        void global::System.IDisposable.Dispose() => ((global::System.IDisposable)(IWinRTObject)this).Dispose();

        global::Windows.Foundation.IAsyncOperationWithProgress<global::Windows.Storage.Streams.IBuffer, uint> global::Windows.Storage.Streams.IInputStream.ReadAsync(global::Windows.Storage.Streams.IBuffer buffer, uint count, global::Windows.Storage.Streams.InputStreamOptions options) => ((global::Windows.Storage.Streams.IInputStream)(IWinRTObject)this).ReadAsync(buffer, count, options);

        global::Windows.Foundation.IAsyncOperationWithProgress<uint, uint> global::Windows.Storage.Streams.IOutputStream.WriteAsync(global::Windows.Storage.Streams.IBuffer buffer) => ((global::Windows.Storage.Streams.IOutputStream)(IWinRTObject)this).WriteAsync(buffer);

        global::Windows.Foundation.IAsyncOperation<bool> global::Windows.Storage.Streams.IOutputStream.FlushAsync() => ((global::Windows.Storage.Streams.IOutputStream)(IWinRTObject)this).FlushAsync();
    }

    public static class IRandomAccessStreamReferenceMethods
    {


        public static unsafe global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.Streams.IRandomAccessStreamWithContentType> OpenReadAsync(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>**)ThisPtr)[6](ThisPtr, &__retval));
                global::System.GC.KeepAlive(_obj);
                _ = global::WinRT.GenericTypeInstantiations.Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStreamWithContentType.EnsureInitialized();
                return MarshalInterface<global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.Streams.IRandomAccessStreamWithContentType>>.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.Streams.IRandomAccessStreamWithContentType>>.DisposeAbi(__retval);
            }
        }


        public static ref readonly global::System.Guid IID
        {
            [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            get
            {
                global::System.ReadOnlySpan<byte> data = new byte[] { 0x34, 0x31, 0xEE, 0x33, 0xD6, 0x1D, 0x3A, 0x4E, 0x80, 0x67, 0xD1, 0xC1, 0x62, 0xE8, 0x64, 0x2B };
                return ref global::System.Runtime.CompilerServices.Unsafe.As<byte, global::System.Guid>(ref global::System.Runtime.InteropServices.MemoryMarshal.GetReference(data));
            }
        }

        public static global::System.IntPtr AbiToProjectionVftablePtr => IRandomAccessStreamReference.AbiToProjectionVftablePtr;

    }
    [DynamicInterfaceCastableImplementation]
    [Guid("33EE3134-1DD6-4E3A-8067-D1C162E8642B")]
    internal unsafe interface IRandomAccessStreamReference : global::Windows.Storage.Streams.IRandomAccessStreamReference
    {

        public static readonly IntPtr AbiToProjectionVftablePtr;
        static unsafe IRandomAccessStreamReference()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IRandomAccessStreamReference), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 1);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;
            ((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>*)AbiToProjectionVftablePtr)[6] = &Do_Abi_OpenReadAsync_0;
        }

        [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
        private static unsafe int Do_Abi_OpenReadAsync_0(IntPtr thisPtr, IntPtr* operation)
        {
            _ = global::WinRT.GenericTypeInstantiations.Windows_Foundation_IAsyncOperation_1_Windows_Storage_Streams_IRandomAccessStreamWithContentType.EnsureInitialized();

            global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.Streams.IRandomAccessStreamWithContentType> __operation = default;

            *operation = default;

            try
            {
                __operation = global::WinRT.ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IRandomAccessStreamReference>(thisPtr).OpenReadAsync();
                *operation = MarshalInterface<global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.Streams.IRandomAccessStreamWithContentType>>.FromManaged(__operation);

            }
            catch (Exception __exception__)
            {
                global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
            }
            return 0;
        }

        unsafe global::Windows.Foundation.IAsyncOperation<global::Windows.Storage.Streams.IRandomAccessStreamWithContentType> global::Windows.Storage.Streams.IRandomAccessStreamReference.OpenReadAsync()
        {
            var _obj = ((IObjectReference)((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IRandomAccessStreamReference).TypeHandle));
            return global::ABI.Windows.Storage.Streams.IRandomAccessStreamReferenceMethods.OpenReadAsync(_obj);
        }
    }

    internal static class IRandomAccessStreamReferenceStaticsMethods
    {


        internal static unsafe global::Windows.Storage.Streams.RandomAccessStreamReference CreateFromFile(IObjectReference _obj, global::Windows.Storage.IStorageFile file)
        {
            var ThisPtr = _obj.ThisPtr;

            ObjectReferenceValue __file = default;
            IntPtr __retval = default;
            try
            {
                __file = MarshalInterface<global::Windows.Storage.IStorageFile>.CreateMarshaler2(file, global::ABI.Windows.Storage.IStorageFileMethods.IID);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr*, int>**)ThisPtr)[6](ThisPtr, MarshalInspectable<object>.GetAbi(__file), &__retval));
                global::System.GC.KeepAlive(_obj);
                return global::ABI.Windows.Storage.Streams.RandomAccessStreamReference.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeMarshaler(__file);
                global::ABI.Windows.Storage.Streams.RandomAccessStreamReference.DisposeAbi(__retval);
            }
        }

        internal static unsafe global::Windows.Storage.Streams.RandomAccessStreamReference CreateFromUri(IObjectReference _obj, global::System.Uri uri)
        {
            var ThisPtr = _obj.ThisPtr;

            ObjectReferenceValue __uri = default;
            IntPtr __retval = default;
            try
            {
                __uri = global::ABI.System.Uri.CreateMarshaler2(uri);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr*, int>**)ThisPtr)[7](ThisPtr, MarshalInspectable<object>.GetAbi(__uri), &__retval));
                global::System.GC.KeepAlive(_obj);
                return global::ABI.Windows.Storage.Streams.RandomAccessStreamReference.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeMarshaler(__uri);
                global::ABI.Windows.Storage.Streams.RandomAccessStreamReference.DisposeAbi(__retval);
            }
        }

        internal static unsafe global::Windows.Storage.Streams.RandomAccessStreamReference CreateFromStream(IObjectReference _obj, global::Windows.Storage.Streams.IRandomAccessStream stream)
        {
            var ThisPtr = _obj.ThisPtr;

            ObjectReferenceValue __stream = default;
            IntPtr __retval = default;
            try
            {
                __stream = MarshalInterface<global::Windows.Storage.Streams.IRandomAccessStream>.CreateMarshaler2(stream, global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.IID);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr*, int>**)ThisPtr)[8](ThisPtr, MarshalInspectable<object>.GetAbi(__stream), &__retval));
                global::System.GC.KeepAlive(_obj);
                return global::ABI.Windows.Storage.Streams.RandomAccessStreamReference.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeMarshaler(__stream);
                global::ABI.Windows.Storage.Streams.RandomAccessStreamReference.DisposeAbi(__retval);
            }
        }


        public static ref readonly global::System.Guid IID
        {
            [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            get
            {
                global::System.ReadOnlySpan<byte> data = new byte[] { 0xDC, 0x9, 0x73, 0x85, 0xBF, 0x3F, 0x7D, 0x4E, 0x98, 0x6F, 0xEF, 0x3B, 0x1A, 0x7, 0xA9, 0x64 };
                return ref global::System.Runtime.CompilerServices.Unsafe.As<byte, global::System.Guid>(ref global::System.Runtime.InteropServices.MemoryMarshal.GetReference(data));
            }
        }

    }
    [Guid("857309DC-3FBF-4E7D-986F-EF3B1A07A964")]
    internal interface IRandomAccessStreamReferenceStatics : global::Windows.Storage.Streams.IRandomAccessStreamReferenceStatics
    {
    }
    internal static class IRandomAccessStreamStaticsMethods
    {


        internal static unsafe global::Windows.Foundation.IAsyncOperationWithProgress<ulong, ulong> CopyAsync(IObjectReference _obj, global::Windows.Storage.Streams.IInputStream source, global::Windows.Storage.Streams.IOutputStream destination)
        {
            var ThisPtr = _obj.ThisPtr;

            ObjectReferenceValue __source = default;
            ObjectReferenceValue __destination = default;
            IntPtr __retval = default;
            try
            {
                __source = MarshalInterface<global::Windows.Storage.Streams.IInputStream>.CreateMarshaler2(source, global::ABI.Windows.Storage.Streams.IInputStreamMethods.IID);
                __destination = MarshalInterface<global::Windows.Storage.Streams.IOutputStream>.CreateMarshaler2(destination, global::ABI.Windows.Storage.Streams.IOutputStreamMethods.IID);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr, IntPtr*, int>**)ThisPtr)[6](ThisPtr, MarshalInspectable<object>.GetAbi(__source), MarshalInspectable<object>.GetAbi(__destination), &__retval));
                global::System.GC.KeepAlive(_obj);
                _ = global::WinRT.GenericTypeInstantiations.Windows_Foundation_IAsyncOperationWithProgress_2_UInt64__UInt64.EnsureInitialized();
                return MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<ulong, ulong>>.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeMarshaler(__source);
                MarshalInspectable<object>.DisposeMarshaler(__destination);
                MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<ulong, ulong>>.DisposeAbi(__retval);
            }
        }

        internal static unsafe global::Windows.Foundation.IAsyncOperationWithProgress<ulong, ulong> CopyAsync(IObjectReference _obj, global::Windows.Storage.Streams.IInputStream source, global::Windows.Storage.Streams.IOutputStream destination, ulong bytesToCopy)
        {
            var ThisPtr = _obj.ThisPtr;

            ObjectReferenceValue __source = default;
            ObjectReferenceValue __destination = default;
            IntPtr __retval = default;
            try
            {
                __source = MarshalInterface<global::Windows.Storage.Streams.IInputStream>.CreateMarshaler2(source, global::ABI.Windows.Storage.Streams.IInputStreamMethods.IID);
                __destination = MarshalInterface<global::Windows.Storage.Streams.IOutputStream>.CreateMarshaler2(destination, global::ABI.Windows.Storage.Streams.IOutputStreamMethods.IID);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr, ulong, IntPtr*, int>**)ThisPtr)[7](ThisPtr, MarshalInspectable<object>.GetAbi(__source), MarshalInspectable<object>.GetAbi(__destination), bytesToCopy, &__retval));
                global::System.GC.KeepAlive(_obj);
                _ = global::WinRT.GenericTypeInstantiations.Windows_Foundation_IAsyncOperationWithProgress_2_UInt64__UInt64.EnsureInitialized();
                return MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<ulong, ulong>>.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeMarshaler(__source);
                MarshalInspectable<object>.DisposeMarshaler(__destination);
                MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<ulong, ulong>>.DisposeAbi(__retval);
            }
        }

        internal static unsafe global::Windows.Foundation.IAsyncOperationWithProgress<ulong, ulong> CopyAndCloseAsync(IObjectReference _obj, global::Windows.Storage.Streams.IInputStream source, global::Windows.Storage.Streams.IOutputStream destination)
        {
            var ThisPtr = _obj.ThisPtr;

            ObjectReferenceValue __source = default;
            ObjectReferenceValue __destination = default;
            IntPtr __retval = default;
            try
            {
                __source = MarshalInterface<global::Windows.Storage.Streams.IInputStream>.CreateMarshaler2(source, global::ABI.Windows.Storage.Streams.IInputStreamMethods.IID);
                __destination = MarshalInterface<global::Windows.Storage.Streams.IOutputStream>.CreateMarshaler2(destination, global::ABI.Windows.Storage.Streams.IOutputStreamMethods.IID);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr, IntPtr*, int>**)ThisPtr)[8](ThisPtr, MarshalInspectable<object>.GetAbi(__source), MarshalInspectable<object>.GetAbi(__destination), &__retval));
                global::System.GC.KeepAlive(_obj);
                _ = global::WinRT.GenericTypeInstantiations.Windows_Foundation_IAsyncOperationWithProgress_2_UInt64__UInt64.EnsureInitialized();
                return MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<ulong, ulong>>.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeMarshaler(__source);
                MarshalInspectable<object>.DisposeMarshaler(__destination);
                MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<ulong, ulong>>.DisposeAbi(__retval);
            }
        }


        public static ref readonly global::System.Guid IID
        {
            [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            get
            {
                global::System.ReadOnlySpan<byte> data = new byte[] { 0xCF, 0xED, 0x4C, 0x52, 0x29, 0x6E, 0xE5, 0x4C, 0x95, 0x73, 0x6B, 0x75, 0x3D, 0xB6, 0x6C, 0x3A };
                return ref global::System.Runtime.CompilerServices.Unsafe.As<byte, global::System.Guid>(ref global::System.Runtime.InteropServices.MemoryMarshal.GetReference(data));
            }
        }

    }
    [Guid("524CEDCF-6E29-4CE5-9573-6B753DB66C3A")]
    internal interface IRandomAccessStreamStatics : global::Windows.Storage.Streams.IRandomAccessStreamStatics
    {
    }
    public static class IRandomAccessStreamWithContentTypeMethods
    {



        public static ref readonly global::System.Guid IID
        {
            [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            get
            {
                global::System.ReadOnlySpan<byte> data = new byte[] { 0x27, 0x48, 0x25, 0xCC, 0x3D, 0x4B, 0x8F, 0x43, 0x92, 0x32, 0x10, 0xC7, 0x6B, 0xC7, 0xE0, 0x38 };
                return ref global::System.Runtime.CompilerServices.Unsafe.As<byte, global::System.Guid>(ref global::System.Runtime.InteropServices.MemoryMarshal.GetReference(data));
            }
        }

        public static global::System.IntPtr AbiToProjectionVftablePtr => IRandomAccessStreamWithContentType.AbiToProjectionVftablePtr;

    }
    [DynamicInterfaceCastableImplementation]
    [Guid("CC254827-4B3D-438F-9232-10C76BC7E038")]
    internal unsafe interface IRandomAccessStreamWithContentType : global::Windows.Storage.Streams.IRandomAccessStreamWithContentType
    {

        public static readonly IntPtr AbiToProjectionVftablePtr;
        static unsafe IRandomAccessStreamWithContentType()
        {
            AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(IRandomAccessStreamWithContentType), sizeof(IInspectable.Vftbl) + sizeof(IntPtr) * 0);
            *(IInspectable.Vftbl*)AbiToProjectionVftablePtr = IInspectable.Vftbl.AbiToProjectionVftable;

        }


        void global::System.IDisposable.Dispose() => ((global::System.IDisposable)(IWinRTObject)this).Dispose();

        string global::Windows.Storage.Streams.IContentTypeProvider.ContentType => ((global::Windows.Storage.Streams.IContentTypeProvider)(IWinRTObject)this).ContentType;

        global::Windows.Foundation.IAsyncOperationWithProgress<global::Windows.Storage.Streams.IBuffer, uint> global::Windows.Storage.Streams.IInputStream.ReadAsync(global::Windows.Storage.Streams.IBuffer buffer, uint count, global::Windows.Storage.Streams.InputStreamOptions options) => ((global::Windows.Storage.Streams.IInputStream)(IWinRTObject)this).ReadAsync(buffer, count, options);

        global::Windows.Foundation.IAsyncOperationWithProgress<uint, uint> global::Windows.Storage.Streams.IOutputStream.WriteAsync(global::Windows.Storage.Streams.IBuffer buffer) => ((global::Windows.Storage.Streams.IOutputStream)(IWinRTObject)this).WriteAsync(buffer);

        global::Windows.Foundation.IAsyncOperation<bool> global::Windows.Storage.Streams.IOutputStream.FlushAsync() => ((global::Windows.Storage.Streams.IOutputStream)(IWinRTObject)this).FlushAsync();

        global::Windows.Storage.Streams.IInputStream global::Windows.Storage.Streams.IRandomAccessStream.GetInputStreamAt(ulong position) => ((global::Windows.Storage.Streams.IRandomAccessStream)(IWinRTObject)this).GetInputStreamAt(position);

        global::Windows.Storage.Streams.IOutputStream global::Windows.Storage.Streams.IRandomAccessStream.GetOutputStreamAt(ulong position) => ((global::Windows.Storage.Streams.IRandomAccessStream)(IWinRTObject)this).GetOutputStreamAt(position);

        void global::Windows.Storage.Streams.IRandomAccessStream.Seek(ulong position) => ((global::Windows.Storage.Streams.IRandomAccessStream)(IWinRTObject)this).Seek(position);

        global::Windows.Storage.Streams.IRandomAccessStream global::Windows.Storage.Streams.IRandomAccessStream.CloneStream() => ((global::Windows.Storage.Streams.IRandomAccessStream)(IWinRTObject)this).CloneStream();

        bool global::Windows.Storage.Streams.IRandomAccessStream.CanRead => ((global::Windows.Storage.Streams.IRandomAccessStream)(IWinRTObject)this).CanRead;

        bool global::Windows.Storage.Streams.IRandomAccessStream.CanWrite => ((global::Windows.Storage.Streams.IRandomAccessStream)(IWinRTObject)this).CanWrite;

        ulong global::Windows.Storage.Streams.IRandomAccessStream.Position => ((global::Windows.Storage.Streams.IRandomAccessStream)(IWinRTObject)this).Position;

        ulong global::Windows.Storage.Streams.IRandomAccessStream.Size
        {
            get => ((global::Windows.Storage.Streams.IRandomAccessStream)(IWinRTObject)this).Size;
            set => ((global::Windows.Storage.Streams.IRandomAccessStream)(IWinRTObject)this).Size = value;
        }
    }

    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public struct InMemoryRandomAccessStream
    {

        public static IObjectReference CreateMarshaler(global::Windows.Storage.Streams.InMemoryRandomAccessStream obj) => obj is null ? null : MarshalInterface<global::Windows.Storage.Streams.IRandomAccessStream>.CreateMarshaler(obj);
        public static ObjectReferenceValue CreateMarshaler2(global::Windows.Storage.Streams.InMemoryRandomAccessStream obj) => MarshalInterface<global::Windows.Storage.Streams.IRandomAccessStream>.CreateMarshaler2(obj, global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.IID);
        public static IntPtr GetAbi(IObjectReference value) => value is null ? IntPtr.Zero : MarshalInterfaceHelper<object>.GetAbi(value);
        public static global::Windows.Storage.Streams.InMemoryRandomAccessStream FromAbi(IntPtr thisPtr) => global::Windows.Storage.Streams.InMemoryRandomAccessStream.FromAbi(thisPtr);
        public static IntPtr FromManaged(global::Windows.Storage.Streams.InMemoryRandomAccessStream obj) => obj is null ? IntPtr.Zero : CreateMarshaler2(obj).Detach();
        public static unsafe MarshalInterfaceHelper<global::Windows.Storage.Streams.InMemoryRandomAccessStream>.MarshalerArray CreateMarshalerArray(global::Windows.Storage.Streams.InMemoryRandomAccessStream[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.InMemoryRandomAccessStream>.CreateMarshalerArray2(array, (o) => CreateMarshaler2(o));
        public static (int length, IntPtr data) GetAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.InMemoryRandomAccessStream>.GetAbiArray(box);
        public static unsafe global::Windows.Storage.Streams.InMemoryRandomAccessStream[] FromAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.InMemoryRandomAccessStream>.FromAbiArray(box, FromAbi);
        public static void CopyAbiArray(global::Windows.Storage.Streams.InMemoryRandomAccessStream[] array, object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.InMemoryRandomAccessStream>.CopyAbiArray(array, box, FromAbi);
        public static (int length, IntPtr data) FromManagedArray(global::Windows.Storage.Streams.InMemoryRandomAccessStream[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.InMemoryRandomAccessStream>.FromManagedArray(array, (o) => FromManaged(o));
        public static void DisposeMarshaler(IObjectReference value) => MarshalInspectable<object>.DisposeMarshaler(value);
        public static void DisposeMarshalerArray(MarshalInterfaceHelper<global::Windows.Storage.Streams.InMemoryRandomAccessStream>.MarshalerArray array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.InMemoryRandomAccessStream>.DisposeMarshalerArray(array);
        public static void DisposeAbi(IntPtr abi) => MarshalInspectable<object>.DisposeAbi(abi);
        public static unsafe void DisposeAbiArray(object box) => MarshalInspectable<object>.DisposeAbiArray(box);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    internal sealed class InMemoryRandomAccessStreamRcwFactoryAttribute : global::WinRT.WinRTImplementationTypeRcwFactoryAttribute
    {
        public override object CreateInstance(global::WinRT.IInspectable inspectable)
            => new global::Windows.Storage.Streams.InMemoryRandomAccessStream(inspectable.ObjRef);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public struct InputStreamOverStream
    {

        public static IObjectReference CreateMarshaler(global::Windows.Storage.Streams.InputStreamOverStream obj) => obj is null ? null : MarshalInterface<global::Windows.Storage.Streams.IInputStream>.CreateMarshaler(obj);
        public static ObjectReferenceValue CreateMarshaler2(global::Windows.Storage.Streams.InputStreamOverStream obj) => MarshalInterface<global::Windows.Storage.Streams.IInputStream>.CreateMarshaler2(obj, global::ABI.Windows.Storage.Streams.IInputStreamMethods.IID);
        public static IntPtr GetAbi(IObjectReference value) => value is null ? IntPtr.Zero : MarshalInterfaceHelper<object>.GetAbi(value);
        public static global::Windows.Storage.Streams.InputStreamOverStream FromAbi(IntPtr thisPtr) => global::Windows.Storage.Streams.InputStreamOverStream.FromAbi(thisPtr);
        public static IntPtr FromManaged(global::Windows.Storage.Streams.InputStreamOverStream obj) => obj is null ? IntPtr.Zero : CreateMarshaler2(obj).Detach();
        public static unsafe MarshalInterfaceHelper<global::Windows.Storage.Streams.InputStreamOverStream>.MarshalerArray CreateMarshalerArray(global::Windows.Storage.Streams.InputStreamOverStream[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.InputStreamOverStream>.CreateMarshalerArray2(array, (o) => CreateMarshaler2(o));
        public static (int length, IntPtr data) GetAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.InputStreamOverStream>.GetAbiArray(box);
        public static unsafe global::Windows.Storage.Streams.InputStreamOverStream[] FromAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.InputStreamOverStream>.FromAbiArray(box, FromAbi);
        public static void CopyAbiArray(global::Windows.Storage.Streams.InputStreamOverStream[] array, object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.InputStreamOverStream>.CopyAbiArray(array, box, FromAbi);
        public static (int length, IntPtr data) FromManagedArray(global::Windows.Storage.Streams.InputStreamOverStream[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.InputStreamOverStream>.FromManagedArray(array, (o) => FromManaged(o));
        public static void DisposeMarshaler(IObjectReference value) => MarshalInspectable<object>.DisposeMarshaler(value);
        public static void DisposeMarshalerArray(MarshalInterfaceHelper<global::Windows.Storage.Streams.InputStreamOverStream>.MarshalerArray array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.InputStreamOverStream>.DisposeMarshalerArray(array);
        public static void DisposeAbi(IntPtr abi) => MarshalInspectable<object>.DisposeAbi(abi);
        public static unsafe void DisposeAbiArray(object box) => MarshalInspectable<object>.DisposeAbiArray(box);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    internal sealed class InputStreamOverStreamRcwFactoryAttribute : global::WinRT.WinRTImplementationTypeRcwFactoryAttribute
    {
        public override object CreateInstance(global::WinRT.IInspectable inspectable)
            => new global::Windows.Storage.Streams.InputStreamOverStream(inspectable.ObjRef);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public struct OutputStreamOverStream
    {

        public static IObjectReference CreateMarshaler(global::Windows.Storage.Streams.OutputStreamOverStream obj) => obj is null ? null : MarshalInterface<global::Windows.Storage.Streams.IOutputStream>.CreateMarshaler(obj);
        public static ObjectReferenceValue CreateMarshaler2(global::Windows.Storage.Streams.OutputStreamOverStream obj) => MarshalInterface<global::Windows.Storage.Streams.IOutputStream>.CreateMarshaler2(obj, global::ABI.Windows.Storage.Streams.IOutputStreamMethods.IID);
        public static IntPtr GetAbi(IObjectReference value) => value is null ? IntPtr.Zero : MarshalInterfaceHelper<object>.GetAbi(value);
        public static global::Windows.Storage.Streams.OutputStreamOverStream FromAbi(IntPtr thisPtr) => global::Windows.Storage.Streams.OutputStreamOverStream.FromAbi(thisPtr);
        public static IntPtr FromManaged(global::Windows.Storage.Streams.OutputStreamOverStream obj) => obj is null ? IntPtr.Zero : CreateMarshaler2(obj).Detach();
        public static unsafe MarshalInterfaceHelper<global::Windows.Storage.Streams.OutputStreamOverStream>.MarshalerArray CreateMarshalerArray(global::Windows.Storage.Streams.OutputStreamOverStream[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.OutputStreamOverStream>.CreateMarshalerArray2(array, (o) => CreateMarshaler2(o));
        public static (int length, IntPtr data) GetAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.OutputStreamOverStream>.GetAbiArray(box);
        public static unsafe global::Windows.Storage.Streams.OutputStreamOverStream[] FromAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.OutputStreamOverStream>.FromAbiArray(box, FromAbi);
        public static void CopyAbiArray(global::Windows.Storage.Streams.OutputStreamOverStream[] array, object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.OutputStreamOverStream>.CopyAbiArray(array, box, FromAbi);
        public static (int length, IntPtr data) FromManagedArray(global::Windows.Storage.Streams.OutputStreamOverStream[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.OutputStreamOverStream>.FromManagedArray(array, (o) => FromManaged(o));
        public static void DisposeMarshaler(IObjectReference value) => MarshalInspectable<object>.DisposeMarshaler(value);
        public static void DisposeMarshalerArray(MarshalInterfaceHelper<global::Windows.Storage.Streams.OutputStreamOverStream>.MarshalerArray array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.OutputStreamOverStream>.DisposeMarshalerArray(array);
        public static void DisposeAbi(IntPtr abi) => MarshalInspectable<object>.DisposeAbi(abi);
        public static unsafe void DisposeAbiArray(object box) => MarshalInspectable<object>.DisposeAbiArray(box);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    internal sealed class OutputStreamOverStreamRcwFactoryAttribute : global::WinRT.WinRTImplementationTypeRcwFactoryAttribute
    {
        public override object CreateInstance(global::WinRT.IInspectable inspectable)
            => new global::Windows.Storage.Streams.OutputStreamOverStream(inspectable.ObjRef);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public struct RandomAccessStreamOverStream
    {

        public static IObjectReference CreateMarshaler(global::Windows.Storage.Streams.RandomAccessStreamOverStream obj) => obj is null ? null : MarshalInterface<global::Windows.Storage.Streams.IRandomAccessStream>.CreateMarshaler(obj);
        public static ObjectReferenceValue CreateMarshaler2(global::Windows.Storage.Streams.RandomAccessStreamOverStream obj) => MarshalInterface<global::Windows.Storage.Streams.IRandomAccessStream>.CreateMarshaler2(obj, global::ABI.Windows.Storage.Streams.IRandomAccessStreamMethods.IID);
        public static IntPtr GetAbi(IObjectReference value) => value is null ? IntPtr.Zero : MarshalInterfaceHelper<object>.GetAbi(value);
        public static global::Windows.Storage.Streams.RandomAccessStreamOverStream FromAbi(IntPtr thisPtr) => global::Windows.Storage.Streams.RandomAccessStreamOverStream.FromAbi(thisPtr);
        public static IntPtr FromManaged(global::Windows.Storage.Streams.RandomAccessStreamOverStream obj) => obj is null ? IntPtr.Zero : CreateMarshaler2(obj).Detach();
        public static unsafe MarshalInterfaceHelper<global::Windows.Storage.Streams.RandomAccessStreamOverStream>.MarshalerArray CreateMarshalerArray(global::Windows.Storage.Streams.RandomAccessStreamOverStream[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.RandomAccessStreamOverStream>.CreateMarshalerArray2(array, (o) => CreateMarshaler2(o));
        public static (int length, IntPtr data) GetAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.RandomAccessStreamOverStream>.GetAbiArray(box);
        public static unsafe global::Windows.Storage.Streams.RandomAccessStreamOverStream[] FromAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.RandomAccessStreamOverStream>.FromAbiArray(box, FromAbi);
        public static void CopyAbiArray(global::Windows.Storage.Streams.RandomAccessStreamOverStream[] array, object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.RandomAccessStreamOverStream>.CopyAbiArray(array, box, FromAbi);
        public static (int length, IntPtr data) FromManagedArray(global::Windows.Storage.Streams.RandomAccessStreamOverStream[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.RandomAccessStreamOverStream>.FromManagedArray(array, (o) => FromManaged(o));
        public static void DisposeMarshaler(IObjectReference value) => MarshalInspectable<object>.DisposeMarshaler(value);
        public static void DisposeMarshalerArray(MarshalInterfaceHelper<global::Windows.Storage.Streams.RandomAccessStreamOverStream>.MarshalerArray array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.RandomAccessStreamOverStream>.DisposeMarshalerArray(array);
        public static void DisposeAbi(IntPtr abi) => MarshalInspectable<object>.DisposeAbi(abi);
        public static unsafe void DisposeAbiArray(object box) => MarshalInspectable<object>.DisposeAbiArray(box);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    internal sealed class RandomAccessStreamOverStreamRcwFactoryAttribute : global::WinRT.WinRTImplementationTypeRcwFactoryAttribute
    {
        public override object CreateInstance(global::WinRT.IInspectable inspectable)
            => new global::Windows.Storage.Streams.RandomAccessStreamOverStream(inspectable.ObjRef);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public struct RandomAccessStreamReference
    {

        public static IObjectReference CreateMarshaler(global::Windows.Storage.Streams.RandomAccessStreamReference obj) => obj is null ? null : MarshalInterface<global::Windows.Storage.Streams.IRandomAccessStreamReference>.CreateMarshaler(obj);
        public static ObjectReferenceValue CreateMarshaler2(global::Windows.Storage.Streams.RandomAccessStreamReference obj) => MarshalInterface<global::Windows.Storage.Streams.IRandomAccessStreamReference>.CreateMarshaler2(obj, global::ABI.Windows.Storage.Streams.IRandomAccessStreamReferenceMethods.IID);
        public static IntPtr GetAbi(IObjectReference value) => value is null ? IntPtr.Zero : MarshalInterfaceHelper<object>.GetAbi(value);
        public static global::Windows.Storage.Streams.RandomAccessStreamReference FromAbi(IntPtr thisPtr) => global::Windows.Storage.Streams.RandomAccessStreamReference.FromAbi(thisPtr);
        public static IntPtr FromManaged(global::Windows.Storage.Streams.RandomAccessStreamReference obj) => obj is null ? IntPtr.Zero : CreateMarshaler2(obj).Detach();
        public static unsafe MarshalInterfaceHelper<global::Windows.Storage.Streams.RandomAccessStreamReference>.MarshalerArray CreateMarshalerArray(global::Windows.Storage.Streams.RandomAccessStreamReference[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.RandomAccessStreamReference>.CreateMarshalerArray2(array, (o) => CreateMarshaler2(o));
        public static (int length, IntPtr data) GetAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.RandomAccessStreamReference>.GetAbiArray(box);
        public static unsafe global::Windows.Storage.Streams.RandomAccessStreamReference[] FromAbiArray(object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.RandomAccessStreamReference>.FromAbiArray(box, FromAbi);
        public static void CopyAbiArray(global::Windows.Storage.Streams.RandomAccessStreamReference[] array, object box) => MarshalInterfaceHelper<global::Windows.Storage.Streams.RandomAccessStreamReference>.CopyAbiArray(array, box, FromAbi);
        public static (int length, IntPtr data) FromManagedArray(global::Windows.Storage.Streams.RandomAccessStreamReference[] array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.RandomAccessStreamReference>.FromManagedArray(array, (o) => FromManaged(o));
        public static void DisposeMarshaler(IObjectReference value) => MarshalInspectable<object>.DisposeMarshaler(value);
        public static void DisposeMarshalerArray(MarshalInterfaceHelper<global::Windows.Storage.Streams.RandomAccessStreamReference>.MarshalerArray array) => MarshalInterfaceHelper<global::Windows.Storage.Streams.RandomAccessStreamReference>.DisposeMarshalerArray(array);
        public static void DisposeAbi(IntPtr abi) => MarshalInspectable<object>.DisposeAbi(abi);
        public static unsafe void DisposeAbiArray(object box) => MarshalInspectable<object>.DisposeAbiArray(box);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    internal sealed class RandomAccessStreamReferenceRcwFactoryAttribute : global::WinRT.WinRTImplementationTypeRcwFactoryAttribute
    {
        public override object CreateInstance(global::WinRT.IInspectable inspectable)
            => new global::Windows.Storage.Streams.RandomAccessStreamReference(inspectable.ObjRef);
    }
}
#pragma warning restore CA1416

namespace Windows.Storage.Streams
{
    using global::System;

    [global::WinRT.WindowsRuntimeType("Windows.Foundation.UniversalApiContract")]
    [Guid("905a0fef-bc53-11df-8c49-001e4fc686da")]
    [global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Windows.Storage.Streams.IBufferByteAccess))]
    internal interface IBufferByteAccess
    {
        IntPtr Buffer { get; }
    }
}

namespace ABI.Windows.Storage.Streams
{
    using global::System;
    using global::System.Runtime.CompilerServices;
    using global::System.Runtime.InteropServices;
    using global::System.ComponentModel;

#if !NET
    [global::WinRT.ObjectReferenceWrapper(nameof(_obj)), EditorBrowsable(EditorBrowsableState.Never)]
    [Guid("905a0fef-bc53-11df-8c49-001e4fc686da")]
    internal unsafe class IBufferByteAccess : global::Windows.Storage.Streams.IBufferByteAccess
    {
        [Guid("905a0fef-bc53-11df-8c49-001e4fc686da")]
        public struct Vftbl
        {
            internal global::WinRT.Interop.IUnknownVftbl IUnknownVftbl;
            private void* _get_Buffer_0;
            public delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int> get_Buffer_0 { get => (delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>)_get_Buffer_0; set => _get_Buffer_0 = value; }

            public unsafe delegate int _get_Buffer_0_delegate(IntPtr thisPtr, IntPtr* result);
            private static readonly _get_Buffer_0_delegate DelegateCache;

            static unsafe Vftbl()
            {
                AbiToProjectionVftable = new Vftbl
                {
                    IUnknownVftbl = global::WinRT.Interop.IUnknownVftbl.AbiToProjectionVftbl,
                    _get_Buffer_0 = Marshal.GetFunctionPointerForDelegate(DelegateCache = Do_Abi_get_Buffer_0).ToPointer()
                };
                var nativeVftbl = (IntPtr*)ComWrappersSupport.AllocateVtableMemory(typeof(Vftbl), Marshal.SizeOf<global::WinRT.IInspectable.Vftbl>() + sizeof(IntPtr) * 1);
                Marshal.StructureToPtr(AbiToProjectionVftable, (IntPtr)nativeVftbl, false);
                AbiToProjectionVftablePtr = (IntPtr)nativeVftbl;
            }

            public static readonly Vftbl AbiToProjectionVftable;
            public static readonly IntPtr AbiToProjectionVftablePtr;

            private static int Do_Abi_get_Buffer_0(IntPtr thisPtr, IntPtr* buffer)
            {
                *buffer = default;
                try
                {
                    *buffer = ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IBufferByteAccess>(thisPtr).Buffer;
                }
                catch (Exception ex)
                {
                    return Marshal.GetHRForException(ex);
                }
                return 0;
            }
        }
        internal static ObjectReference<Vftbl> FromAbi(IntPtr thisPtr) => ObjectReference<Vftbl>.FromAbi(thisPtr);

        public static implicit operator IBufferByteAccess(IObjectReference obj) => (obj != null) ? new IBufferByteAccess(obj) : null;
        protected readonly ObjectReference<Vftbl> _obj;
        public IObjectReference ObjRef { get => _obj; }
        public IntPtr ThisPtr => _obj.ThisPtr;
        public ObjectReference<I> AsInterface<I>() => _obj.As<I>();
        public A As<A>() => _obj.AsType<A>();
        public IBufferByteAccess(IObjectReference obj) : this(obj.As<Vftbl>()) { }
        internal IBufferByteAccess(ObjectReference<Vftbl> obj)
        {
            _obj = obj;
        }

        public IntPtr Buffer
        {
            get
            {
                IntPtr __retval = default;
                Marshal.ThrowExceptionForHR(_obj.Vftbl.get_Buffer_0(ThisPtr, &__retval));
                GC.KeepAlive(_obj);
                return __retval;
            }
        }
    }
#else
    [DynamicInterfaceCastableImplementation]
    [Guid("905a0fef-bc53-11df-8c49-001e4fc686da")]
    internal unsafe interface IBufferByteAccess : global::Windows.Storage.Streams.IBufferByteAccess
    {
        [Guid("905a0fef-bc53-11df-8c49-001e4fc686da")]
        public struct Vftbl
        {
            internal global::WinRT.Interop.IUnknownVftbl IUnknownVftbl;
            public delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int> Get_Buffer_0;

            public static readonly IntPtr AbiToProjectionVftablePtr;

            static unsafe Vftbl()
            {
                AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(Vftbl), sizeof(global::WinRT.Interop.IUnknownVftbl) + sizeof(IntPtr));
                (*(Vftbl*)AbiToProjectionVftablePtr) = new Vftbl
                {
                    IUnknownVftbl = global::WinRT.Interop.IUnknownVftbl.AbiToProjectionVftbl,
                    Get_Buffer_0 = &Do_Abi_get_Buffer_0,
                };
            }

            [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
            private static int Do_Abi_get_Buffer_0(IntPtr thisPtr, IntPtr* buffer)
            {
                *buffer = default;
                try
                {
                    *buffer = ComWrappersSupport.FindObject<global::Windows.Storage.Streams.IBufferByteAccess>(thisPtr).Buffer;
                }
                catch (Exception ex)
                {
                    return Marshal.GetHRForException(ex);
                }
                return 0;
            }
        }
        internal static ObjectReference<global::WinRT.Interop.IUnknownVftbl> FromAbi(IntPtr thisPtr) => ObjectReference<global::WinRT.Interop.IUnknownVftbl>.FromAbi(thisPtr, global::WinRT.Interop.IID.IID_IBufferByteAccess);

        IntPtr global::Windows.Storage.Streams.IBufferByteAccess.Buffer
        {
            get
            {
                var _obj = ((IWinRTObject)this).GetObjectReferenceForType(typeof(global::Windows.Storage.Streams.IBufferByteAccess).TypeHandle);
                var ThisPtr = _obj.ThisPtr;
                IntPtr buffer = default;
                Marshal.ThrowExceptionForHR(((delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>)(*(void***)ThisPtr)[3])(ThisPtr, &buffer));
                GC.KeepAlive(_obj);
                return buffer;
            }
        }
    }
#endif
}

namespace Com
{
    using global::System;

    internal enum MSHCTX : int { Local = 0, NoSharedMem = 1, DifferentMachine = 2, InProc = 3, CrossCtx = 4 }
    internal enum MSHLFLAGS : int { Normal = 0, TableStrong = 1, TableWeak = 2, NoPing = 4 }

    [global::WinRT.WindowsRuntimeType("Windows.Foundation.UniversalApiContract")]
    [Guid("00000003-0000-0000-c000-000000000046")]
    [global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Com.IMarshal))]
    internal interface IMarshal
    {
        unsafe void GetUnmarshalClass(Guid* riid, IntPtr pv, MSHCTX dwDestContext, IntPtr pvDestContext, MSHLFLAGS mshlFlags, Guid* pCid);

        unsafe void GetMarshalSizeMax(Guid* riid, IntPtr pv, MSHCTX dwDestContext, IntPtr pvDestContext, MSHLFLAGS mshlflags, uint* pSize);

        unsafe void MarshalInterface(IntPtr pStm, Guid* riid, IntPtr pv, MSHCTX dwDestContext, IntPtr pvDestContext, MSHLFLAGS mshlflags);

        unsafe void UnmarshalInterface(IntPtr pStm, Guid* riid, IntPtr* ppv);

        void ReleaseMarshalData(IntPtr pStm);

        void DisconnectObject(uint dwReserved);
    }
}

namespace ABI.Com
{
    using global::System;
    using global::System.ComponentModel;
    using global::System.Diagnostics.CodeAnalysis;
    using global::System.Runtime.CompilerServices;
    using global::System.Runtime.InteropServices;

    [Guid("00000003-0000-0000-c000-000000000046")]
    internal sealed class IMarshal : global::Com.IMarshal
    {
        [Guid("00000003-0000-0000-c000-000000000046")]
        public unsafe struct Vftbl
        {
            internal global::WinRT.Interop.IUnknownVftbl IUnknownVftbl;

#if !NET
            private void* _GetUnmarshalClass_0;
            public delegate* unmanaged[Stdcall]<IntPtr, Guid*, IntPtr, global::Com.MSHCTX, IntPtr, global::Com.MSHLFLAGS, Guid*, int> GetUnmarshalClass_0 { get => (delegate* unmanaged[Stdcall]<IntPtr, Guid*, IntPtr, global::Com.MSHCTX, IntPtr, global::Com.MSHLFLAGS, Guid*, int>)_GetUnmarshalClass_0; set => _GetUnmarshalClass_0 = value; }
            private void* _GetMarshalSizeMax_1;
            public delegate* unmanaged[Stdcall]<IntPtr, Guid*, IntPtr, global::Com.MSHCTX, IntPtr, global::Com.MSHLFLAGS, uint*, int> GetMarshalSizeMax_1 { get => (delegate* unmanaged[Stdcall]<IntPtr, Guid*, IntPtr, global::Com.MSHCTX, IntPtr, global::Com.MSHLFLAGS, uint*, int>)_GetMarshalSizeMax_1; set => _GetMarshalSizeMax_1 = value; }
            private void* _MarshalInterface_2;
            public delegate* unmanaged[Stdcall]<IntPtr, IntPtr, Guid*, IntPtr, global::Com.MSHCTX, IntPtr, global::Com.MSHLFLAGS, int> MarshalInterface_2 { get => (delegate* unmanaged[Stdcall]<IntPtr, IntPtr, Guid*, IntPtr, global::Com.MSHCTX, IntPtr, global::Com.MSHLFLAGS, int>)_MarshalInterface_2; set => _MarshalInterface_2 = value; }
            private void* _UnmarshalInterface_3;
            public delegate* unmanaged[Stdcall]<IntPtr, IntPtr, Guid*, IntPtr*, int> UnmarshalInterface_3 { get => (delegate* unmanaged[Stdcall]<IntPtr, IntPtr, Guid*, IntPtr*, int>)_UnmarshalInterface_3; set => _UnmarshalInterface_3 = value; }
            private void* _ReleaseMarshalData_4;
            public delegate* unmanaged[Stdcall]<IntPtr, IntPtr, int> ReleaseMarshalData_4 { get => (delegate* unmanaged[Stdcall]<IntPtr, IntPtr, int>)_ReleaseMarshalData_4; set => _ReleaseMarshalData_4 = value; }
            private void* _DisconnectObject_5;
            public delegate* unmanaged[Stdcall]<IntPtr, uint, int> DisconnectObject_5 { get => (delegate* unmanaged[Stdcall]<IntPtr, uint, int>)_DisconnectObject_5; set => _DisconnectObject_5 = value; }

            private static readonly Delegate[] DelegateCache = new Delegate[6];
            public static readonly Vftbl AbiToProjectionVftable;
#else
            public delegate* unmanaged[Stdcall]<IntPtr, Guid*, IntPtr, global::Com.MSHCTX, IntPtr, global::Com.MSHLFLAGS, Guid*, int> GetUnmarshalClass_0;
            public delegate* unmanaged[Stdcall]<IntPtr, Guid*, IntPtr, global::Com.MSHCTX, IntPtr, global::Com.MSHLFLAGS, uint*, int> GetMarshalSizeMax_1;
            public delegate* unmanaged[Stdcall]<IntPtr, IntPtr, Guid*, IntPtr, global::Com.MSHCTX, IntPtr, global::Com.MSHLFLAGS, int> MarshalInterface_2;
            public delegate* unmanaged[Stdcall]<IntPtr, IntPtr, Guid*, IntPtr*, int> UnmarshalInterface_3;
            public delegate* unmanaged[Stdcall]<IntPtr, IntPtr, int> ReleaseMarshalData_4;
            public delegate* unmanaged[Stdcall]<IntPtr, uint, int> DisconnectObject_5;
#endif

            public static readonly IntPtr AbiToProjectionVftablePtr;

            static Vftbl()
            {
    #if !NET
                    AbiToProjectionVftable = new Vftbl
                    {
                        IUnknownVftbl = global::WinRT.Interop.IUnknownVftbl.AbiToProjectionVftbl,
                        _GetUnmarshalClass_0 = Marshal.GetFunctionPointerForDelegate(DelegateCache[0] = new IMarshal_Delegates.GetUnmarshalClass_0(Do_Abi_GetUnmarshalClass_0)).ToPointer(),
                        _GetMarshalSizeMax_1 = Marshal.GetFunctionPointerForDelegate(DelegateCache[1] = new IMarshal_Delegates.GetMarshalSizeMax_1(Do_Abi_GetMarshalSizeMax_1)).ToPointer(),
                        _MarshalInterface_2 = Marshal.GetFunctionPointerForDelegate(DelegateCache[2] = new IMarshal_Delegates.MarshalInterface_2(Do_Abi_MarshalInterface_2)).ToPointer(),
                        _UnmarshalInterface_3 = Marshal.GetFunctionPointerForDelegate(DelegateCache[3] = new IMarshal_Delegates.UnmarshalInterface_3(Do_Abi_UnmarshalInterface_3)).ToPointer(),
                        _ReleaseMarshalData_4 = Marshal.GetFunctionPointerForDelegate(DelegateCache[4] = new IMarshal_Delegates.ReleaseMarshalData_4(Do_Abi_ReleaseMarshalData_4)).ToPointer(),
                        _DisconnectObject_5 = Marshal.GetFunctionPointerForDelegate(DelegateCache[5] = new IMarshal_Delegates.DisconnectObject_5(Do_Abi_DisconnectObject_5)).ToPointer(),
                    };
                    AbiToProjectionVftablePtr = Marshal.AllocHGlobal(Marshal.SizeOf<Vftbl>());
                    Marshal.StructureToPtr(AbiToProjectionVftable, AbiToProjectionVftablePtr, false);
    #else
                    AbiToProjectionVftablePtr = ComWrappersSupport.AllocateVtableMemory(typeof(Vftbl), sizeof(global::WinRT.Interop.IUnknownVftbl) + sizeof(IntPtr) * 6);
                    (*(Vftbl*)AbiToProjectionVftablePtr) = new Vftbl
                    {
                        IUnknownVftbl = global::WinRT.Interop.IUnknownVftbl.AbiToProjectionVftbl,
                        GetUnmarshalClass_0 = &Do_Abi_GetUnmarshalClass_0,
                        GetMarshalSizeMax_1 = &Do_Abi_GetMarshalSizeMax_1,
                        MarshalInterface_2 = &Do_Abi_MarshalInterface_2,
                        UnmarshalInterface_3 = &Do_Abi_UnmarshalInterface_3,
                        ReleaseMarshalData_4 = &Do_Abi_ReleaseMarshalData_4,
                        DisconnectObject_5 = &Do_Abi_DisconnectObject_5
                    };
    #endif
                }

#if NET
            [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
#endif
            private static int Do_Abi_GetUnmarshalClass_0(IntPtr thisPtr, Guid* riid, IntPtr pv, global::Com.MSHCTX dwDestContext, IntPtr pvDestContext, global::Com.MSHLFLAGS mshlFlags, Guid* pCid)
            {
                *pCid = default;
                try
                {
                    ComWrappersSupport.FindObject<global::Com.IMarshal>(thisPtr).GetUnmarshalClass(riid, pv, dwDestContext, pvDestContext, mshlFlags, pCid);
                }
                catch (Exception ex)
                {
                    return Marshal.GetHRForException(ex);
                }
                return 0;
            }

#if NET
            [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
#endif
            private static int Do_Abi_GetMarshalSizeMax_1(IntPtr thisPtr, Guid* riid, IntPtr pv, global::Com.MSHCTX dwDestContext, IntPtr pvDestContext, global::Com.MSHLFLAGS mshlflags, uint* pSize)
            {
                *pSize = default;
                try
                {
                    ComWrappersSupport.FindObject<global::Com.IMarshal>(thisPtr).GetMarshalSizeMax(riid, pv, dwDestContext, pvDestContext, mshlflags, pSize);
                }
                catch (Exception ex)
                {
                    return Marshal.GetHRForException(ex);
                }
                return 0;
            }

#if NET
            [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
#endif
            private static int Do_Abi_MarshalInterface_2(IntPtr thisPtr, IntPtr pStm, Guid* riid, IntPtr pv, global::Com.MSHCTX dwDestContext, IntPtr pvDestContext, global::Com.MSHLFLAGS mshlflags)
            {
                try
                {
                    ComWrappersSupport.FindObject<global::Com.IMarshal>(thisPtr).MarshalInterface(pStm, riid, pv, dwDestContext, pvDestContext, mshlflags);
                }
                catch (Exception ex)
                {
                    return Marshal.GetHRForException(ex);
                }
                return 0;
            }

#if NET
            [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
#endif
            private static int Do_Abi_UnmarshalInterface_3(IntPtr thisPtr, IntPtr pStm, Guid* riid, IntPtr* ppv)
            {
                *ppv = default;
                try
                {
                    ComWrappersSupport.FindObject<global::Com.IMarshal>(thisPtr).UnmarshalInterface(pStm, riid, ppv);
                }
                catch (Exception ex)
                {
                    return Marshal.GetHRForException(ex);
                }
                return 0;
            }

#if NET
            [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
#endif
            private static int Do_Abi_ReleaseMarshalData_4(IntPtr thisPtr, IntPtr pStm)
            {
                try
                {
                    ComWrappersSupport.FindObject<global::Com.IMarshal>(thisPtr).ReleaseMarshalData(pStm);
                }
                catch (Exception ex)
                {
                    return Marshal.GetHRForException(ex);
                }
                return 0;
            }

#if NET
            [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
#endif
            private static int Do_Abi_DisconnectObject_5(IntPtr thisPtr, uint dwReserved)
            {
                try
                {
                    ComWrappersSupport.FindObject<global::Com.IMarshal>(thisPtr).DisconnectObject(dwReserved);
                }
                catch (Exception ex)
                {
                    return Marshal.GetHRForException(ex);
                }
                return 0;
            }
        }
#if NET
        internal static ObjectReference<global::WinRT.Interop.IUnknownVftbl> FromAbi(IntPtr thisPtr) => ObjectReference<global::WinRT.Interop.IUnknownVftbl>.FromAbi(thisPtr, global::WinRT.Interop.IID.IID_IMarshal);
#else
        internal static ObjectReference<Vftbl> FromAbi(IntPtr thisPtr) => ObjectReference<Vftbl>.FromAbi(thisPtr, global::WinRT.Interop.IID.IID_IMarshal);
#endif
#if NET
        private readonly ObjectReference<global::WinRT.Interop.IUnknownVftbl> _obj;
#else
        private readonly ObjectReference<Vftbl> _obj;
#endif
        public IObjectReference ObjRef { get => _obj; }
        public IntPtr ThisPtr => _obj.ThisPtr;

#if NET
        public IMarshal(IObjectReference obj)
        {
            _obj = obj.As<global::WinRT.Interop.IUnknownVftbl>(global::WinRT.Interop.IID.IID_IMarshal);
        }
#else
        public IMarshal(IObjectReference obj) : this(obj.As<Vftbl>()) { }
        internal IMarshal(ObjectReference<Vftbl> obj)
        {
            _obj = obj;
        }
#endif

        public unsafe void GetUnmarshalClass(Guid* riid, IntPtr pv, global::Com.MSHCTX dwDestContext, IntPtr pvDestContext, global::Com.MSHLFLAGS mshlFlags, Guid* pCid)
        {
    #if NET
                IntPtr thisPtr = ThisPtr;
                Marshal.ThrowExceptionForHR(((delegate* unmanaged[Stdcall]<IntPtr, Guid*, IntPtr, global::Com.MSHCTX, IntPtr, global::Com.MSHLFLAGS, Guid*, int>)(*(void***)thisPtr)[3])(thisPtr, riid, pv, dwDestContext, pvDestContext, mshlFlags, pCid));
    #else
                Marshal.ThrowExceptionForHR(_obj.Vftbl.GetUnmarshalClass_0(ThisPtr, riid, pv, dwDestContext, pvDestContext, mshlFlags, pCid));
    #endif
                GC.KeepAlive(_obj);
            }

        public unsafe void GetMarshalSizeMax(Guid* riid, IntPtr pv, global::Com.MSHCTX dwDestContext, IntPtr pvDestContext, global::Com.MSHLFLAGS mshlflags, uint* pSize)
        {
    #if NET
                IntPtr thisPtr = ThisPtr;
                Marshal.ThrowExceptionForHR(((delegate* unmanaged[Stdcall]<IntPtr, Guid*, IntPtr, global::Com.MSHCTX, IntPtr, global::Com.MSHLFLAGS, uint*, int>)(*(void***)thisPtr)[4])(thisPtr, riid, pv, dwDestContext, pvDestContext, mshlflags, pSize));
    #else
                Marshal.ThrowExceptionForHR(_obj.Vftbl.GetMarshalSizeMax_1(ThisPtr, riid, pv, dwDestContext, pvDestContext, mshlflags, pSize));
    #endif
                GC.KeepAlive(_obj);
            }

        public unsafe void MarshalInterface(IntPtr pStm, Guid* riid, IntPtr pv, global::Com.MSHCTX dwDestContext, IntPtr pvDestContext, global::Com.MSHLFLAGS mshlflags)
        {
    #if NET
                IntPtr thisPtr = ThisPtr;
                Marshal.ThrowExceptionForHR(((delegate* unmanaged[Stdcall]<IntPtr, IntPtr, Guid*, IntPtr, global::Com.MSHCTX, IntPtr, global::Com.MSHLFLAGS, int>)(*(void***)thisPtr)[5])(thisPtr, pStm, riid, pv, dwDestContext, pvDestContext, mshlflags));
    #else
                Marshal.ThrowExceptionForHR(_obj.Vftbl.MarshalInterface_2(ThisPtr, pStm, riid, pv, dwDestContext, pvDestContext, mshlflags));
    #endif
                GC.KeepAlive(_obj);
            }

        public unsafe void UnmarshalInterface(IntPtr pStm, Guid* riid, IntPtr* ppv)
        {
    #if NET
                IntPtr thisPtr = ThisPtr;
                Marshal.ThrowExceptionForHR(((delegate* unmanaged[Stdcall]<IntPtr, IntPtr, Guid*, IntPtr*, int>)(*(void***)thisPtr)[6])(thisPtr, pStm, riid, ppv));
    #else
                Marshal.ThrowExceptionForHR(_obj.Vftbl.UnmarshalInterface_3(ThisPtr, pStm, riid, ppv));
    #endif
                GC.KeepAlive(_obj);
            }

        public unsafe void ReleaseMarshalData(IntPtr pStm)
        {
    #if NET
                IntPtr thisPtr = ThisPtr;
                Marshal.ThrowExceptionForHR(((delegate* unmanaged[Stdcall]<IntPtr, IntPtr, int>)(*(void***)thisPtr)[7])(thisPtr, pStm));
    #else
                Marshal.ThrowExceptionForHR(_obj.Vftbl.ReleaseMarshalData_4(ThisPtr, pStm));
    #endif
                GC.KeepAlive(_obj);
            }

        public unsafe void DisconnectObject(uint dwReserved)
        {
    #if NET
                IntPtr thisPtr = ThisPtr;
                Marshal.ThrowExceptionForHR(((delegate* unmanaged[Stdcall]<IntPtr, uint, int>)(*(void***)thisPtr)[8])(thisPtr, dwReserved));
    #else
                Marshal.ThrowExceptionForHR(_obj.Vftbl.DisconnectObject_5(ThisPtr, dwReserved));
    #endif
                GC.KeepAlive(_obj);
            }
    }

#if !NET
    internal static unsafe class IMarshal_Delegates
    {
        public delegate int GetUnmarshalClass_0(IntPtr thisPtr, Guid* riid, IntPtr pv, global::Com.MSHCTX dwDestContext, IntPtr pvDestContext, global::Com.MSHLFLAGS mshlFlags, Guid* pCid);
        public delegate int GetMarshalSizeMax_1(IntPtr thisPtr, Guid* riid, IntPtr pv, global::Com.MSHCTX dwDestContext, IntPtr pvDestContext, global::Com.MSHLFLAGS mshlflags, uint* pSize);
        public delegate int MarshalInterface_2(IntPtr thisPtr, IntPtr pStm, Guid* riid, IntPtr pv, global::Com.MSHCTX dwDestContext, IntPtr pvDestContext, global::Com.MSHLFLAGS mshlflags);
        public delegate int UnmarshalInterface_3(IntPtr thisPtr, IntPtr pStm, Guid* riid, IntPtr* ppv);
        public delegate int ReleaseMarshalData_4(IntPtr thisPtr, IntPtr pStm);
        public delegate int DisconnectObject_5(IntPtr thisPtr, uint dwReserved);
    }
#endif
}

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.


namespace System.IO
{
    using System.Diagnostics;
    using System.IO;
    
    using System.Runtime.InteropServices;
    using System.Threading.Tasks;
    using System.Threading;
    using global::Windows.Foundation;
    using global::Windows.Storage.Streams;
    using System.Diagnostics.CodeAnalysis;
    /// <summary>
    /// An <code>wrapper</code> for a managed stream that implements all WinRT stream operations.
    /// This class must not implement any WinRT stream interfaces directly.
    /// We never create instances of this class directly; instead we use classes defined in
    /// the region Interface adapters to implement WinRT ifaces and create instances of those types.
    /// See comment in that region for technical details.
    /// </summary>
    internal abstract partial class NetFxToWinRtStreamAdapter : IDisposable
    {
        private const int E_ILLEGAL_METHOD_CALL = unchecked((int)0x8000000E);
        private const int RO_E_CLOSED = unchecked((int)0x80000013);
        private const int E_NOTIMPL = unchecked((int)0x80004001);
        private const int E_INVALIDARG = unchecked((int)0x80070057);
        #region Construction

        #region Interface adapters

        // Instances of private types defined in this section will be returned from NetFxToWinRtStreamAdapter.Create(..).
        // Depending on the capabilities of the .NET stream for which we need to construct the adapter, we need to return
        // an object that can be QIed (COM speak for "cast") to a well-defined set of ifaces.
        // E.g, if the specified stream CanRead, but not CanSeek and not CanWrite, then we *must* return an object that
        // can be QIed to IInputStream, but *not* IRandomAccessStream and *not* IOutputStream.
        // There are two ways to do that:
        //   - We could explicitly implement ICustomQueryInterface and respond to QI requests by analyzing the stream capabilities
        //   - We can use the runtime's ability to do that for us, based on the ifaces the concrete class implements (or does not).
        // The latter is much more elegant, and likely also faster.


        private sealed partial class InputStream : NetFxToWinRtStreamAdapter, IInputStream, IDisposable
        {
            internal InputStream(Stream stream, StreamReadOperationOptimization readOptimization)
                : base(stream, readOptimization)
            {
            }
        }


        private sealed partial class OutputStream : NetFxToWinRtStreamAdapter, IOutputStream, IDisposable
        {
            internal OutputStream(Stream stream, StreamReadOperationOptimization readOptimization)
                : base(stream, readOptimization)
            {
            }
        }


        private sealed partial class RandomAccessStream : NetFxToWinRtStreamAdapter, IRandomAccessStream, IInputStream, IOutputStream, IDisposable
        {
            internal RandomAccessStream(Stream stream, StreamReadOperationOptimization readOptimization)
                : base(stream, readOptimization)
            {
            }
        }


        private sealed partial class InputOutputStream : NetFxToWinRtStreamAdapter, IInputStream, IOutputStream, IDisposable
        {
            internal InputOutputStream(Stream stream, StreamReadOperationOptimization readOptimization)
                : base(stream, readOptimization)
            {
            }
        }

        #endregion Interface adapters

        // We may want to define different behaviour for different types of streams.
        // For instance, ReadAsync treats MemoryStream special for performance reasons.
        // The enum 'StreamReadOperationOptimization' describes the read optimization to employ for a
        // given NetFxToWinRtStreamAdapter instance. In future, we might define other enums to follow a
        // similar pattern, e.g. 'StreamWriteOperationOptimization' or 'StreamFlushOperationOptimization'.
        private enum StreamReadOperationOptimization
        {
            AbstractStream = 0, MemoryStream
        }


        internal static NetFxToWinRtStreamAdapter Create(Stream stream)
        {
            if (stream == null)
                throw new ArgumentNullException(nameof(stream));

            StreamReadOperationOptimization readOptimization = StreamReadOperationOptimization.AbstractStream;
            if (stream.CanRead)
                readOptimization = DetermineStreamReadOptimization(stream);

            NetFxToWinRtStreamAdapter adapter;

            if (stream.CanSeek)
                adapter = new RandomAccessStream(stream, readOptimization);

            else if (stream.CanRead && stream.CanWrite)
                adapter = new InputOutputStream(stream, readOptimization);

            else if (stream.CanRead)
                adapter = new InputStream(stream, readOptimization);

            else if (stream.CanWrite)
                adapter = new OutputStream(stream, readOptimization);

            else
                throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_NotSufficientCapabilitiesToConvertToWinRtStream);

            return adapter;
        }


        private static StreamReadOperationOptimization DetermineStreamReadOptimization(Stream stream)
        {
            Debug.Assert(stream != null);

            if (CanApplyReadMemoryStreamOptimization(stream))
                return StreamReadOperationOptimization.MemoryStream;

            return StreamReadOperationOptimization.AbstractStream;
        }


        private static bool CanApplyReadMemoryStreamOptimization(Stream stream)
        {
            MemoryStream memStream = stream as MemoryStream;
            if (memStream == null)
                return false;

            ArraySegment<byte> arrSeg;
            return memStream.TryGetBuffer(out arrSeg);
        }


        private NetFxToWinRtStreamAdapter(Stream stream, StreamReadOperationOptimization readOptimization)
        {
            Debug.Assert(stream != null);
            Debug.Assert(stream.CanRead || stream.CanWrite || stream.CanSeek);
            Debug.Assert(!stream.CanRead || (stream.CanRead && this is IInputStream));
            Debug.Assert(!stream.CanWrite || (stream.CanWrite && this is IOutputStream));
            Debug.Assert(!stream.CanSeek || (stream.CanSeek && this is IRandomAccessStream));

            _readOptimization = readOptimization;
            _managedStream = stream;
        }

        #endregion Construction


        #region Instance variables

        private Stream _managedStream = null;
        private bool _leaveUnderlyingStreamOpen = true;
        private readonly StreamReadOperationOptimization _readOptimization;

        #endregion Instance variables


        #region Tools and Helpers

        /// <summary>
        /// We keep tables for mappings between managed and WinRT streams to make sure to always return the same adapter for a given underlying stream.
        /// However, in order to avoid global locks on those tables, several instances of this type may be created and then can race to be entered
        /// into the appropriate map table. All except for the winning instances will be thrown away. However, we must ensure that when the losers are
        /// finalized, they do not dispose the underlying stream. To ensure that, we must call this method on the winner to notify it that it is safe to
        /// dispose the underlying stream.
        /// </summary>
        internal void SetWonInitializationRace()
        {
            _leaveUnderlyingStreamOpen = false;
        }


        public Stream GetManagedStream()
        {
            return _managedStream;
        }


        private Stream EnsureNotDisposed()
        {
            Stream str = _managedStream;

            if (str == null)
            {
                ObjectDisposedException ex = new ObjectDisposedException(global::Windows.Storage.Streams.SR.ObjectDisposed_CannotPerformOperation);
                ex.SetHResult(RO_E_CLOSED);
                throw ex;
            }

            return str;
        }

        #endregion Tools and Helpers


        #region Common public interface

        /// <summary>Implements IDisposable.Dispose (IClosable.Close in WinRT)</summary>
        void IDisposable.Dispose()
        {
            Stream str = _managedStream;
            if (str == null)
                return;

            _managedStream = null;

            if (!_leaveUnderlyingStreamOpen)
                str.Dispose();
        }

        #endregion Common public interface


        #region IInputStream public interface

#if NET
        [global::System.Runtime.Versioning.SupportedOSPlatform("windows10.0.10240.0")]
#endif
        public IAsyncOperationWithProgress<IBuffer, uint> ReadAsync(IBuffer buffer, uint count, InputStreamOptions options)
        {
            if (buffer == null)
            {
                // Mapped to E_POINTER.
                throw new ArgumentNullException(nameof(buffer));
            }

            if (count < 0 || int.MaxValue < count)
            {
                ArgumentOutOfRangeException ex = new ArgumentOutOfRangeException(nameof(count));
                ex.SetHResult(E_INVALIDARG);
                throw ex;
            }

            if (buffer.Capacity < count)
            {
                ArgumentException ex = new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InsufficientBufferCapacity);
                ex.SetHResult(E_INVALIDARG);
                throw ex;
            }

            if (!(options == InputStreamOptions.None || options == InputStreamOptions.Partial || options == InputStreamOptions.ReadAhead))
            {
                ArgumentOutOfRangeException ex = new ArgumentOutOfRangeException(nameof(options),
                                                                                 global::Windows.Storage.Streams.SR.ArgumentOutOfRange_InvalidInputStreamOptionsEnumValue);
                ex.SetHResult(E_INVALIDARG);
                throw ex;
            }

            Stream str = EnsureNotDisposed();

            IAsyncOperationWithProgress<IBuffer, uint> readAsyncOperation;
            switch (_readOptimization)
            {
                case StreamReadOperationOptimization.MemoryStream:
                    readAsyncOperation = StreamOperationsImplementation.ReadAsync_MemoryStream(str, buffer, count);
                    break;

                case StreamReadOperationOptimization.AbstractStream:
                    readAsyncOperation = StreamOperationsImplementation.ReadAsync_AbstractStream(str, buffer, count, options);
                    break;

                // Use this pattern to add more optimisation options if necessary:
                //case StreamReadOperationOptimization.XxxxStream:
                //    readAsyncOperation = StreamOperationsImplementation.ReadAsync_XxxxStream(str, buffer, count, options);
                //    break;

                default:
                    Debug.Fail("We should never get here. Someone forgot to handle an input stream optimisation option.");
                    readAsyncOperation = null;
                    break;
            }

            return readAsyncOperation;
        }

        #endregion IInputStream public interface


        #region IOutputStream public interface

#if NET
        [global::System.Runtime.Versioning.SupportedOSPlatform("windows10.0.10240.0")]
#endif
        public IAsyncOperationWithProgress<uint, uint> WriteAsync(IBuffer buffer)
        {
            if (buffer == null)
            {
                // Mapped to E_POINTER.
                throw new ArgumentNullException(nameof(buffer));
            }

            if (buffer.Capacity < buffer.Length)
            {
                ArgumentException ex = new ArgumentException(global::Windows.Storage.Streams.SR.Argument_BufferLengthExceedsCapacity);
                ex.SetHResult(E_INVALIDARG);
                throw ex;
            }

            Stream str = EnsureNotDisposed();
            return StreamOperationsImplementation.WriteAsync_AbstractStream(str, buffer);
        }

#if NET
        [global::System.Runtime.Versioning.SupportedOSPlatform("windows10.0.10240.0")]
#endif
        public IAsyncOperation<bool> FlushAsync()
        {
            Stream str = EnsureNotDisposed();
            return StreamOperationsImplementation.FlushAsync_AbstractStream(str);
        }

        #endregion IOutputStream public interface


        #region IRandomAccessStream public interface


        #region IRandomAccessStream public interface: Not cloning related

        public void Seek(ulong position)
        {
            if (position > long.MaxValue)
            {
                ArgumentException ex = new ArgumentException(global::Windows.Storage.Streams.SR.IO_CannotSeekBeyondInt64MaxValue);
                ex.SetHResult(E_INVALIDARG);
                throw ex;
            }

            Stream str = EnsureNotDisposed();
            long pos = unchecked((long)position);

            Debug.Assert(str != null);
            Debug.Assert(str.CanSeek, "The underlying str is expected to support Seek, but it does not.");
            Debug.Assert(0 <= pos, "Unexpected pos=" + pos + ".");

            str.Seek(pos, SeekOrigin.Begin);
        }


        public bool CanRead
        {
            get
            {
                Stream str = EnsureNotDisposed();
                return str.CanRead;
            }
        }


        public bool CanWrite
        {
            get
            {
                Stream str = EnsureNotDisposed();
                return str.CanWrite;
            }
        }


        public ulong Position
        {
            get
            {
                Stream str = EnsureNotDisposed();
                return (ulong)str.Position;
            }
        }


        public ulong Size
        {
            get
            {
                Stream str = EnsureNotDisposed();
                return (ulong)str.Length;
            }

            set
            {
                if (value > long.MaxValue)
                {
                    ArgumentException ex = new ArgumentException(global::Windows.Storage.Streams.SR.IO_CannotSetSizeBeyondInt64MaxValue);
                    ex.SetHResult(E_INVALIDARG);
                    throw ex;
                }

                Stream str = EnsureNotDisposed();

                if (!str.CanWrite)
                {
                    InvalidOperationException ex = new InvalidOperationException(global::Windows.Storage.Streams.SR.InvalidOperation_CannotSetStreamSizeCannotWrite);
                    ex.SetHResult(E_ILLEGAL_METHOD_CALL);
                    throw ex;
                }

                long val = unchecked((long)value);

                Debug.Assert(str != null);
                Debug.Assert(str.CanSeek, "The underlying str is expected to support Seek, but it does not.");
                Debug.Assert(0 <= val, "Unexpected val=" + val + ".");

                str.SetLength(val);
            }
        }

        #endregion IRandomAccessStream public interface: Not cloning related


        #region IRandomAccessStream public interface: Cloning related

        // We do not want to support the cloning-related operation for now.
        // They appear to mainly target corner-case scenarios in Windows itself,
        // and are (mainly) a historical artefact of abandoned early designs
        // for IRandonAccessStream.
        // Cloning can be added in future, however, it would be quite complex
        // to support it correctly for generic streams.
        private static void ThrowCloningNotSupported(string methodName)
        {
            NotSupportedException nse = new NotSupportedException(string.Format(global::Windows.Storage.Streams.SR.NotSupported_CloningNotSupported, methodName));
            nse.SetHResult(E_NOTIMPL);
            throw nse;
        }


        public IRandomAccessStream CloneStream()
        {
            ThrowCloningNotSupported("CloneStream");
            return null;
        }


        public IInputStream GetInputStreamAt(ulong position)
        {
            ThrowCloningNotSupported("GetInputStreamAt");
            return null;
        }


        public IOutputStream GetOutputStreamAt(ulong position)
        {
            ThrowCloningNotSupported("GetOutputStreamAt");
            return null;
        }
        #endregion IRandomAccessStream public interface: Cloning related

        #endregion IRandomAccessStream public interface

    }  // class NetFxToWinRtStreamAdapter
}  // namespace

// NetFxToWinRtStreamAdapter.cs

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.


namespace System.IO
{
    using System.Diagnostics;
    using System.Runtime.ExceptionServices;
    
    using System.Runtime.InteropServices;
    using System.Threading.Tasks;
    using System.Threading;
    using global::Windows.Foundation;
    using global::Windows.Storage.Streams;
    using System.Diagnostics.CodeAnalysis;
    #region class StreamOperationAsyncResult

    internal abstract partial class StreamOperationAsyncResult : IAsyncResult
    {
        private readonly AsyncCallback _userCompletionCallback = null;
        private readonly object _userAsyncStateInfo = null;

        private IAsyncInfo _asyncStreamOperation = null;

        private volatile bool _completed = false;
        private volatile bool _callbackInvoked = false;
        private volatile ManualResetEvent _waitHandle = null;

        private long _bytesCompleted = 0;

        private ExceptionDispatchInfo _errorInfo = null;

        private readonly bool _processCompletedOperationInCallback;
        private IAsyncInfo _completedOperation = null;


        protected internal StreamOperationAsyncResult(IAsyncInfo asyncStreamOperation,
                                                      AsyncCallback userCompletionCallback, object userAsyncStateInfo,
                                                      bool processCompletedOperationInCallback)
        {
            if (asyncStreamOperation == null)
                throw new ArgumentNullException(nameof(asyncStreamOperation));

            _userCompletionCallback = userCompletionCallback;
            _userAsyncStateInfo = userAsyncStateInfo;

            _asyncStreamOperation = asyncStreamOperation;

            _completed = false;
            _callbackInvoked = false;

            _bytesCompleted = 0;

            _errorInfo = null;

            _processCompletedOperationInCallback = processCompletedOperationInCallback;
        }


        public object AsyncState
        {
            get { return _userAsyncStateInfo; }
        }


        internal bool ProcessCompletedOperationInCallback
        {
            get { return _processCompletedOperationInCallback; }
        }


        public WaitHandle AsyncWaitHandle
        {
            get
            {
                ManualResetEvent wh = _waitHandle;
                if (wh != null)
                    return wh;

                // What if someone calls this public property and decides to wait on it?
                // > Use 'completed' in the ctor - this way the handle wait will return as appropriate.
                wh = new ManualResetEvent(_completed);

                ManualResetEvent otherHandle = Interlocked.CompareExchange(ref _waitHandle, wh, null);

                // We lost the race. Dispose OUR handle and return OTHER handle:
                if (otherHandle != null)
                {
                    wh.Dispose();
                    return otherHandle;
                }

                // We won the race. Return OUR new handle:
                return wh;
            }
        }

        public bool CompletedSynchronously
        {
            get { return false; }
        }


        public bool IsCompleted
        {
            get { return _completed; }
        }


        internal void Wait()
        {
            if (_completed)
                return;

            WaitHandle wh = AsyncWaitHandle;

            while (_completed == false)
                wh.WaitOne();
        }


        internal long BytesCompleted
        {
            get { return _bytesCompleted; }
        }


        internal bool HasError
        {
            get { return _errorInfo != null; }
        }


        internal void ThrowCachedError()
        {
            if (_errorInfo == null)
                return;

            _errorInfo.Throw();
        }


        internal bool CancelStreamOperation()
        {
            if (_callbackInvoked)
                return false;

            if (_asyncStreamOperation != null)
            {
                _asyncStreamOperation.Cancel();
                _asyncStreamOperation = null;
            }

            return true;
        }

        internal void CloseStreamOperation()
        {
            try
            {
                if (_asyncStreamOperation != null)
                    _asyncStreamOperation.Close();
            }
            catch { }
            _asyncStreamOperation = null;
        }


        ~StreamOperationAsyncResult()
        {
            // This finalisation is not critical, but we can still make an effort to notify the underlying WinRT stream
            // that we are not any longer interested in the results:
            CancelStreamOperation();
        }


        internal abstract void ProcessConcreteCompletedOperation(IAsyncInfo completedOperation, out long bytesCompleted);

         private static void ProcessCompletedOperation_InvalidOperationThrowHelper(ExceptionDispatchInfo errInfo, string errMsg)
        {
            Exception errInfosrc = (errInfo == null) ? null : errInfo.SourceException;

            if (errInfosrc == null)
                throw new InvalidOperationException(errMsg);
            else
                throw new InvalidOperationException(errMsg, errInfosrc);
        }


        internal void ProcessCompletedOperation()
        {
            // The error handling is slightly tricky here:
            // Before processing the IO results, we are verifying some basic assumptions and if they do not hold, we are
            // throwing InvalidOperation. However, by the time this method is called, we might have already stored something
            // into errorInfo, e.g. if an error occurred in StreamOperationCompletedCallback. If that is the case, then that
            // previous exception might include some important info relevant for detecting the problem. So, we take that
            // previous exception and attach it as the inner exception to the InvalidOperationException being thrown.
            // In cases where we have a good understanding of the previously saved errorInfo, and we know for sure that it
            // the immediate reason for the state validation to fail, we can avoid throwing InvalidOperation altogether
            // and only rethrow the errorInfo.

            if (!_callbackInvoked)
                ProcessCompletedOperation_InvalidOperationThrowHelper(_errorInfo, global::Windows.Storage.Streams.SR.InvalidOperation_CannotCallThisMethodInCurrentState);

            if (!_processCompletedOperationInCallback && !_completed)
                ProcessCompletedOperation_InvalidOperationThrowHelper(_errorInfo, global::Windows.Storage.Streams.SR.InvalidOperation_CannotCallThisMethodInCurrentState);

            if (_completedOperation == null)
            {
                ExceptionDispatchInfo errInfo = _errorInfo;
                Exception errInfosrc = (errInfo == null) ? null : errInfo.SourceException;

                // See if errorInfo is set because we observed completedOperation == null previously (being slow is Ok on error path):
                if (errInfosrc != null && errInfosrc is NullReferenceException
                        && global::Windows.Storage.Streams.SR.NullReference_IOCompletionCallbackCannotProcessNullAsyncInfo.Equals(errInfosrc.Message))
                {
                    errInfo!.Throw();
                }
                else
                {
                    throw new InvalidOperationException(global::Windows.Storage.Streams.SR.InvalidOperation_CannotCallThisMethodInCurrentState);
                }
            }

            if (_completedOperation.Id != _asyncStreamOperation!.Id)
                ProcessCompletedOperation_InvalidOperationThrowHelper(_errorInfo, global::Windows.Storage.Streams.SR.InvalidOperation_UnexpectedAsyncOperationID);

            if (_completedOperation.Status == AsyncStatus.Error)
            {
                _bytesCompleted = 0;
                ThrowWithIOExceptionDispatchInfo(_completedOperation.ErrorCode);
            }

            ProcessConcreteCompletedOperation(_completedOperation, out _bytesCompleted);
        }


        internal void StreamOperationCompletedCallback(IAsyncInfo completedOperation, AsyncStatus unusedCompletionStatus)
        {
            try
            {
                if (_callbackInvoked)
                    throw new InvalidOperationException(global::Windows.Storage.Streams.SR.InvalidOperation_MultipleIOCompletionCallbackInvocation);

                _callbackInvoked = true;

                // This happens in rare stress cases in Console mode and the WinRT folks said they are unlikely to fix this in Dev11.
                // Moreover, this can happen if the underlying WinRT stream has a faulty user implementation.
                // If we did not do this check, we would either get the same exception without the explaining message when dereferencing
                // completedOperation later, or we will get an InvalidOperation when processing the Op. With the check, they will be
                // aggregated and the user will know what went wrong.
                if (completedOperation == null)
                    throw new NullReferenceException(global::Windows.Storage.Streams.SR.NullReference_IOCompletionCallbackCannotProcessNullAsyncInfo);

                _completedOperation = completedOperation;

                // processCompletedOperationInCallback == false indicates that the stream is doing a blocking wait on the waitHandle of this IAsyncResult.
                // In that case calls on completedOperation may deadlock if completedOperation is not free threaded.
                // By setting processCompletedOperationInCallback to false the stream that created this IAsyncResult indicated that it
                // will call ProcessCompletedOperation after the waitHandle is signalled to fetch the results.

                if (_processCompletedOperationInCallback)
                    ProcessCompletedOperation();
            }
            catch (Exception ex)
            {
                _bytesCompleted = 0;
                _errorInfo = ExceptionDispatchInfo.Capture(ex);
            }
            finally
            {
                _completed = true;
                Interlocked.MemoryBarrier();
                // From this point on, AsyncWaitHandle would create a handle that is readily set,
                // so we do not need to check if it is being produced asynchronously.
                if (_waitHandle != null)
                    _waitHandle.Set();
            }

            if (_userCompletionCallback != null)
                _userCompletionCallback(this);
        }

        private void ThrowWithIOExceptionDispatchInfo(Exception e)
        {
            WinRtIOHelper.NativeExceptionToIOExceptionInfo(WinRT.ExceptionHelpers.AttachRestrictedErrorInfo(_completedOperation.ErrorCode)).Throw();
        }
    }  // class StreamOperationAsyncResult

    #endregion class StreamOperationAsyncResult


    #region class StreamReadAsyncResult

    internal sealed class StreamReadAsyncResult : StreamOperationAsyncResult
    {
        private readonly IBuffer _userBuffer;

        internal StreamReadAsyncResult(IAsyncOperationWithProgress<IBuffer, uint> asyncStreamReadOperation, IBuffer buffer,
                                       AsyncCallback userCompletionCallback, object userAsyncStateInfo,
                                       bool processCompletedOperationInCallback)

            : base(asyncStreamReadOperation, userCompletionCallback, userAsyncStateInfo, processCompletedOperationInCallback)
        {
            if (buffer == null)
                throw new ArgumentNullException(nameof(buffer));

            _userBuffer = buffer;
            asyncStreamReadOperation.Completed = this.StreamOperationCompletedCallback;
        }


        internal override void ProcessConcreteCompletedOperation(IAsyncInfo completedOperation, out long bytesCompleted)
        {
            ProcessConcreteCompletedOperation((IAsyncOperationWithProgress<IBuffer, uint>)completedOperation, out bytesCompleted);
        }


        private void ProcessConcreteCompletedOperation(IAsyncOperationWithProgress<IBuffer, uint> completedOperation, out long bytesCompleted)
        {
            IBuffer resultBuffer = completedOperation.GetResults();
            Debug.Assert(resultBuffer != null);

            WinRtIOHelper.EnsureResultsInUserBuffer(_userBuffer!, resultBuffer);
            bytesCompleted = _userBuffer!.Length;
        }
    }  // class StreamReadAsyncResult

    #endregion class StreamReadAsyncResult


    #region class StreamWriteAsyncResult

    internal sealed class StreamWriteAsyncResult : StreamOperationAsyncResult
    {
        internal StreamWriteAsyncResult(IAsyncOperationWithProgress<uint, uint> asyncStreamWriteOperation,
                                        AsyncCallback userCompletionCallback, object userAsyncStateInfo,
                                        bool processCompletedOperationInCallback)

            : base(asyncStreamWriteOperation, userCompletionCallback, userAsyncStateInfo, processCompletedOperationInCallback)
        {
            asyncStreamWriteOperation.Completed = this.StreamOperationCompletedCallback;
        }


        internal override void ProcessConcreteCompletedOperation(IAsyncInfo completedOperation, out long bytesCompleted)
        {
            ProcessConcreteCompletedOperation((IAsyncOperationWithProgress<uint, uint>)completedOperation, out bytesCompleted);
        }


        private void ProcessConcreteCompletedOperation(IAsyncOperationWithProgress<uint, uint> completedOperation, out long bytesCompleted)
        {
            uint bytesWritten = completedOperation.GetResults();
            bytesCompleted = bytesWritten;
        }
    }  // class StreamWriteAsyncResult

    #endregion class StreamWriteAsyncResult


    #region class StreamFlushAsyncResult

    internal sealed class StreamFlushAsyncResult : StreamOperationAsyncResult
    {
        internal StreamFlushAsyncResult(IAsyncOperation<bool> asyncStreamFlushOperation, bool processCompletedOperationInCallback)

            : base(asyncStreamFlushOperation, null, null, processCompletedOperationInCallback)
        {
            asyncStreamFlushOperation.Completed = this.StreamOperationCompletedCallback;
        }


        internal override void ProcessConcreteCompletedOperation(IAsyncInfo completedOperation, out long bytesCompleted)
        {
            ProcessConcreteCompletedOperation((IAsyncOperation<bool>)completedOperation, out bytesCompleted);
        }


        private void ProcessConcreteCompletedOperation(IAsyncOperation<bool> completedOperation, out long bytesCompleted)
        {
            bool success = completedOperation.GetResults();
            bytesCompleted = (success ? 0 : -1);
        }
    }  // class StreamFlushAsyncResult
    #endregion class StreamFlushAsyncResult
}  // namespace

// StreamOperationAsyncResult.cs

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.


namespace Windows.Storage.Streams
{
    using global::System.Diagnostics;
    using global::System.IO;
    
    using global::System.Runtime.InteropServices;
    using global::System.Threading.Tasks;
    using global::System.Threading;
    using global::System.Runtime.InteropServices.WindowsRuntime;
    using Windows.Foundation;

    /// <summary>Depending on the concrete type of the stream managed by a <c>NetFxToWinRtStreamAdapter</c>,
    /// we want the <c>ReadAsync</c> / <c>WriteAsync</c> / <c>FlushAsync</c> / etc. operation to be implemented
    /// differently. This is for best performance as we can take advantage of the specifics of particular stream
    /// types. For instance, <c>ReadAsync</c> currently has a special implementation for memory streams.
    /// Moreover, knowledge about the actual runtime type of the <c>IBuffer</c> can also help choosing the optimal
    /// implementation. This type provides static methods that encapsulate the performance logic and can be used
    /// by <c>NetFxToWinRtStreamAdapter</c>.</summary>
#if NET
    [global::System.Runtime.Versioning.SupportedOSPlatform("windows10.0.10240.0")]
#endif
    internal static class StreamOperationsImplementation
    {
    #if NET
            static StreamOperationsImplementation()
            {
                _ = StreamTaskAdaptersImplementation.Initialized;
            }
    #endif

            #region ReadAsync implementations

            internal static IAsyncOperationWithProgress<IBuffer, uint> ReadAsync_MemoryStream(Stream stream, IBuffer buffer, uint count)
            {
                Debug.Assert(stream != null);
                Debug.Assert(stream is MemoryStream);
                Debug.Assert(stream.CanRead);
                Debug.Assert(stream.CanSeek);
                Debug.Assert(buffer != null);
                Debug.Assert(0 <= count);
                Debug.Assert(count <= int.MaxValue);
                Debug.Assert(count <= buffer.Capacity);

                // We will return a different buffer to the user backed directly by the memory stream (avoids memory copy).
                // This is permitted by the WinRT stream contract.
                // The user specified buffer will not have any data put into it:
                buffer.Length = 0;

                MemoryStream memStream = stream as MemoryStream;
                Debug.Assert(memStream != null);

                try
                {
                    IBuffer dataBuffer = memStream.GetWindowsRuntimeBuffer((int)memStream.Position, (int)count);
                    if (dataBuffer.Length > 0)
                        memStream.Seek(dataBuffer.Length, SeekOrigin.Current);

                    return AsyncInfo.FromResultWithProgress<IBuffer, uint>(dataBuffer);
                }
                catch (Exception ex)
                {
                    return AsyncInfo.FromExceptionWithProgress<IBuffer, uint>(ex);
                }
            }  // ReadAsync_MemoryStream


            internal static IAsyncOperationWithProgress<IBuffer, uint> ReadAsync_AbstractStream(Stream stream, IBuffer buffer, uint count,
                                                                                                  InputStreamOptions options)
            {
                Debug.Assert(stream != null);
                Debug.Assert(stream.CanRead);
                Debug.Assert(buffer != null);
                Debug.Assert(0 <= count);
                Debug.Assert(count <= int.MaxValue);
                Debug.Assert(count <= buffer.Capacity);
                Debug.Assert(options == InputStreamOptions.None || options == InputStreamOptions.Partial || options == InputStreamOptions.ReadAhead);

                int bytesrequested = (int)count;

                // Check if the buffer is our implementation.
                // IF YES: In that case, we can read directly into its data array.
                // IF NO:  The buffer is of unknown implementation. It's not backed by a managed array, but the wrapped stream can only
                //         read into a managed array. If we used the user-supplied buffer we would need to copy data into it after every read.
                //         The spec allows to return a buffer instance that is not the same as passed by the user. So, we will create an own
                //         buffer instance, read data *directly* into the array backing it and then return it to the user.
                //         Note: the allocation costs we are paying for the new buffer are unavoidable anyway, as we would need to create
                //         an array to read into either way.

                IBuffer dataBuffer = buffer as WindowsRuntimeBuffer;

                if (dataBuffer == null)
                    dataBuffer = WindowsRuntimeBuffer.Create((int)Math.Min((uint)int.MaxValue, buffer.Capacity));

                // This operation delegate will we run inside of the returned IAsyncOperationWithProgress:
                Func<CancellationToken, IProgress<uint>, Task<IBuffer>> readOperation = async (cancelToken, progressListener) =>
                {
                    // No bytes read yet:
                    dataBuffer.Length = 0;

                    // Get the buffer backing array:
                    byte[] data;
                    int offset;
                    bool managedBufferAssert = dataBuffer.TryGetUnderlyingData(out data, out offset);
                    Debug.Assert(managedBufferAssert);

                    // Init tracking values:
                    bool done = cancelToken.IsCancellationRequested;
                    int bytesCompleted = 0;

                    // Loop until EOS, cancelled or read enough data according to options:
                    while (!done)
                    {
                        int bytesread = 0;

                        try
                        {
                            // Read asynchronously:
                            bytesread = await stream.ReadAsync(data!, offset + bytesCompleted, bytesrequested - bytesCompleted, cancelToken)
                                                    .ConfigureAwait(continueOnCapturedContext: false);

                            // We will continue here on a different thread when read async completed:
                            bytesCompleted += bytesread;
                            // We will handle a cancelation exception and re-throw all others:
                        }
                        catch (OperationCanceledException)
                        {
                            // We assume that cancelToken.IsCancellationRequested is has been set and simply proceed.
                            // (we check cancelToken.IsCancellationRequested later)
                            Debug.Assert(cancelToken.IsCancellationRequested);

                            // This is because if the cancellation came after we read some bytes we want to return the results we got instead
                            // of an empty cancelled task, so if we have not yet read anything at all, then we can throw cancellation:
                            if (bytesCompleted == 0 && bytesread == 0)
                                throw;
                        }

                        // Update target buffer:
                        dataBuffer.Length = (uint)bytesCompleted;

                        Debug.Assert(bytesCompleted <= bytesrequested);

                        // Check if we are done:
                        done = options == InputStreamOptions.Partial  // If no complete read was requested, any amount of data is OK
                                || bytesread == 0                         // this implies EndOfStream
                                || bytesCompleted == bytesrequested       // read all requested bytes
                                || cancelToken.IsCancellationRequested;   // operation was cancelled

                        // Call user Progress handler:
                        if (progressListener != null)
                            progressListener.Report(dataBuffer.Length);
                    }  // while (!done)

                    // If we got here, then no error was detected. Return the results buffer:
                    return dataBuffer;
                };  // readOperation

                return AsyncInfo.Run<IBuffer, uint>(readOperation);
            }  // ReadAsync_AbstractStream

            #endregion ReadAsync implementations


            #region WriteAsync implementations

            internal static IAsyncOperationWithProgress<uint, uint> WriteAsync_AbstractStream(Stream stream, IBuffer buffer)
            {
                Debug.Assert(stream != null);
                Debug.Assert(stream.CanWrite);
                Debug.Assert(buffer != null);

                // Choose the optimal writing strategy for the kind of buffer supplied:
                Func<CancellationToken, IProgress<uint>, Task<uint>> writeOperation;
                byte[] data;
                int offset;

                // If buffer is backed by a managed array:
                if (buffer.TryGetUnderlyingData(out data, out offset))
                {
                    writeOperation = async (cancelToken, progressListener) =>
                    {
                        if (cancelToken.IsCancellationRequested)  // CancellationToken is non-nullable
                            return 0;

                        Debug.Assert(buffer.Length <= int.MaxValue);

                        int bytesToWrite = (int)buffer.Length;

                        await stream.WriteAsync(data, offset, bytesToWrite, cancelToken).ConfigureAwait(continueOnCapturedContext: false);

                        if (progressListener != null)
                            progressListener.Report((uint)bytesToWrite);

                        return (uint)bytesToWrite;
                    };
                    // Otherwise buffer is of an unknown implementation:
                }
                else
                {
                    writeOperation = async (cancelToken, progressListener) =>
                    {
                        if (cancelToken.IsCancellationRequested)  // CancellationToken is non-nullable
                            return 0;

                        uint bytesToWrite = buffer.Length;
                        Stream dataStream = buffer.AsStream();

                        int buffSize = 0x4000;
                        if (bytesToWrite < buffSize)
                            buffSize = (int)bytesToWrite;
                        
                        if (buffSize > 0)
                            await dataStream.CopyToAsync(stream, buffSize, cancelToken).ConfigureAwait(continueOnCapturedContext: false);

                        if (progressListener != null)
                            progressListener.Report((uint)bytesToWrite);

                        return (uint)bytesToWrite;
                    };
                }  // if-else

                // Construct and run the async operation:
                return AsyncInfo.Run<uint, uint>(writeOperation);
            }  // WriteAsync_AbstractStream

            #endregion WriteAsync implementations


            #region FlushAsync implementations

            internal static IAsyncOperation<bool> FlushAsync_AbstractStream(Stream stream)
            {
                Debug.Assert(stream != null);
                Debug.Assert(stream.CanWrite);

                Func<CancellationToken, Task<bool>> flushOperation = async (cancelToken) =>
                {
                    if (cancelToken.IsCancellationRequested)  // CancellationToken is non-nullable
                        return false;

                    await stream.FlushAsync(cancelToken).ConfigureAwait(continueOnCapturedContext: false);
                    return true;
                };

                // Construct and run the async operation:
                return AsyncInfo.Run<bool>(flushOperation);
            }
            #endregion FlushAsync implementations

        }  // class StreamOperationsImplementation
}  // namespace

#if NET
namespace Windows.Storage.Streams
{
    // Given we do not do automatic lookup table generation for projections, this class defines
    // one for the scenarios which are used by StreamOperationsImplementations for its task adapters.
    internal static class StreamTaskAdaptersImplementation
    {
        private static readonly bool _initialized = Init();
        internal static bool Initialized => _initialized;

        private static unsafe bool Init()
        {
            global::WinRT.ComWrappersSupport.RegisterTypeComInterfaceEntriesLookup(LookupVtableEntries);
            global::WinRT.ComWrappersSupport.RegisterTypeRuntimeClassNameLookup(new Func<Type, string>(LookupRuntimeClassName));
            return true;
        }

        private static ComWrappers.ComInterfaceEntry[] LookupVtableEntries(Type type)
        {
            var typeName = type.ToString();
            if (typeName == "System.Threading.Tasks.TaskToAsyncOperationWithProgressAdapter`2[Windows.Storage.Streams.IBuffer,System.UInt32]")
            {
                _ = IAsyncOperationWithProgress_IBuffer_uint.Initialized;

                return new global::System.Runtime.InteropServices.ComWrappers.ComInterfaceEntry[]
                {
                    new global::System.Runtime.InteropServices.ComWrappers.ComInterfaceEntry
                    {
                        IID = global::ABI.Windows.Foundation.IAsyncOperationWithProgressMethods<Windows.Storage.Streams.IBuffer, uint>.IID,
                        Vtable = global::ABI.Windows.Foundation.IAsyncOperationWithProgressMethods<Windows.Storage.Streams.IBuffer, uint>.AbiToProjectionVftablePtr
                    },
                    new global::System.Runtime.InteropServices.ComWrappers.ComInterfaceEntry
                    {
                        IID = global::ABI.Windows.Foundation.IAsyncInfoMethods.IID,
                        Vtable = global::ABI.Windows.Foundation.IAsyncInfoMethods.AbiToProjectionVftablePtr
                    },
                };
            }
            else if (typeName == "System.Threading.Tasks.TaskToAsyncOperationWithProgressAdapter`2[System.UInt32,System.UInt32]")
            {
                _ = IAsyncOperationWithProgress_uint_uint.Initialized;

                return new global::System.Runtime.InteropServices.ComWrappers.ComInterfaceEntry[]
                {
                    new global::System.Runtime.InteropServices.ComWrappers.ComInterfaceEntry
                    {
                        IID = global::ABI.Windows.Foundation.IAsyncOperationWithProgressMethods<uint, uint>.IID,
                        Vtable = global::ABI.Windows.Foundation.IAsyncOperationWithProgressMethods<uint, uint>.AbiToProjectionVftablePtr
                    },
                    new global::System.Runtime.InteropServices.ComWrappers.ComInterfaceEntry
                    {
                        IID = global::ABI.Windows.Foundation.IAsyncInfoMethods.IID,
                        Vtable = global::ABI.Windows.Foundation.IAsyncInfoMethods.AbiToProjectionVftablePtr
                    },
                };
            }
            else if (typeName == "System.Threading.Tasks.TaskToAsyncOperationAdapter`1[System.Boolean]")
            {
                _ = IAsyncOperation_bool.Initialized;

                return new global::System.Runtime.InteropServices.ComWrappers.ComInterfaceEntry[]
                {
                    new global::System.Runtime.InteropServices.ComWrappers.ComInterfaceEntry
                    {
                        IID = global::ABI.Windows.Foundation.IAsyncOperationMethods<bool>.IID,
                        Vtable = global::ABI.Windows.Foundation.IAsyncOperationMethods<bool>.AbiToProjectionVftablePtr
                    },
                    new global::System.Runtime.InteropServices.ComWrappers.ComInterfaceEntry
                    {
                        IID = global::ABI.Windows.Foundation.IAsyncInfoMethods.IID,
                        Vtable = global::ABI.Windows.Foundation.IAsyncInfoMethods.AbiToProjectionVftablePtr
                    },
                };
            }

            return default;
        }

        private static string LookupRuntimeClassName(Type type)
        {
            var typeName = type.ToString();
            if (typeName == "System.Threading.Tasks.TaskToAsyncOperationWithProgressAdapter`2[Windows.Storage.Streams.IBuffer,System.UInt32]")
            {
                return "Windows.Foundation.IAsyncOperationWithProgress`2<Windows.Storage.Streams.IBuffer, UInt32>";
            }
            else if (typeName == "System.Threading.Tasks.TaskToAsyncOperationWithProgressAdapter`2[System.UInt32,System.UInt32]")
            {
                return "Windows.Foundation.IAsyncOperationWithProgress`2<Double, Double>";
            }
            else if (typeName == "System.Threading.Tasks.TaskToAsyncOperationAdapter`1[System.Boolean]")
            {
                return "Windows.Foundation.IAsyncOperation`1<Boolean>";
            }

            return default;
        }

        private static class IAsyncOperationWithProgress_uint_uint
        {
            private static readonly bool _initialized = Init();
            internal static bool Initialized => _initialized;

            private static unsafe bool Init()
            {
                return global::ABI.Windows.Foundation.IAsyncOperationWithProgressMethods<uint, uint, uint, uint>.InitCcw(
                    &Do_Abi_put_Progress_0,
                    &Do_Abi_get_Progress_1,
                    &Do_Abi_put_Completed_2,
                    &Do_Abi_get_Completed_3,
                    &Do_Abi_GetResults_4
                );
            }

            [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
            private static unsafe int Do_Abi_GetResults_4(IntPtr thisPtr, uint* __return_value__)
            {
                uint ____return_value__ = default;

                *__return_value__ = default;

                try
                {
                    ____return_value__ = global::ABI.Windows.Foundation.IAsyncOperationWithProgressMethods<uint, uint>.Do_Abi_GetResults_4(thisPtr);
                    *__return_value__ = ____return_value__;
                }
                catch (Exception __exception__)
                {
                    global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                    return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
                }
                return 0;
            }

            [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
            private static unsafe int Do_Abi_put_Progress_0(IntPtr thisPtr, IntPtr handler)
            {
                _ = AsyncOperationProgressHandler_uint_uint.Initialized;
                try
                {
                    global::ABI.Windows.Foundation.IAsyncOperationWithProgressMethods<uint, uint>.Do_Abi_put_Progress_0(
                        thisPtr,
                        global::ABI.Windows.Foundation.AsyncOperationProgressHandler<uint, uint>.FromAbi(handler));
                }
                catch (Exception __exception__)
                {
                    global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                    return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
                }
                return 0;
            }

            [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
            private static unsafe int Do_Abi_get_Progress_1(IntPtr thisPtr, IntPtr* __return_value__)
            {
                _ = AsyncOperationProgressHandler_uint_uint.Initialized;
                global::Windows.Foundation.AsyncOperationProgressHandler<uint, uint> ____return_value__ = default;

                *__return_value__ = default;

                try
                {
                    ____return_value__ = global::ABI.Windows.Foundation.IAsyncOperationWithProgressMethods<uint, uint>.Do_Abi_get_Progress_1(thisPtr);
                    *__return_value__ = global::ABI.Windows.Foundation.AsyncOperationProgressHandler<uint, uint>.FromManaged(____return_value__);

                }
                catch (Exception __exception__)
                {
                    global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                    return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
                }
                return 0;
            }

            [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
            private static unsafe int Do_Abi_put_Completed_2(IntPtr thisPtr, IntPtr handler)
            {
                _ = AsyncOperationWithProgressCompletedHandler_uint_uint.Initialized;
                try
                {
                    global::ABI.Windows.Foundation.IAsyncOperationWithProgressMethods<uint, uint>.Do_Abi_put_Completed_2(
                        thisPtr,
                        global::ABI.Windows.Foundation.AsyncOperationWithProgressCompletedHandler<uint, uint>.FromAbi(handler));
                }
                catch (Exception __exception__)
                {
                    global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                    return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
                }
                return 0;
            }

            [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
            private static unsafe int Do_Abi_get_Completed_3(IntPtr thisPtr, IntPtr* __return_value__)
            {
                _ = AsyncOperationWithProgressCompletedHandler_uint_uint.Initialized;
                global::Windows.Foundation.AsyncOperationWithProgressCompletedHandler<uint, uint> ____return_value__ = default;

                *__return_value__ = default;

                try
                {
                    ____return_value__ = global::ABI.Windows.Foundation.IAsyncOperationWithProgressMethods<uint, uint>.Do_Abi_get_Completed_3(thisPtr);
                    *__return_value__ = global::ABI.Windows.Foundation.AsyncOperationWithProgressCompletedHandler<uint, uint>.FromManaged(____return_value__);
                }
                catch (Exception __exception__)
                {
                    global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                    return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
                }
                return 0;
            }
        }

        private static class AsyncOperationProgressHandler_uint_uint
        {
            private static readonly bool _initialized = Init();
            internal static bool Initialized => _initialized;

            private static unsafe bool Init()
            {
                _ = global::ABI.Windows.Foundation.AsyncOperationProgressHandlerMethods<uint, uint, uint, uint>.InitCcw(&Do_Abi_Invoke);
                _ = global::ABI.Windows.Foundation.AsyncOperationProgressHandlerMethods<uint, uint, uint, uint>.InitRcwHelper(&Invoke);
                return true;
            }

            [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
            private static unsafe int Do_Abi_Invoke(IntPtr thisPtr, IntPtr asyncInfo, uint progressInfo)
            {
                try
                {
                    global::ABI.Windows.Foundation.AsyncOperationProgressHandlerMethods<uint, uint, uint, uint>.Abi_Invoke(
                        thisPtr,
                        MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<uint, uint>>.FromAbi(asyncInfo),
                        progressInfo);
                }
                catch (global::System.Exception __exception__)
                {
                    global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                    return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
                }
                return 0;
            }

            private static unsafe void Invoke(IObjectReference objRef, global::Windows.Foundation.IAsyncOperationWithProgress<uint, uint> asyncInfo, uint progressInfo)
            {
                IntPtr ThisPtr = objRef.ThisPtr;
                ObjectReferenceValue __asyncInfo = default;

                try
                {
                    __asyncInfo = MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<uint, uint>>.CreateMarshaler2(
                        asyncInfo,
                        global::ABI.Windows.Foundation.IAsyncOperationWithProgressMethods<uint, uint>.IID);
                    IntPtr abiAsyncInfo = MarshalInspectable<object>.GetAbi(__asyncInfo);

                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, uint, int>**)ThisPtr)[3](
                        ThisPtr,
                        abiAsyncInfo,
                        progressInfo));
                    GC.KeepAlive(objRef);
                }
                finally
                {
                    MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<uint, uint>>.DisposeMarshaler(__asyncInfo);

                }
            }
        }

        private static class AsyncOperationWithProgressCompletedHandler_uint_uint
        {
            private static readonly bool _initialized = Init();
            internal static bool Initialized => _initialized;

            private static unsafe bool Init()
            {
                return global::ABI.Windows.Foundation.AsyncOperationWithProgressCompletedHandlerMethods<uint, uint, uint, uint>.
                    InitCcw(&Do_Abi_Invoke);
            }

            [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
            private static unsafe int Do_Abi_Invoke(IntPtr thisPtr, IntPtr asyncInfo, global::Windows.Foundation.AsyncStatus asyncStatus)
            {
                try
                {
                    global::ABI.Windows.Foundation.AsyncOperationWithProgressCompletedHandlerMethods<uint, uint, uint, uint>.Abi_Invoke(
                        thisPtr,
                        MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<uint, uint>>.FromAbi(asyncInfo),
                        asyncStatus);
                }
                catch (global::System.Exception __exception__)
                {
                    global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                    return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
                }
                return 0;
            }
        }

        private static class IAsyncOperationWithProgress_IBuffer_uint
        {
            private static readonly bool _initialized = Init();
            internal static bool Initialized => _initialized;

            private static unsafe bool Init()
            {
                return global::ABI.Windows.Foundation.IAsyncOperationWithProgressMethods<Windows.Storage.Streams.IBuffer, IntPtr, uint, uint>.InitCcw(
                    &Do_Abi_put_Progress_0,
                    &Do_Abi_get_Progress_1,
                    &Do_Abi_put_Completed_2,
                    &Do_Abi_get_Completed_3,
                    &Do_Abi_GetResults_4
                );
            }

            [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
            private static unsafe int Do_Abi_GetResults_4(IntPtr thisPtr, IntPtr* __return_value__)
            {
                Windows.Storage.Streams.IBuffer ____return_value__ = default;

                *__return_value__ = default;

                try
                {
                    ____return_value__ = global::ABI.Windows.Foundation.IAsyncOperationWithProgressMethods<Windows.Storage.Streams.IBuffer, uint>.
                        Do_Abi_GetResults_4(thisPtr);
                    *__return_value__ = MarshalInterface<Windows.Storage.Streams.IBuffer>.FromManaged(____return_value__);
                }
                catch (Exception __exception__)
                {
                    global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                    return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
                }
                return 0;
            }

            [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
            private static unsafe int Do_Abi_put_Progress_0(IntPtr thisPtr, IntPtr handler)
            {
                _ = AsyncOperationProgressHandler_IBuffer_uint.Initialized;
                try
                {
                    global::ABI.Windows.Foundation.IAsyncOperationWithProgressMethods<Windows.Storage.Streams.IBuffer, uint>.Do_Abi_put_Progress_0(
                        thisPtr,
                        global::ABI.Windows.Foundation.AsyncOperationProgressHandler<Windows.Storage.Streams.IBuffer, uint>.FromAbi(handler));
                }
                catch (Exception __exception__)
                {
                    global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                    return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
                }
                return 0;
            }

            [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
            private static unsafe int Do_Abi_get_Progress_1(IntPtr thisPtr, IntPtr* __return_value__)
            {
                _ = AsyncOperationProgressHandler_IBuffer_uint.Initialized;
                global::Windows.Foundation.AsyncOperationProgressHandler<Windows.Storage.Streams.IBuffer, uint> ____return_value__ = default;

                *__return_value__ = default;

                try
                {
                    ____return_value__ = global::ABI.Windows.Foundation.IAsyncOperationWithProgressMethods<Windows.Storage.Streams.IBuffer, uint>.Do_Abi_get_Progress_1(thisPtr);
                    *__return_value__ = global::ABI.Windows.Foundation.AsyncOperationProgressHandler<Windows.Storage.Streams.IBuffer, uint>.FromManaged(____return_value__);

                }
                catch (Exception __exception__)
                {
                    global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                    return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
                }
                return 0;
            }

            [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
            private static unsafe int Do_Abi_put_Completed_2(IntPtr thisPtr, IntPtr handler)
            {
                _ = AsyncOperationWithProgressCompletedHandler_IBuffer_uint.Initialized;
                try
                {
                    global::ABI.Windows.Foundation.IAsyncOperationWithProgressMethods<Windows.Storage.Streams.IBuffer, uint>.Do_Abi_put_Completed_2(
                        thisPtr,
                        global::ABI.Windows.Foundation.AsyncOperationWithProgressCompletedHandler<Windows.Storage.Streams.IBuffer, uint>.FromAbi(handler));
                }
                catch (Exception __exception__)
                {
                    global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                    return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
                }
                return 0;
            }

            [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
            private static unsafe int Do_Abi_get_Completed_3(IntPtr thisPtr, IntPtr* __return_value__)
            {
                _ = AsyncOperationWithProgressCompletedHandler_IBuffer_uint.Initialized;
                global::Windows.Foundation.AsyncOperationWithProgressCompletedHandler<Windows.Storage.Streams.IBuffer, uint> ____return_value__ = default;

                *__return_value__ = default;

                try
                {
                    ____return_value__ = global::ABI.Windows.Foundation.IAsyncOperationWithProgressMethods<Windows.Storage.Streams.IBuffer, uint>.Do_Abi_get_Completed_3(thisPtr);
                    *__return_value__ = global::ABI.Windows.Foundation.AsyncOperationWithProgressCompletedHandler<Windows.Storage.Streams.IBuffer, uint>.FromManaged(____return_value__);
                }
                catch (Exception __exception__)
                {
                    global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                    return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
                }
                return 0;
            }
        }

        private static class AsyncOperationProgressHandler_IBuffer_uint
        {
            private static readonly bool _initialized = Init();
            internal static bool Initialized => _initialized;

            private static unsafe bool Init()
            {
                _ = global::ABI.Windows.Foundation.AsyncOperationProgressHandlerMethods<Windows.Storage.Streams.IBuffer, IntPtr, uint, uint>.InitCcw(&Do_Abi_Invoke);
                _ = global::ABI.Windows.Foundation.AsyncOperationProgressHandlerMethods<Windows.Storage.Streams.IBuffer, IntPtr, uint, uint>.InitRcwHelper(&Invoke);
                return true;
            }

            [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
            private static unsafe int Do_Abi_Invoke(IntPtr thisPtr, IntPtr asyncInfo, uint progressInfo)
            {
                try
                {
                    global::ABI.Windows.Foundation.AsyncOperationProgressHandlerMethods<Windows.Storage.Streams.IBuffer, IntPtr, uint, uint>.Abi_Invoke(
                        thisPtr,
                        MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer, uint>>.FromAbi(asyncInfo),
                        progressInfo);
                }
                catch (global::System.Exception __exception__)
                {
                    global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                    return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
                }
                return 0;
            }

            private static unsafe void Invoke(
                IObjectReference objRef,
                global::Windows.Foundation.IAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer, uint> asyncInfo,
                uint progressInfo)
            {
                IntPtr ThisPtr = objRef.ThisPtr;
                ObjectReferenceValue __asyncInfo = default;

                try
                {
                    __asyncInfo = MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer, uint>>.CreateMarshaler2(
                        asyncInfo,
                        global::ABI.Windows.Foundation.IAsyncOperationWithProgressMethods<Windows.Storage.Streams.IBuffer, uint>.IID);
                    IntPtr abiAsyncInfo = MarshalInspectable<object>.GetAbi(__asyncInfo);

                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, uint, int>**)ThisPtr)[3](
                        ThisPtr,
                        abiAsyncInfo,
                        progressInfo));
                    GC.KeepAlive(objRef);
                }
                finally
                {
                    MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer, uint>>.DisposeMarshaler(__asyncInfo);

                }
            }
        }

        private static class AsyncOperationWithProgressCompletedHandler_IBuffer_uint
        {
            private static readonly bool _initialized = Init();
            internal static bool Initialized => _initialized;

            private static unsafe bool Init()
            {
                return global::ABI.Windows.Foundation.AsyncOperationWithProgressCompletedHandlerMethods<Windows.Storage.Streams.IBuffer, IntPtr, uint, uint>.
                    InitCcw(&Do_Abi_Invoke);
            }

            [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
            private static unsafe int Do_Abi_Invoke(IntPtr thisPtr, IntPtr asyncInfo, global::Windows.Foundation.AsyncStatus asyncStatus)
            {
                try
                {
                    global::ABI.Windows.Foundation.AsyncOperationWithProgressCompletedHandlerMethods<Windows.Storage.Streams.IBuffer, IntPtr, uint, uint>.Abi_Invoke(
                        thisPtr,
                        MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer, uint>>.FromAbi(asyncInfo),
                        asyncStatus);
                }
                catch (global::System.Exception __exception__)
                {
                    global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                    return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
                }
                return 0;
            }
        }

        private static class IAsyncOperation_bool
        {
            private static readonly bool _initialized = Init();
            internal static bool Initialized => _initialized;

            private static unsafe bool Init()
            {
                return global::ABI.Windows.Foundation.IAsyncOperationMethods<bool, byte>.InitCcw(
                    &Do_Abi_put_Completed_0,
                    &Do_Abi_get_Completed_1,
                    &Do_Abi_GetResults_2
                );
            }

            [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
            private static unsafe int Do_Abi_GetResults_2(IntPtr thisPtr, byte* __return_value__)
            {
                bool ____return_value__ = default;

                *__return_value__ = default;

                try
                {
                    ____return_value__ = global::ABI.Windows.Foundation.IAsyncOperationMethods<bool>.Do_Abi_GetResults_2(thisPtr);
                    *__return_value__ = (byte)(____return_value__ ? 1 : 0);
                }
                catch (Exception __exception__)
                {
                    global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                    return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
                }
                return 0;
            }

            [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
            private static unsafe int Do_Abi_put_Completed_0(IntPtr thisPtr, IntPtr handler)
            {
                _ = AsyncOperationCompletedHandler_bool.Initialized;
                try
                {
                    global::ABI.Windows.Foundation.IAsyncOperationMethods<bool>.Do_Abi_put_Completed_0(thisPtr, global::ABI.Windows.Foundation.AsyncOperationCompletedHandler<bool>.FromAbi(handler));
                }
                catch (Exception __exception__)
                {
                    global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                    return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
                }
                return 0;
            }

            [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
            private static unsafe int Do_Abi_get_Completed_1(IntPtr thisPtr, IntPtr* __return_value__)
            {
                _ = AsyncOperationCompletedHandler_bool.Initialized;
                global::Windows.Foundation.AsyncOperationCompletedHandler<bool> ____return_value__ = default;

                *__return_value__ = default;

                try
                {
                    ____return_value__ = global::ABI.Windows.Foundation.IAsyncOperationMethods<bool>.Do_Abi_get_Completed_1(thisPtr);
                    *__return_value__ = global::ABI.Windows.Foundation.AsyncOperationCompletedHandler<bool>.FromManaged(____return_value__);
                }
                catch (Exception __exception__)
                {
                    global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                    return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
                }
                return 0;
            }
        }

        private static class AsyncOperationCompletedHandler_bool
        {
            private static readonly bool _initialized = Init();
            internal static bool Initialized => _initialized;

            private static unsafe bool Init()
            {
                return global::ABI.Windows.Foundation.AsyncOperationCompletedHandlerMethods<bool, byte>.InitCcw(
                    &Do_Abi_Invoke
                );
            }

            [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvStdcall) })]
            private static unsafe int Do_Abi_Invoke(IntPtr thisPtr, IntPtr asyncInfo, global::Windows.Foundation.AsyncStatus asyncStatus)
            {
                try
                {
                    global::ABI.Windows.Foundation.AsyncOperationCompletedHandlerMethods<bool, byte>.Abi_Invoke(
                        thisPtr,
                        MarshalInterface<global::Windows.Foundation.IAsyncOperation<bool>>.FromAbi(asyncInfo),
                        asyncStatus);
                }
                catch (global::System.Exception __exception__)
                {
                    global::WinRT.ExceptionHelpers.SetErrorInfo(__exception__);
                    return global::WinRT.ExceptionHelpers.GetHRForException(__exception__);
                }
                return 0;
            }
        }
    }
}
#endif

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

namespace Windows.Storage.Streams
{
    static class SR
    {
        public static string Argument_BufferIndexExceedsCapacity = "The specified buffer index is not within the buffer capacity.";

        public static string Argument_BufferLengthExceedsCapacity = "The specified useful data length exceeds the capacity of this buffer.";

        public static string Argument_IndexOutOfArrayBounds = "The specified index is out of bounds of the specified array.";

        public static string Argument_InstancesImplementingIRASThatCanReadMustImplementIIS = "The specified Windows Runtime stream supports the IRandomAccessStream interface and its CanRead property returns TRUE, however it does not implement the IInputStream interface. Windows Runtime streams with such inconsistent capabilities cannot be converted to managed Stream objects. IRandomAccessStream instances whose CanRead property returns TRUE must implement the IInputStream interface.";

        public static string Argument_InstancesImplementingIRASThatCanWriteMustImplementIOS = "The specified Windows Runtime stream supports the IRandomAccessStream interface and its CanWrite property returns TRUE, however it does not implement the IOutputStream interface. Windows Runtime streams with such inconsistent capabilities cannot be converted to managed Stream objects. IRandomAccessStream instances whose CanWrite property returns TRUE must implement the IOutputStream interface.";

        public static string Argument_InsufficientArrayElementsAfterOffset = "The specified array does not contain the specified number of elements starting at the specified offset.";

        public static string Argument_InsufficientBufferCapacity = "The specified buffer capacity is not sufficient to hold data of the specified length.";

        public static string Argument_InsufficientSpaceInSourceBuffer = "The specified source buffer does not contain the specified number of elements starting at the specified offset.";

        public static string Argument_InsufficientSpaceInTargetBuffer = "The specified destination buffer is not large enough to hold the specified number of bytes starting at the specified offset.";

        public static string Argument_NotSufficientCapabilitiesToConvertToWinRtStream = "Cannot convert the specified Stream object to a Windows Runtime stream because it does not have sufficient capabilities. In order to convert a System.IO.Stream instance to a Windows Runtime stream at least one of the properties CanRead, CanWrite, CanSeek must return TRUE; however, none of these properties returns TRUE for the specified Stream.";

        public static string Argument_ObjectMustBeWinRtStreamToConvertToNetFxStream = "The specified object cannot be converted to a System.IO.Stream instance because it is not a Windows Runtime stream. In order to convert an object to a Stream instance it must implement at least one of the following 3 Windows Runtime stream interfaces: IInputStream, IOutputStream, IRandomAccessStream.";

        public static string Argument_RelativePathMayNotBeWhitespaceOnly = "The specified relative path may not consist of whitespace only";

        public static string Argument_StreamPositionBeyondEOS = "The specified stream position is beyond the end of the stream.";

        public static string Argument_UnexpectedAsyncResult = "The specified AsyncResult does not correspond to any outstanding IO operation.";

        public static string Argument_WinRtStreamCannotReadOrWrite = "The specified Windows Runtime stream does not support reading nor writing. Windows Runtime streams with such capabilities cannot be converted to managed Stream objects. Use a Windows Runtime stream that can support reading, writing or both.";

        public static string ArgumentOutOfRange_CannotResizeStreamToNegative = "Cannot set the length of a stream to a negative value.";

        public static string ArgumentOutOfRange_IO_CannotSeekToNegativePosition = "Cannot seek to an absolute stream position that is negative.";

        public static string ArgumentOutOfRange_InvalidInputStreamOptionsEnumValue = "The specified value is not a valid member of the InputStreamOptions enumeration.";

        public static string ArgumentOutOfRange_NeedNonNegNum = "Non-negative number required.";

        public static string ArgumentOutOfRange_WinRtAdapterBufferSizeMayNotBeNegative = "The buffer size for a Windows Runtime stream adapter may not be negative. Use a positive buffer size or 0 to disable buffering.";

        public static string InvalidOperation_CannotCallThisMethodInCurrentState = "The state of this object does not permit invoking this method.";

        public static string InvalidOperation_CannotChangeBufferSizeOfWinRtStreamAdapter = "Cannot convert the specified Windows Runtime stream to a managed System.IO.Stream object with the specified buffer size because this Windows Runtime stream has been previously converted to a managed Stream object with a different buffer size. Ensure that the 'bufferSize' argument matches the existing buffer or use the '{0}'-overload without the 'bufferSize' argument to convert the specified Windows Runtime stream to a Stream object with the same buffer size as previously.";

        public static string InvalidOperation_CannotChangeBufferSizeOfWinRtStreamAdapterToZero = "Cannot convert the specified Windows Runtime stream to a managed System.IO.Stream object without a buffer because this Windows Runtime stream has been previously converted to a managed Stream object with a buffer. Ensure that the 'bufferSize' argument matches the existing buffer or use the '{0}'-overload without the 'bufferSize' argument to convert the specified Windows Runtime stream to a Stream object with the same buffer size as previously.";

        public static string InvalidOperation_CannotGetResultsFromIncompleteOperation = "Cannot call GetResults on this asynchronous info because the underlying operation has not completed.";

        public static string InvalidOperation_CannotSetCompletionHanlderMoreThanOnce = "The 'Completed' handler delegate cannot be set more than once, but this handler has already been set.";

        public static string InvalidOperation_CannotSetStreamSizeCannotWrite = "Cannot set the size of this stream because it cannot be written to.";

        public static string InvalidOperation_IllegalStateChange = "The specified state transition is illegal for the current state of this object.";

        public static string InvalidOperation_InvalidAsyncCompletion = "The asynchronous operation could not be completed.";

        public static string InvalidOperation_MultipleIOCompletionCallbackInvocation = "A callback for the same asynchronous IO operation was invoked more than once.";

        public static string InvalidOperation_TaskProviderReturnedUnstartedTask = "The Task provider delegate specified for this IAsyncInfo instance returned a Task object that was not started. Task instances must be run immediately upon creation.";

        public static string InvalidOperation_UnexpectedAsyncOperationID = "This AsyncResult or Task corresponds to a different asynchronous operation ID than the one that invoked the completion callback.";

        public static string InvalidOperation_UnstartedTaskSpecified = "The specified underlying Task is not started. Task instances must be run immediately upon creation.";

        public static string IO_CannotSeekBeyondInt64MaxValue = "Cannot seek to an absolute stream position that is larger than 2^63 - 1 bytes. (2^63 - 1 = 0x7FFFFFFFFFFFFFFF = Int64.MaxValue).";

        public static string IO_CannotSetSizeBeyondInt64MaxValue = "This Windows Runtime stream is backed by a .NET Stream; its size cannot be set to a value that is larger than 2^63 - 1 bytes. (2^63 - 1 = 0x7FFFFFFFFFFFFFFF = Int64.MaxValue).";

        public static string IO_General = "An IO error occurred in the Windows runtime system.";

        public static string IO_UnderlyingWinRTStreamTooLong_CannotUseLengthOrPosition = "This Stream is backed by a Windows Runtime stream with a length that exceeds 2^63 - 1 bytes. Operations related to the stream's length or position cannot be performed on streams when the length exceeds 2^63 - 1 bytes. (2^63 - 1 = 0x7FFFFFFFFFFFFFFF = Int64.MaxValue = approx. 8000 PetaBytes.)";

        public static string NotImplemented_NativeRoutineNotFound = "A native library routine was not found: {0}.";

        public static string NotSupported_CannotConvertNotReadableToInputStream = "Cannot use the specified Stream as a Windows Runtime IInputStream because this Stream is not readable.";

        public static string NotSupported_CannotConvertNotSeekableToRandomAccessStream = "Cannot use the specified Stream as a Windows Runtime IRandomAccessStream because this Stream does not support seeking.";

        public static string NotSupported_CannotConvertNotWritableToOutputStream = "Cannot use the specified Stream as a Windows Runtime IOutputStream because this Stream is not writable.";

        public static string NotSupported_CannotReadFromStream = "This stream does not support read access.";

        public static string NotSupported_CannotSeekInStream = "This stream does not support seeking.";

        public static string NotSupported_CannotUseLength_StreamNotSeekable = "This stream does not support the Length property because it is not seekable.";

        public static string NotSupported_CannotUsePosition_StreamNotSeekable = "This stream does not support the Position property because it is not seekable.";

        public static string NotSupported_CannotWriteToStream = "This stream does not support write access.";

        public static string NotSupported_CloningNotSupported = "This IRandomAccessStream does not support the {0} method because it requires cloning and this stream does not support cloning.";

        public static string NullReference_IOCompletionCallbackCannotProcessNullAsyncInfo = "The Windows Runtime stream that underlies this System.IO.Stream object has invoked an IO completion callback and specified null for the IAsyncInfo instance that describes the completed IO operation. This behavior is not supported because results cannot be retrieved from a null operation. Either the underlying Windows Runtime stream has a faulty implementation, or you are using a Windows Runtime object in an unsupported runtime environment.";

        public static string NullReference_TaskProviderReturnedNull = "The task provider delegate used to create this asynchronous operation returned null, but a valid Task object was expected.";

        public static string ObjectDisposed_AsyncInfoIsClosed = "The requested invocation is not permitted because this IAsyncInfo instance has already been closed.";

        public static string ObjectDisposed_CannotPerformOperation = "The requested operation cannot be performed because this stream has already been disposed.";

        public static string WinRtCOM_Error = "An error has occurred.";

        public static string ObjectDisposed_StreamClosed = "Cannot access a closed stream.";

        public static string NotSupported_UnseekableStream = "Stream does not support seeking.";

        public static string NotSupported_UnreadableStream = "Stream does not support reading.";

        public static string NotSupported_UnwritableStream = "Stream does not support writing.";

        public static string Argument_InvalidSeekOrigin = "Invalid seek origin.";

        public static string DirectUI_Empty = "Empty.";

        public static string InvalidOperation_SendNotSupportedOnWindowsrTSynchronizationContext = "Send is not supported in the Windows Runtime SynchronizationContext";

        public static string UnauthorizedAccess_InternalBuffer = "MemoryStream's internal buffer cannot be accessed.";

        public static string NotSupported_Inheritable = "Inheritable is not a supported option.";

        public static string NotSupported_Encrypted = "Encrypted is not a supported option.";

        public static string IO_FileNotFound = "Unable to find the specified file.";

        public static string IO_FileNotFound_FileName = "Could not find file '{0}'.";

        public static string IO_PathNotFound_NoPathName = "Could not find a part of the path.";

        public static string IO_PathNotFound_Path = "Could not find a part of the path '{0}'.";

        public static string UnauthorizedAccess_IODenied_NoPathName = "Access to the path is denied.";

        public static string UnauthorizedAccess_IODenied_Path = "Access to the path '{0}' is denied.";

        public static string IO_AlreadyExists_Name = "Cannot create '{0}' because a file or directory with the same name already exists.";

        public static string IO_PathTooLong = "The specified file name or path is too long, or a component of the specified path is too long.";

        public static string IO_SharingViolation_File = "The process cannot access the file '{0}' because it is being used by another process.";

        public static string IO_SharingViolation_NoFileName = "The process cannot access the file because it is being used by another process.";

        public static string IO_FileExists_Name = "The file '{0}' already exists.";

        public static string IO_PathTooLong_Path = "The path '{0}' is too long, or a component of the specified path is too long.";
    
        public static string InvalidAction = "Invalid action value: '{0}'.";

    }
}

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.


namespace System.Runtime.InteropServices.WindowsRuntime
{
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using System.Runtime.CompilerServices;
    using System.Runtime.InteropServices;
    using System.Security;
    using System.Threading;
    using global::Windows.Foundation;
    using global::Windows.Storage.Streams;
    using Com;
    /// <summary>
    /// Contains an implementation of the WinRT IBuffer interface that conforms to all requirements on classes that implement that interface,
    /// such as implementing additional interfaces.
    /// </summary>
#if NET
    [global::WinRT.WinRTExposedType(typeof(global::ABI.System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferWinRTTypeDetails))]
#endif
#if EMBED
    internal
#else
    public
#endif
    sealed class WindowsRuntimeBuffer : IBuffer, IBufferByteAccess, IMarshal
    {
        [DllImport("api-ms-win-core-winrt-robuffer-l1-1-0.dll")]
        private static extern unsafe int RoGetBufferMarshaler(IntPtr* bufferMarshalerPtr);
        #region Constants

        private const string WinTypesDLL = "WinTypes.dll";
        private const int E_BOUNDS = unchecked((int)0x8000000B);

        #endregion Constants


        #region Static factory methods

        public static IBuffer Create(int capacity)
        {
            if (capacity < 0) throw new ArgumentOutOfRangeException(nameof(capacity));

            return new WindowsRuntimeBuffer(capacity);
        }


        public static IBuffer Create(byte[] data, int offset, int length, int capacity)
        {
            if (data == null) throw new ArgumentNullException(nameof(data));
            if (offset < 0) throw new ArgumentOutOfRangeException(nameof(offset));
            if (length < 0) throw new ArgumentOutOfRangeException(nameof(length));
            if (capacity < 0) throw new ArgumentOutOfRangeException(nameof(capacity));
            if (data.Length - offset < length) throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InsufficientArrayElementsAfterOffset);
            if (data.Length - offset < capacity) throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InsufficientArrayElementsAfterOffset);
            if (capacity < length) throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InsufficientBufferCapacity);

            byte[] underlyingData = new byte[capacity];
            Array.Copy(data, offset, underlyingData, 0, length);
            return new WindowsRuntimeBuffer(underlyingData, 0, length, capacity);
        }

        #endregion Static factory methods


        #region Static fields and helpers

        // This object handles IMarshal calls for us:
        [ThreadStatic]
        private static IMarshal t_winRtMarshalProxy = null;

        private static unsafe void EnsureHasMarshalProxy()
        {
            if (t_winRtMarshalProxy != null)
                return;

            try
            {
                IntPtr proxyPtr = default;
                int hr = RoGetBufferMarshaler(&proxyPtr);
                IMarshal proxy = new ABI.Com.IMarshal(ObjectReference<ABI.Com.IMarshal.Vftbl>.Attach(ref proxyPtr, global::WinRT.Interop.IID.IID_IMarshal));
                t_winRtMarshalProxy = proxy;

                if (hr != 0)
                {
                    Exception ex = new Exception(string.Format("{0} ({1}!RoGetBufferMarshaler)", global::Windows.Storage.Streams.SR.WinRtCOM_Error, WinTypesDLL));
                    ex.SetHResult(hr);
                    throw ex;
                }

                if (proxy == null)
                    throw new NullReferenceException(string.Format("{0} ({1}!RoGetBufferMarshaler)", global::Windows.Storage.Streams.SR.WinRtCOM_Error, WinTypesDLL));
            }
            catch (DllNotFoundException ex)
            {
                throw new NotImplementedException(string.Format(global::Windows.Storage.Streams.SR.NotImplemented_NativeRoutineNotFound,
                                                               string.Format("{0}!RoGetBufferMarshaler", WinTypesDLL)),
                                                  ex);
            }
        }

        #endregion Static fields and helpers


        #region Fields

        private readonly byte[] _data;
        private readonly int _dataStartOffs = 0;
        private int _usefulDataLength = 0;
        private readonly int _maxDataCapacity = 0;
        private GCHandle _pinHandle;

        // Pointer to data[dataStartOffs] when data is pinned:
        private IntPtr _dataPtr = IntPtr.Zero;

        #endregion Fields


        #region Constructors

        internal WindowsRuntimeBuffer(int capacity)
        {
            if (capacity < 0)
                throw new ArgumentOutOfRangeException(nameof(capacity));

            _data = new byte[capacity];
            _dataStartOffs = 0;
            _usefulDataLength = 0;
            _maxDataCapacity = capacity;
            _dataPtr = IntPtr.Zero;
        }


        internal WindowsRuntimeBuffer(byte[] data, int offset, int length, int capacity)
        {
            if (data == null) throw new ArgumentNullException(nameof(data));
            if (offset < 0) throw new ArgumentOutOfRangeException(nameof(offset));
            if (length < 0) throw new ArgumentOutOfRangeException(nameof(length));
            if (capacity < 0) throw new ArgumentOutOfRangeException(nameof(capacity));
            if (data.Length - offset < length) throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InsufficientArrayElementsAfterOffset);
            if (data.Length - offset < capacity) throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InsufficientArrayElementsAfterOffset);
            if (capacity < length) throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InsufficientBufferCapacity);

            _data = data;
            _dataStartOffs = offset;
            _usefulDataLength = length;
            _maxDataCapacity = capacity;
            _dataPtr = IntPtr.Zero;
        }

        #endregion Constructors


        #region Helpers

        internal void GetUnderlyingData(out byte[] underlyingDataArray, out int underlyingDataArrayStartOffset)
        {
            underlyingDataArray = _data;
            underlyingDataArrayStartOffset = _dataStartOffs;
        }


        private unsafe byte* PinUnderlyingData()
        {
            GCHandle gcHandle = default(GCHandle);
            bool ptrWasStored = false;
            IntPtr buffPtr;

            try { }
            finally
            {
                try
                {
                    // Pin the data array:
                    gcHandle = GCHandle.Alloc(_data, GCHandleType.Pinned);
                    buffPtr = gcHandle.AddrOfPinnedObject() + _dataStartOffs;

                    // Store the pin IFF it has not been assigned:
                    ptrWasStored = (Interlocked.CompareExchange(ref _dataPtr, buffPtr, IntPtr.Zero) == IntPtr.Zero);
                }
                finally
                {
                    if (!ptrWasStored)
                    {
                        // There is a race with another thread also trying to create a pin and they were first
                        // in assigning to data pin. That's ok, just give it up.
                        // Unpin again (the pin from the other thread remains):
                        gcHandle.Free();
                    }
                    else
                    {
                        if (_pinHandle.IsAllocated)
                            _pinHandle.Free();

                        // Make sure we keep track of the handle
                        _pinHandle = gcHandle;
                    }
                }
            }

            // Ok, now all is good:
            return (byte*)buffPtr;
        }

        ~WindowsRuntimeBuffer()
        {
            if (_pinHandle.IsAllocated)
                _pinHandle.Free();
        }

        #endregion Helpers


        #region Implementation of Windows.Foundation.IBuffer

        uint IBuffer.Capacity
        {
            get { return unchecked((uint)_maxDataCapacity); }
        }


        uint IBuffer.Length
        {
            get
            {
                return unchecked((uint)_usefulDataLength);
            }

            set
            {
                if (value > ((IBuffer)this).Capacity)
                {
                    ArgumentOutOfRangeException ex = new ArgumentOutOfRangeException(nameof(value), global::Windows.Storage.Streams.SR.Argument_BufferLengthExceedsCapacity);
                    ex.SetHResult(E_BOUNDS);
                    throw ex;
                }

                // Capacity is ensured to not exceed Int32.MaxValue, so Length is within this limit and this cast is safe:
                Debug.Assert(((IBuffer)this).Capacity <= int.MaxValue);
                _usefulDataLength = unchecked((int)value);
            }
        }

        #endregion Implementation of Windows.Foundation.IBuffer


        #region Implementation of IBufferByteAccess

        unsafe IntPtr IBufferByteAccess.Buffer
        {
            get
            {
                // Get pin handle:
                IntPtr buffPtr = Volatile.Read(ref _dataPtr);

                // If we are already pinned, return the pointer and have a nice day:
                if (buffPtr != IntPtr.Zero)
                    return buffPtr;

                // Ok, we are not yet pinned. Let's do it.
                return new IntPtr(PinUnderlyingData());
            }
        }

        #endregion Implementation of IBufferByteAccess

        #region Implementation of IMarshal

        void IMarshal.DisconnectObject(uint dwReserved)
        {
            EnsureHasMarshalProxy();
            t_winRtMarshalProxy!.DisconnectObject(dwReserved);
        }


        unsafe void IMarshal.GetMarshalSizeMax(Guid* riid, IntPtr pv, MSHCTX dwDestContext, IntPtr pvDestContext, MSHLFLAGS mshlflags, uint* pSize)
        {
            EnsureHasMarshalProxy();
            t_winRtMarshalProxy!.GetMarshalSizeMax(riid, pv, dwDestContext, pvDestContext, mshlflags, pSize);
        }


        unsafe void IMarshal.GetUnmarshalClass(Guid* riid, IntPtr pv, MSHCTX dwDestContext, IntPtr pvDestContext, MSHLFLAGS mshlFlags, Guid* pCid)
        {
            EnsureHasMarshalProxy();
            t_winRtMarshalProxy!.GetUnmarshalClass(riid, pv, dwDestContext, pvDestContext, mshlFlags, pCid);
        }


        unsafe void IMarshal.MarshalInterface(IntPtr pStm, Guid* riid, IntPtr pv, MSHCTX dwDestContext, IntPtr pvDestContext, MSHLFLAGS mshlflags)
        {
            EnsureHasMarshalProxy();
            t_winRtMarshalProxy!.MarshalInterface(pStm, riid, pv, dwDestContext, pvDestContext, mshlflags);
        }


        void IMarshal.ReleaseMarshalData(IntPtr pStm)
        {
            EnsureHasMarshalProxy();
            t_winRtMarshalProxy!.ReleaseMarshalData(pStm);
        }


        unsafe void IMarshal.UnmarshalInterface(IntPtr pStm, Guid* riid, IntPtr* ppv)
        {
            EnsureHasMarshalProxy();
            t_winRtMarshalProxy!.UnmarshalInterface(pStm, riid, ppv);
        }
        #endregion Implementation of IMarshal
    }  // class WindowsRuntimeBuffer
}  // namespace

#if NET
namespace ABI.System.Runtime.InteropServices.WindowsRuntime
{
    internal sealed class WindowsRuntimeBufferWinRTTypeDetails : global::WinRT.IWinRTExposedTypeDetails
    {
        public ComWrappers.ComInterfaceEntry[] GetExposedInterfaces()
        {
            return new ComWrappers.ComInterfaceEntry[]
            {
                new ComWrappers.ComInterfaceEntry
                {
                    IID = global::WinRT.Interop.IID.IID_IBuffer,
                    Vtable = global::ABI.Windows.Storage.Streams.IBuffer.AbiToProjectionVftablePtr
                },
                new ComWrappers.ComInterfaceEntry
                {
                    IID = global::WinRT.Interop.IID.IID_IBufferByteAccess,
                    Vtable = global::ABI.Windows.Storage.Streams.IBufferByteAccess.Vftbl.AbiToProjectionVftablePtr
                },
                new ComWrappers.ComInterfaceEntry
                {
                    IID = global::WinRT.Interop.IID.IID_IMarshal,
                    Vtable = global::ABI.Com.IMarshal.Vftbl.AbiToProjectionVftablePtr
                }
            };
        }
    }
}
#endif

// WindowsRuntimeBuffer.cs

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.


namespace System.Runtime.InteropServices.WindowsRuntime
{
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using System.IO;
    using System.Threading;
    using System.Threading.Tasks;
    using global::Windows.Foundation;
    using global::Windows.Storage.Streams;
    using WinRT;
    /// <summary>
    /// Contains extension methods that expose operations on WinRT <code>Windows.Foundation.IBuffer</code>.
    /// </summary>
#if EMBED
    internal
#else
    public 
#endif 
    static class WindowsRuntimeBufferExtensions
    {
    #region (Byte []).AsBuffer extensions

            public static IBuffer AsBuffer(this byte[] source)
            {
                if (source == null) throw new ArgumentNullException(nameof(source));

                return AsBuffer(source, 0, source.Length, source.Length);
            }


            public static IBuffer AsBuffer(this byte[] source, int offset, int length)
            {
                if (source == null) throw new ArgumentNullException(nameof(source));
                if (offset < 0) throw new ArgumentOutOfRangeException(nameof(offset));
                if (length < 0) throw new ArgumentOutOfRangeException(nameof(length));
                if (source.Length - offset < length) throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InsufficientArrayElementsAfterOffset);

                return AsBuffer(source, offset, length, length);
            }


            public static IBuffer AsBuffer(this byte[] source, int offset, int length, int capacity)
            {
                if (source == null) throw new ArgumentNullException(nameof(source));
                if (offset < 0) throw new ArgumentOutOfRangeException(nameof(offset));
                if (length < 0) throw new ArgumentOutOfRangeException(nameof(length));
                if (capacity < 0) throw new ArgumentOutOfRangeException(nameof(capacity));
                if (source.Length - offset < length) throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InsufficientArrayElementsAfterOffset);
                if (source.Length - offset < capacity) throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InsufficientArrayElementsAfterOffset);
                if (capacity < length) throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InsufficientBufferCapacity);

                return new WindowsRuntimeBuffer(source, offset, length, capacity);
            }

    #endregion (Byte []).AsBuffer extensions


    #region (Span<Byte>).CopyTo extensions for copying to an (IBuffer)

            /// <summary>
            /// Copies the contents of <code>source</code> to <code>destination</code> starting at offset 0.
            /// This method does <em>NOT</em> update <code>destination.Length</code>.
            /// </summary>
            /// <param name="source">Span to copy data from.</param>
            /// <param name="destination">The buffer to copy to.</param>
            public static void CopyTo(this Span<byte> source, IBuffer destination)
            {
                if (source == null) throw new ArgumentNullException(nameof(source));
                if (destination == null) throw new ArgumentNullException(nameof(destination));

                CopyTo(source, destination, 0);
            }


            /// <summary>
            /// Copies <code>count</code> bytes from <code>source</code> starting at offset <code>sourceIndex</code>
            /// to <code>destination</code> starting at <code>destinationIndex</code>.
            /// This method does <em>NOT</em> update <code>destination.Length</code>.
            /// </summary>
            /// <param name="source">Span to copy data from.</param>
            /// <param name="sourceIndex">Position in the span from where to start copying.</param>
            /// <param name="destination">The buffer to copy to.</param>
            /// <param name="destinationIndex">Position in the buffer to where to start copying.</param>
            /// <param name="count">The number of bytes to copy.</param>
            public static void CopyTo(this Span<byte> source, IBuffer destination, uint destinationIndex)
            {
                if (destination == null) throw new ArgumentNullException(nameof(destination));
                if (destination.Capacity < destinationIndex) throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_BufferIndexExceedsCapacity);
                if (destination.Capacity - destinationIndex < source.Length) throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InsufficientSpaceInTargetBuffer);
                if (source.Length == 0) return;

                Debug.Assert(destinationIndex <= int.MaxValue);

                // If destination is backed by a managed memory, use the memory instead of the pointer as it does not require pinning:
                Span<byte> destSpan = destination.TryGetUnderlyingData(out byte[] destDataArr, out int destOffset) ? destDataArr.AsSpan(destOffset + (int)destinationIndex) : destination.GetSpanForCapacityUnsafe(destinationIndex);
                source.CopyTo(destSpan);

                // Ensure destination stays alive for the copy operation
                GC.KeepAlive(destination);

                // Update Length last to make sure the data is valid
                if (destinationIndex + source.Length > destination.Length)
                {
                    destination.Length = destinationIndex + (uint)source.Length;
                }
            }

    #endregion (Span<Byte>).CopyTo extensions for copying to an (IBuffer)

    #region (Byte []).CopyTo extensions for copying to an (IBuffer)

            /// <summary>
            /// Copies the contents of <code>source</code> to <code>destination</code> starting at offset 0.
            /// This method does <em>NOT</em> update <code>destination.Length</code>.
            /// </summary>
            /// <param name="source">Array to copy data from.</param>
            /// <param name="destination">The buffer to copy to.</param>
            public static void CopyTo(this byte[] source, IBuffer destination)
            {
                if (source == null) throw new ArgumentNullException(nameof(source));

                CopyTo(source.AsSpan(), destination, 0);
            }


            /// <summary>
            /// Copies <code>count</code> bytes from <code>source</code> starting at offset <code>sourceIndex</code>
            /// to <code>destination</code> starting at <code>destinationIndex</code>.
            /// This method does <em>NOT</em> update <code>destination.Length</code>.
            /// </summary>
            /// <param name="source">Array to copy data from.</param>
            /// <param name="sourceIndex">Position in the array from where to start copying.</param>
            /// <param name="destination">The buffer to copy to.</param>
            /// <param name="destinationIndex">Position in the buffer to where to start copying.</param>
            /// <param name="count">The number of bytes to copy.</param>
            public static void CopyTo(this byte[] source, int sourceIndex, IBuffer destination, uint destinationIndex, int count)
            {
                if (source == null) throw new ArgumentNullException(nameof(source));

                CopyTo(source.AsSpan(sourceIndex, count), destination, destinationIndex);
            }

    #endregion (Byte []).CopyTo extensions for copying to an (IBuffer)


    #region (IBuffer).ToArray extensions for copying to a new (Byte [])

            public static byte[] ToArray(this IBuffer source)
            {
                if (source == null) throw new ArgumentNullException(nameof(source));

                return ToArray(source, 0, checked((int)source.Length));
            }


            public static byte[] ToArray(this IBuffer source, uint sourceIndex, int count)
            {
                if (source == null) throw new ArgumentNullException(nameof(source));
                if (count < 0) throw new ArgumentOutOfRangeException(nameof(count));
                if (source.Length < sourceIndex) throw new ArgumentException("The specified buffer index is not within the buffer length.");
                if (source.Length - sourceIndex < count) throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InsufficientSpaceInSourceBuffer);

                if (count == 0)
                    return Array.Empty<byte>();

                byte[] destination = new byte[count];
                source.CopyTo(sourceIndex, destination, 0, count);
                return destination;
            }

    #endregion (IBuffer).ToArray extensions for copying to a new (Byte [])


    #region (IBuffer).CopyTo extensions for copying to a (Span<Byte>)

            public static void CopyTo(this IBuffer source, Span<byte> destination)
            {
                if (source == null) throw new ArgumentNullException(nameof(source));

                CopyTo(source, 0, destination, checked((int)source.Length));
            }

            public static void CopyTo(this IBuffer source, uint sourceIndex, Span<byte> destination, int count)
            {
                if (source == null) throw new ArgumentNullException(nameof(source));
                if (count < 0) throw new ArgumentOutOfRangeException(nameof(count));
                if (source.Length < sourceIndex) throw new ArgumentException("The specified buffer index is not within the buffer length.");
                if (source.Length - sourceIndex < count) throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InsufficientSpaceInSourceBuffer);
                if (destination.Length < count) throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InsufficientArrayElementsAfterOffset);
                if (count == 0) return;

                Debug.Assert(sourceIndex <= int.MaxValue);

                Span<byte> srcSpan = source.TryGetUnderlyingData(out byte[] srcDataArr, out int srcOffset) ? srcDataArr.AsSpan(srcOffset + (int)sourceIndex, count) : source.GetSpanForCapacityUnsafe(sourceIndex).Slice(0, (int)count);
                srcSpan.CopyTo(destination);

                // Ensure source and destination stay alive for the copy operation
                GC.KeepAlive(source);
            }

    #endregion (IBuffer).CopyTo extensions for copying to a (Span<Byte>)

    #region (IBuffer).CopyTo extensions for copying to a (Byte [])

            public static void CopyTo(this IBuffer source, byte[] destination)
            {
                if (source == null) throw new ArgumentNullException(nameof(source));
                if (destination == null) throw new ArgumentNullException(nameof(destination));

                CopyTo(source, destination.AsSpan());
            }

            public static void CopyTo(this IBuffer source, uint sourceIndex, byte[] destination, int destinationIndex, int count)
            {
                if (source == null) throw new ArgumentNullException(nameof(source));
                if (destination == null) throw new ArgumentNullException(nameof(destination));

                CopyTo(source, sourceIndex, destination.AsSpan(destinationIndex, count), count);
            }

    #endregion (IBuffer).CopyTo extensions for copying to a (Byte [])


    #region (IBuffer).CopyTo extensions for copying to an (IBuffer)

            public static void CopyTo(this IBuffer source, IBuffer destination)
            {
                if (source == null) throw new ArgumentNullException(nameof(source));
                if (destination == null) throw new ArgumentNullException(nameof(destination));

                CopyTo(source, 0, destination, 0, source.Length);
            }


            public static void CopyTo(this IBuffer source, uint sourceIndex, IBuffer destination, uint destinationIndex, uint count)
            {
                if (source == null) throw new ArgumentNullException(nameof(source));
                if (destination == null) throw new ArgumentNullException(nameof(destination));
                if (source.Length < sourceIndex) throw new ArgumentException("The specified buffer index is not within the buffer length.");
                if (source.Length - sourceIndex < count) throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InsufficientSpaceInSourceBuffer);
                if (destination.Capacity < destinationIndex) throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_BufferIndexExceedsCapacity);
                if (destination.Capacity - destinationIndex < count) throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InsufficientSpaceInTargetBuffer);
                if (count == 0) return;

                Debug.Assert(count <= int.MaxValue);
                Debug.Assert(sourceIndex <= int.MaxValue);
                Debug.Assert(destinationIndex <= int.MaxValue);

                // If source are destination are backed by managed arrays, use the arrays instead of the pointers as it does not require pinning:
                Span<byte> srcSpan = source.TryGetUnderlyingData(out byte[] srcDataArr, out int srcOffset) ? srcDataArr.AsSpan(srcOffset + (int)sourceIndex, (int)count) : source.GetSpanForCapacityUnsafe(sourceIndex).Slice(0, (int)count);
                Span<byte> destSpan = destination.TryGetUnderlyingData(out byte[] destDataArr, out int destOffset) ? destDataArr.AsSpan(destOffset + (int)destinationIndex) : destination.GetSpanForCapacityUnsafe(destinationIndex).Slice(0, (int)count);

                srcSpan.CopyTo(destSpan);

                // Ensure source and destination stay alive for the copy operation
                GC.KeepAlive(source);
                GC.KeepAlive(destination);

                // Update Length last to make sure the data is valid
                if (destinationIndex + count > destination.Length)
                {
                    destination.Length = destinationIndex + count;
                }
            }

    #endregion (IBuffer).CopyTo extensions for copying to an (IBuffer)


    #region Access to underlying array optimised for IBuffers backed by managed arrays (to avoid pinning)

            /// <summary>
            /// If the specified <code>IBuffer</code> is backed by a managed array, this method will return <code>true</code> and
            /// set <code>underlyingDataArray</code> to refer to that array
            /// and <code>underlyingDataArrayStartOffset</code> to the value at which the buffer data begins in that array.
            /// If the specified <code>IBuffer</code> is <em>not</em> backed by a managed array, this method will return <code>false</code>.
            /// This method is required by managed APIs that wish to use the buffer's data with other managed APIs that use
            /// arrays without a need for a memory copy.
            /// </summary>
            /// <param name="buffer">An <code>IBuffer</code>.</param>
            /// <param name="underlyingDataArray">Will be set to the data array backing <code>buffer</code> or to <code>null</code>.</param>
            /// <param name="underlyingDataArrayStartOffset">Will be set to the start offset of the buffer data in the backing array
            /// or to <code>-1</code>.</param>
            /// <returns>Whether the <code>IBuffer</code> is backed by a managed byte array.</returns>
            internal static bool TryGetUnderlyingData(this IBuffer buffer, out byte[] underlyingDataArray, out int underlyingDataArrayStartOffset)
            {
                if (buffer == null)
                    throw new ArgumentNullException(nameof(buffer));

                WindowsRuntimeBuffer winRtBuffer = buffer as WindowsRuntimeBuffer;
                if (winRtBuffer == null)
                {
                    underlyingDataArray = null;
                    underlyingDataArrayStartOffset = -1;
                    return false;
                }

                winRtBuffer.GetUnderlyingData(out underlyingDataArray, out underlyingDataArrayStartOffset);
                return true;
            }


            /// <summary>
            /// Checks if the underlying memory backing two <code>IBuffer</code> instances is actually the same memory.
            /// When applied to <code>IBuffer</code> instances backed by managed arrays this method is preferable to a naive comparison
            /// (such as <code>((IBufferByteAccess) buffer).Buffer == ((IBufferByteAccess) otherBuffer).Buffer</code>) because it avoids
            /// pinning the backing array which would be necessary if a direct memory pointer was obtained.
            /// </summary>
            /// <param name="buffer">An <code>IBuffer</code> instance.</param>
            /// <param name="otherBuffer">An <code>IBuffer</code> instance or <code>null</code>.</param>
            /// <returns><code>true</code> if the underlying <code>Buffer</code> memory pointer is the same for both specified
            /// <code>IBuffer</code> instances (i.e. if they are backed by the same memory); <code>false</code> otherwise.</returns>
            public static bool IsSameData(this IBuffer buffer, IBuffer otherBuffer)
            {
                if (buffer == null)
                    throw new ArgumentNullException(nameof(buffer));

                if (otherBuffer == null)
                    return false;

                if (buffer == otherBuffer)
                    return true;

                byte[] thisDataArr, otherDataArr;
                int thisDataOffs, otherDataOffs;

                bool thisIsManaged = buffer.TryGetUnderlyingData(out thisDataArr, out thisDataOffs);
                bool otherIsManaged = otherBuffer.TryGetUnderlyingData(out otherDataArr, out otherDataOffs);

                if (thisIsManaged != otherIsManaged)
                    return false;

                if (thisIsManaged)
                    return (thisDataArr == otherDataArr) && (thisDataOffs == otherDataOffs);

                if (!WindowsRuntimeMarshal.TryGetDataUnsafe(buffer, out IntPtr thisBuff) ||
                    !WindowsRuntimeMarshal.TryGetDataUnsafe(otherBuffer, out IntPtr otherBuff))
                {
                    return false;
                }

                return thisBuff == otherBuff;
            }

    #endregion Access to underlying array optimised for IBuffers backed by managed arrays (to avoid pinning)


    #region Extensions for co-operation with memory streams (share mem stream data; expose data as managed/unmanaged mem stream)
            /// <summary>
            /// Creates a new <code>IBuffer</code> instance backed by the same memory as is backing the specified <code>MemoryStream</code>.
            /// The <code>MemoryStream</code> may re-sized in future, as a result the stream will be backed by a different memory region.
            /// In such case, the buffer created by this method will remain backed by the memory behind the stream at the time the buffer was created.<br />
            /// This method can throw an <code>ObjectDisposedException</code> if the specified stream is closed.<br />
            /// This method can throw an <code>UnauthorizedAccessException</code> if the specified stream cannot expose its underlying memory buffer.
            /// </summary>
            /// <param name="underlyingStream">A memory stream to share the data memory with the buffer being created.</param>
            /// <returns>A new <code>IBuffer</code> backed by the same memory as this specified stream.</returns>
            // The naming inconsistency with (Byte []).AsBuffer is intentional: as this extension method will appear on
            // MemoryStream, consistency with method names on MemoryStream is more important. There we already have an API
            // called GetBuffer which returns the underlying array.
            public static IBuffer GetWindowsRuntimeBuffer(this MemoryStream underlyingStream)
            {
                if (underlyingStream == null)
                    throw new ArgumentNullException(nameof(underlyingStream));

                ArraySegment<byte> streamData;
                if (!underlyingStream.TryGetBuffer(out streamData))
                {
                    throw new UnauthorizedAccessException(global::Windows.Storage.Streams.SR.UnauthorizedAccess_InternalBuffer);
                }
                return new WindowsRuntimeBuffer(streamData.Array!, (int)streamData.Offset, (int)underlyingStream.Length, underlyingStream.Capacity);
            }


            /// <summary>
            /// Creates a new <code>IBuffer</code> instance backed by the same memory as is backing the specified <code>MemoryStream</code>.
            /// The <code>MemoryStream</code> may re-sized in future, as a result the stream will be backed by a different memory region.
            /// In such case buffer created by this method will remain backed by the memory behind the stream at the time the buffer was created.<br />
            /// This method can throw an <code>ObjectDisposedException</code> if the specified stream is closed.<br />
            /// This method can throw an <code>UnauthorizedAccessException</code> if the specified stream cannot expose its underlying memory buffer.
            /// The created buffer begins at position <code>positionInStream</code> in the stream and extends over up to <code>length</code> bytes.
            /// If the stream has less than <code>length</code> bytes after the specified starting position, the created buffer covers only as many
            /// bytes as available in the stream. In either case, the <code>Length</code> and the <code>Capacity</code> properties of the created
            /// buffer are set accordingly: <code>Capacity</code> - number of bytes between <code>positionInStream</code> and the stream capacity end,
            /// but not more than <code>length</code>; <code>Length</code> - number of bytes between <code>positionInStream</code> and the stream
            /// length end, or zero if <code>positionInStream</code> is beyond stream length end, but not more than <code>length</code>.
            /// </summary>
            /// <param name="underlyingStream">A memory stream to share the data memory with the buffer being created.</param>
            /// <param name="positionInStream">The position of the shared memory region.</param>
            /// <param name="length">The maximum size of the shared memory region.</param>
            /// <returns>A new <code>IBuffer</code> backed by the same memory as this specified stream.</returns>
            public static IBuffer GetWindowsRuntimeBuffer(this MemoryStream underlyingStream, int positionInStream, int length)
            {
                // The naming inconsistency with (Byte []).AsBuffer is intentional: as this extension method will appear on
                // MemoryStream, consistency with method names on MemoryStream is more important. There we already have an API
                // called GetBuffer which returns the underlying array.

                if (underlyingStream == null)
                    throw new ArgumentNullException(nameof(underlyingStream));

                if (positionInStream < 0)
                    throw new ArgumentOutOfRangeException(nameof(positionInStream));

                if (length < 0)
                    throw new ArgumentOutOfRangeException(nameof(length));

                if (underlyingStream.Length < positionInStream)
                    throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_StreamPositionBeyondEOS);

                ArraySegment<byte> streamData;

                if (!underlyingStream.TryGetBuffer(out streamData))
                {
                    throw new UnauthorizedAccessException(global::Windows.Storage.Streams.SR.UnauthorizedAccess_InternalBuffer);
                }

                int originInStream = streamData.Offset;
                int buffCapacity = Math.Min(length, underlyingStream.Capacity - positionInStream);
                int buffLength = Math.Max(0, Math.Min(length, ((int)underlyingStream.Length) - positionInStream));
                return new WindowsRuntimeBuffer(streamData.Array!, originInStream + positionInStream, buffLength, buffCapacity);
            }


            public static Stream AsStream(this IBuffer source)
            {
                if (source == null)
                    throw new ArgumentNullException(nameof(source));

                byte[] dataArr;
                int dataOffs;
                if (source.TryGetUnderlyingData(out dataArr, out dataOffs))
                {
                    Debug.Assert(source.Capacity < int.MaxValue);
                    return new WindowsRuntimeBufferMemoryStream(source, dataArr, dataOffs);
                }

                if (!WindowsRuntimeMarshal.TryGetDataUnsafe(source, out IntPtr sourceBuff))
                {
                    throw new InvalidCastException();
                }

                return new WindowsRuntimeBufferUnmanagedMemoryStream(source, sourceBuff);
            }

    #endregion Extensions for co-operation with memory streams (share mem stream data; expose data as managed/unmanaged mem stream)


    #region Extensions for direct by-offset access to buffer data elements

            public static byte GetByte(this IBuffer source, uint byteOffset)
            {
                if (source == null) throw new ArgumentNullException(nameof(source));
                if (source.Length <= byteOffset) throw new ArgumentException("The specified buffer offset is not within the buffer length.");

                byte[] srcDataArr;
                int srcDataOffs;
                if (source.TryGetUnderlyingData(out srcDataArr, out srcDataOffs))
                {
                    return srcDataArr[srcDataOffs + byteOffset];
                }

                Span<byte> srcSpan = source.GetSpanForCapacityUnsafe(byteOffset);
                byte value = srcSpan[0];

                // Ensure source stays alive while we read values.
                GC.KeepAlive(source);
                return value;
            }

            #endregion Extensions for direct by-offset access to buffer data elements


            #region Private plumbing

    #if NET
            private sealed class StreamWinRTTypeDetails : global::WinRT.IWinRTExposedTypeDetails
            {
                public ComWrappers.ComInterfaceEntry[] GetExposedInterfaces()
                {
                    return new ComWrappers.ComInterfaceEntry[]
                    {
                        new ComWrappers.ComInterfaceEntry
                        {
                            IID = global::ABI.System.IDisposableMethods.IID,
                            Vtable = global::ABI.System.IDisposableMethods.AbiToProjectionVftablePtr
                        },
                    };
                }
            }
    #endif

    #if NET
            [global::WinRT.WinRTExposedType(typeof(StreamWinRTTypeDetails))]
    #endif
            private sealed class WindowsRuntimeBufferMemoryStream : MemoryStream
            {
                private readonly IBuffer _sourceBuffer;

                internal WindowsRuntimeBufferMemoryStream(IBuffer sourceBuffer, byte[] dataArr, int dataOffs)
                    : base(dataArr, dataOffs, (int)sourceBuffer.Capacity, writable: true)
                {
                    _sourceBuffer = sourceBuffer;

                    SetLength((long)sourceBuffer.Length);
                }

                public override void SetLength(long value)
                {
                    base.SetLength(value);

                    // Length is limited by Capacity which should be a valid value.
                    // Therefore this cast is safe.
                    _sourceBuffer.Length = (uint)Length;
                }

                public override void Write(byte[] buffer, int offset, int count)
                {
                    base.Write(buffer, offset, count);

                    // Length is limited by Capacity which should be a valid value.
                    // Therefore this cast is safe.
                    _sourceBuffer.Length = (uint)Length;
                }

    #if NET
                public override void Write(ReadOnlySpan<byte> buffer)
                {
                    base.Write(buffer);

                    // Length is limited by Capacity which should be a valid value.
                    // Therefore this cast is safe.
                    _sourceBuffer.Length = (uint)Length;
                }
    #endif

                public override async Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
                {
                    await base.WriteAsync(buffer, offset, count, cancellationToken);
                    // Length is limited by Capacity which should be a valid value.
                    // Therefore this cast is safe.
                    _sourceBuffer.Length = (uint)Length;
                }

    #if NET
                public override async ValueTask WriteAsync(ReadOnlyMemory<byte> buffer, CancellationToken cancellationToken = default)
                {
                    await base.WriteAsync(buffer, cancellationToken);

                    // Length is limited by Capacity which should be a valid value.
                    // Therefore this cast is safe.
                    _sourceBuffer.Length = (uint)Length;
                }
    #endif

                public override void WriteByte(byte value)
                {
                    base.WriteByte(value);

                    // Length is limited by Capacity which should be a valid value.
                    // Therefore this cast is safe.
                    _sourceBuffer.Length = (uint)Length;
                }
            }  // class WindowsRuntimeBufferMemoryStream

    #if NET
            [global::WinRT.WinRTExposedType(typeof(StreamWinRTTypeDetails))]
    #endif
            private sealed class WindowsRuntimeBufferUnmanagedMemoryStream : UnmanagedMemoryStream
            {
                // We need this class because if we construct an UnmanagedMemoryStream on an IBuffer backed by native memory,
                // we must keep around a reference to the IBuffer from which we got the memory pointer. Otherwise the ref count
                // of the underlying COM object may drop to zero and the memory may get freed.

                private readonly IBuffer _sourceBuffer;

                internal unsafe WindowsRuntimeBufferUnmanagedMemoryStream(IBuffer sourceBuffer, IntPtr dataPtr)

                    : base((byte*)dataPtr, (long)sourceBuffer.Length, (long)sourceBuffer.Capacity, FileAccess.ReadWrite)
                {
                    _sourceBuffer = sourceBuffer;
                }

                public override void SetLength(long value)
                {
                    base.SetLength(value);

                    // Length is limited by Capacity which should be a valid value.
                    // Therefore this cast is safe.
                    _sourceBuffer.Length = (uint)Length;
                }

                public override void Write(byte[] buffer, int offset, int count)
                {
                    base.Write(buffer, offset, count);

                    // Length is limited by Capacity which should be a valid value.
                    // Therefore this cast is safe.
                    _sourceBuffer.Length = (uint)Length;
                }

    #if NET
                public override void Write(ReadOnlySpan<byte> buffer)
                {
                    base.Write(buffer);

                    // Length is limited by Capacity which should be a valid value.
                    // Therefore this cast is safe.
                    _sourceBuffer.Length = (uint)Length;
                }
    #endif

                public override async Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
                {
                    await base.WriteAsync(buffer, offset, count, cancellationToken);
                    // Length is limited by Capacity which should be a valid value.
                    // Therefore this cast is safe.
                    _sourceBuffer.Length = (uint)Length;
                }

    #if NET
                public override async ValueTask WriteAsync(ReadOnlyMemory<byte> buffer, CancellationToken cancellationToken = default)
                {
                    await base.WriteAsync(buffer, cancellationToken);

                    // Length is limited by Capacity which should be a valid value.
                    // Therefore this cast is safe.
                    _sourceBuffer.Length = (uint)Length;
                }
    #endif

                public override void WriteByte(byte value)
                {
                    base.WriteByte(value);

                    // Length is limited by Capacity which should be a valid value.
                    // Therefore this cast is safe.
                    _sourceBuffer.Length = (uint)Length;
                }
            }  // class WindowsRuntimeBufferUnmanagedMemoryStream

            private static unsafe Span<byte> GetSpanForCapacityUnsafe(this IBuffer buffer, uint offset)
            {
                Debug.Assert(0 <= offset);
                Debug.Assert(offset < buffer.Capacity);

                if (!WindowsRuntimeMarshal.TryGetDataUnsafe(buffer, out IntPtr buffPtr))
                {
                    throw new InvalidCastException();
                }

                var span = new Span<byte>((byte*)buffPtr + offset, (int)(buffer.Capacity - offset));
                GC.KeepAlive(buffer);
                return span;
            }
    #endregion Private plumbing
        }  // class WindowsRuntimeBufferExtensions
}  // namespace

// WindowsRuntimeBufferExtensions.cs

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

namespace System.Runtime.InteropServices.WindowsRuntime
{
    using System;
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using global::Windows.Foundation;
    using global::Windows.Storage.Streams;
    using WinRT;

#nullable enable
    /// <summary>
    /// An unsafe class that provides a set of methods to access the underlying data representations of WinRT types.
    /// </summary>
#if EMBED || !NET // for netstandard this type conflicts with the type in the BCL so make it internal
    internal
#else
    public
#endif
    static partial class WindowsRuntimeMarshal
    {
        /// <summary>
        /// Returns a pointer to the underlying data representation of the <see cref="IBuffer"/>.
        /// Callers are responsible for ensuring that the buffer is kept alive while the pointer is in use.
        /// </summary>
        /// <param name="buffer">The buffer to get the data pointer for.</param>
        /// <param name="dataPtr">The pointer to the underlying data representation of the buffer.</param>
        /// <returns>Whether the data was successfully retrieved.</returns>
        /// <exception cref="Exception">Thrown if invoking <c>IBufferByteAccess::Buffer</c> on the input buffer fails.</exception>
        public static unsafe bool TryGetDataUnsafe(
#if NET
            [NotNullWhen(true)]
#endif
            IBuffer? buffer, out IntPtr dataPtr)
        {
            if (buffer == null)
            {
                dataPtr = IntPtr.Zero;
                return false;
            }

            if (ComWrappersSupport.TryUnwrapObject(buffer, out var unwrapped) &&
                unwrapped.TryAs(global::WinRT.Interop.IID.IID_IBufferByteAccess, out IntPtr ThisPtr) >= 0)
            {
                try
                {
                    IntPtr __retval = default;
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>**)ThisPtr)[3](ThisPtr, &__retval));
                    dataPtr = __retval;
                    return true;
                }
                finally
                {
                    Marshal.Release(ThisPtr);
                }
            }

            if (buffer is IBufferByteAccess managedBuffer)
            {
                dataPtr = managedBuffer.Buffer;
                return true;
            }

            dataPtr = IntPtr.Zero;
            return false;
        }

        /// <summary>
        /// Returns a pointer to the underlying data representation of the <see cref="IMemoryBufferReference"/>.
        /// Callers are responsible for ensuring that the buffer is kept alive while the pointer is in use.
        /// </summary>
        /// <param name="buffer">The buffer to get the data pointer for.</param>
        /// <param name="dataPtr">The pointer to the underlying data representation of the buffer.</param>
        /// <param name="capacity">The capacity of the buffer.</param>
        /// <returns>Whether the data was successfully retrieved.</returns>
        /// <exception cref="Exception">Thrown if invoking <c>IMemoryBufferByteAccess::Buffer</c> on the input buffer fails.</exception>
        public static unsafe bool TryGetDataUnsafe(
#if NET
            [NotNullWhen(true)]
#endif
            IMemoryBufferReference? buffer, out IntPtr dataPtr, out uint capacity)
        {
            if (buffer == null)
            {
                dataPtr = IntPtr.Zero;
                capacity = 0;
                return false;
            }

            if (ComWrappersSupport.TryUnwrapObject(buffer, out var unwrapped) &&
                unwrapped.TryAs(global::WinRT.Interop.IID.IID_IMemoryBufferByteAccess, out IntPtr ThisPtr) >= 0)
            {
                try
                {
                    IntPtr __retval = default;
                    uint __capacity = 0;
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, uint*, int>**)ThisPtr)[3](ThisPtr, &__retval, &__capacity));
                    dataPtr = __retval;
                    capacity = __capacity;
                    return true;
                }
                finally
                {
                    Marshal.Release(ThisPtr);
                }
            }

            dataPtr = IntPtr.Zero;
            capacity = 0;
            return false;
        }

        /// <summary>
        /// Tries to get an array segment from the underlying buffer. The return value indicates the success of the operation.
        /// </summary>
        /// <param name="buffer">The buffer to get the array segment for.</param>
        /// <param name="array">When this method returns, contains the array segment retrieved from the underlying  buffer. If the method fails, the method returns a default array segment.</param>
        public static bool TryGetArray(
#if NET
            [NotNullWhen(true)]
# endif
            IBuffer? buffer, out ArraySegment<byte> array)
        {
            if (buffer == null)
            {
                array = default;
                return false;
            }

            // If buffer is backed by a managed array, return it
            if (buffer.TryGetUnderlyingData(out byte[]? srcDataArr, out int srcDataOffs))
            {
                array = new ArraySegment<byte>(srcDataArr, offset: srcDataOffs, count: (int)buffer.Length);
                return true;
            }

            array = default;
            return false;
        }
    }  // class WindowsRuntimeMarshal
#nullable restore
}  // namespace

// WindowsRuntimeMarshal.cs

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.


namespace System.IO
{
    using System.ComponentModel;
    using System.Diagnostics;
#if NET
    using System.Diagnostics.CodeAnalysis;
#endif
    using System.IO;
    using System.Runtime.CompilerServices;
    using System.Runtime.InteropServices;
    using System.Threading.Tasks;
    using global::Windows.Foundation;
    using global::Windows.Storage.Streams;
    /// <summary>
    /// Contains extension methods for conversion between WinRT streams and managed streams.
    /// This class is the public facade for the stream adapters library.
    /// </summary>
#if EMBED
    internal
#else
    public
#endif
    static class WindowsRuntimeStreamExtensions
    {
        #region Constants and static Fields

        private const int DefaultBufferSize = 16384;  // = 0x4000 = 16 KBytes.

        private static readonly ConditionalWeakTable<object, Stream> s_winRtToNetFxAdapterMap
                 = new ConditionalWeakTable<object, Stream>();

        private static readonly ConditionalWeakTable<Stream, NetFxToWinRtStreamAdapter> s_netFxToWinRtAdapterMap
                 = new ConditionalWeakTable<Stream, NetFxToWinRtStreamAdapter>();

        #endregion Constants and static Fields


#if NET

        #region Helpers

#if DEBUG
        private static void AssertMapContains<TKey, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicParameterlessConstructor)] TValue>(
            ConditionalWeakTable<TKey, TValue> map,
            TKey key,
            TValue value,
            bool valueMayBeWrappedInBufferedStream)
            where TKey : class
            where TValue : class
        {
            TValue valueInMap;

            Debug.Assert(key != null);

            bool hasValueForKey = map.TryGetValue(key, out valueInMap);

            Debug.Assert(hasValueForKey);

            if (valueMayBeWrappedInBufferedStream)
            {
                BufferedStream bufferedValueInMap = valueInMap as BufferedStream;
                Debug.Assert(object.ReferenceEquals(value, valueInMap)
                                || (bufferedValueInMap != null && object.ReferenceEquals(value, bufferedValueInMap.UnderlyingStream)));
            }
            else
            {
                Debug.Assert(object.ReferenceEquals(value, valueInMap));
            }
        }
#endif  // DEBUG

        #endregion Helpers

        private static void EnsureAdapterBufferSize(Stream adapter, int requiredBufferSize, string methodName)
        {
            Debug.Assert(adapter != null);
            Debug.Assert(!string.IsNullOrWhiteSpace(methodName));

            int currentBufferSize = 0;
            BufferedStream bufferedAdapter = adapter as BufferedStream;
            if (bufferedAdapter != null)
                currentBufferSize = bufferedAdapter.BufferSize;

            if (requiredBufferSize != currentBufferSize)
            {
                if (requiredBufferSize == 0)
                    throw new InvalidOperationException(string.Format(global::Windows.Storage.Streams.SR.InvalidOperation_CannotChangeBufferSizeOfWinRtStreamAdapterToZero, methodName));

                throw new InvalidOperationException(string.Format(global::Windows.Storage.Streams.SR.InvalidOperation_CannotChangeBufferSizeOfWinRtStreamAdapter, methodName));
            }
        }


        #region WinRt-to-NetFx conversion

        public static Stream AsStreamForRead(this IInputStream windowsruntimeStream)
        {
            return AsStreamInternal(windowsruntimeStream, DefaultBufferSize, "AsStreamForRead", forceBufferSize: false);
        }


        public static Stream AsStreamForRead(this IInputStream windowsruntimeStream, int bufferSize)
        {
            return AsStreamInternal(windowsruntimeStream, bufferSize, "AsStreamForRead", forceBufferSize: true);
        }


        public static Stream AsStreamForWrite(this IOutputStream windowsruntimeStream)
        {
            return AsStreamInternal(windowsruntimeStream, DefaultBufferSize, "AsStreamForWrite", forceBufferSize: false);
        }


        public static Stream AsStreamForWrite(this IOutputStream windowsruntimeStream, int bufferSize)
        {
            return AsStreamInternal(windowsruntimeStream, bufferSize, "AsStreamForWrite", forceBufferSize: true);
        }


        public static Stream AsStream(this IRandomAccessStream windowsruntimeStream)
        {
            return AsStreamInternal(windowsruntimeStream, DefaultBufferSize, "AsStream", forceBufferSize: false);
        }


        public static Stream AsStream(this IRandomAccessStream windowsruntimeStream, int bufferSize)
        {
            return AsStreamInternal(windowsruntimeStream, bufferSize, "AsStream", forceBufferSize: true);
        }


        private static Stream AsStreamInternal(object windowsruntimeStream, int bufferSize, string invokedMethodName, bool forceBufferSize)
        {
            if (windowsruntimeStream == null)
                throw new ArgumentNullException(nameof(windowsruntimeStream));

            if (bufferSize < 0)
                throw new ArgumentOutOfRangeException(nameof(bufferSize), global::Windows.Storage.Streams.SR.ArgumentOutOfRange_WinRtAdapterBufferSizeMayNotBeNegative);

            Debug.Assert(!string.IsNullOrWhiteSpace(invokedMethodName));

            // If the WinRT stream is actually a wrapped managed stream, we will unwrap it and return the original.
            // In that case we do not need to put the wrapper into the map.

            // We currently do capability-based adapter selection for WinRt->NetFx, but not vice versa (time constraints).
            // Once we added the reverse direction, we will be able replce this entire section with just a few lines.
            NetFxToWinRtStreamAdapter sAdptr = windowsruntimeStream as NetFxToWinRtStreamAdapter;
            if (sAdptr != null)
            {
                Stream wrappedNetFxStream = sAdptr.GetManagedStream();
                if (wrappedNetFxStream == null)
                    throw new ObjectDisposedException(nameof(windowsruntimeStream), global::Windows.Storage.Streams.SR.ObjectDisposed_CannotPerformOperation);

#if DEBUG  // In Chk builds, verify that the original managed stream is correctly entered into the NetFx->WinRT map:
                AssertMapContains(s_netFxToWinRtAdapterMap, wrappedNetFxStream, sAdptr,
                                  valueMayBeWrappedInBufferedStream: false);
#endif  // DEBUG

                return wrappedNetFxStream;
            }

            // We have a real WinRT stream.

            Stream adapter;
            bool adapterExists = s_winRtToNetFxAdapterMap.TryGetValue(windowsruntimeStream, out adapter);

            // There is already an adapter:
            if (adapterExists)
            {
                Debug.Assert((adapter is BufferedStream && ((BufferedStream)adapter).UnderlyingStream is WinRtToNetFxStreamAdapter)
                                || (adapter is WinRtToNetFxStreamAdapter));

                if (forceBufferSize)
                    EnsureAdapterBufferSize(adapter, bufferSize, invokedMethodName);

                return adapter;
            }

            // We do not have an adapter for this WinRT stream yet and we need to create one.
            // Do that in a thread-safe manner in a separate method such that we only have to pay for the compiler allocating
            // the required closure if this code path is hit:

            return AsStreamInternalFactoryHelper(windowsruntimeStream, bufferSize, invokedMethodName, forceBufferSize);
        }


        // Separate method so we only pay for closure allocation if this code is executed:
        private static Stream WinRtToNetFxAdapterMap_GetValue(object winRtStream)
        {
            return s_winRtToNetFxAdapterMap.GetValue(winRtStream, (wrtStr) => WinRtToNetFxStreamAdapter.Create(wrtStr));
        }


        // Separate method so we only pay for closure allocation if this code is executed:
        private static Stream WinRtToNetFxAdapterMap_GetValue(object winRtStream, int bufferSize)
        {
            return s_winRtToNetFxAdapterMap.GetValue(winRtStream, (wrtStr) => new BufferedStream(WinRtToNetFxStreamAdapter.Create(wrtStr), bufferSize));
        }


        private static Stream AsStreamInternalFactoryHelper(object windowsruntimeStream, int bufferSize, string invokedMethodName, bool forceBufferSize)
        {
            Debug.Assert(windowsruntimeStream != null);
            Debug.Assert(bufferSize >= 0);
            Debug.Assert(!string.IsNullOrWhiteSpace(invokedMethodName));

            // Get the adapter for this windowsruntimeStream again (it may have been created concurrently).
            // If none exists yet, create a new one:
            Stream adapter = (bufferSize == 0)
                                ? WinRtToNetFxAdapterMap_GetValue(windowsruntimeStream)
                                : WinRtToNetFxAdapterMap_GetValue(windowsruntimeStream, bufferSize);

            Debug.Assert(adapter != null);
            Debug.Assert((adapter is BufferedStream && ((BufferedStream)adapter).UnderlyingStream is WinRtToNetFxStreamAdapter)
                                || (adapter is WinRtToNetFxStreamAdapter));

            if (forceBufferSize)
                EnsureAdapterBufferSize(adapter, bufferSize, invokedMethodName);

            WinRtToNetFxStreamAdapter actualAdapter = adapter as WinRtToNetFxStreamAdapter;
            if (actualAdapter == null)
                actualAdapter = ((BufferedStream)adapter).UnderlyingStream as WinRtToNetFxStreamAdapter;

            actualAdapter!.SetWonInitializationRace();

            return adapter;
        }

        #endregion WinRt-to-NetFx conversion

        #region NetFx-to-WinRt conversion

        public static IInputStream AsInputStream(this Stream stream)
        {
            if (stream == null)
                throw new ArgumentNullException(nameof(stream));

            if (!stream.CanRead)
                throw new NotSupportedException(global::Windows.Storage.Streams.SR.NotSupported_CannotConvertNotReadableToInputStream);

            object adapter = AsWindowsRuntimeStreamInternal(stream);

            IInputStream winRtStream = adapter as IInputStream;
            Debug.Assert(winRtStream != null);

            return winRtStream;
        }


        public static IOutputStream AsOutputStream(this Stream stream)
        {
            if (stream == null)
                throw new ArgumentNullException(nameof(stream));

            if (!stream.CanWrite)
                throw new NotSupportedException(global::Windows.Storage.Streams.SR.NotSupported_CannotConvertNotWritableToOutputStream);

            object adapter = AsWindowsRuntimeStreamInternal(stream);

            IOutputStream winRtStream = adapter as IOutputStream;
            Debug.Assert(winRtStream != null);

            return winRtStream;
        }


        public static IRandomAccessStream AsRandomAccessStream(this Stream stream)
        {
            if (stream == null)
                throw new ArgumentNullException(nameof(stream));

            if (!stream.CanSeek)
                throw new NotSupportedException(global::Windows.Storage.Streams.SR.NotSupported_CannotConvertNotSeekableToRandomAccessStream);

            object adapter = AsWindowsRuntimeStreamInternal(stream);

            IRandomAccessStream winRtStream = adapter as IRandomAccessStream;
            Debug.Assert(winRtStream != null);

            return winRtStream;
        }


        private static object AsWindowsRuntimeStreamInternal(Stream stream)
        {
            // Check to see if the managed stream is actually a wrapper of a WinRT stream:
            // (This can be either an adapter directly, or an adapter wrapped in a BufferedStream.)
            WinRtToNetFxStreamAdapter sAdptr = stream as WinRtToNetFxStreamAdapter;
            if (sAdptr == null)
            {
                BufferedStream buffAdptr = stream as BufferedStream;
                if (buffAdptr != null)
                    sAdptr = buffAdptr.UnderlyingStream as WinRtToNetFxStreamAdapter;
            }

            // If the managed stream us actually a WinRT stream, we will unwrap it and return the original.
            // In that case we do not need to put the wrapper into the map.
            if (sAdptr != null)
            {
                object wrappedWinRtStream = sAdptr.GetWindowsRuntimeStream<object>();
                if (wrappedWinRtStream == null)
                    throw new ObjectDisposedException(nameof(stream), global::Windows.Storage.Streams.SR.ObjectDisposed_CannotPerformOperation);

#if DEBUG  // In Chk builds, verify that the original WinRT stream is correctly entered into the WinRT->NetFx map:
                AssertMapContains(s_winRtToNetFxAdapterMap, wrappedWinRtStream, sAdptr, valueMayBeWrappedInBufferedStream: true);
#endif  // DEBUG
                return wrappedWinRtStream;
            }

            // We have a real managed Stream.

            // See if the managed stream already has an adapter:
            NetFxToWinRtStreamAdapter adapter;
            bool adapterExists = s_netFxToWinRtAdapterMap.TryGetValue(stream, out adapter);

            // There is already an adapter:
            if (adapterExists)
                return adapter!;

            // We do not have an adapter for this managed stream yet and we need to create one.
            // Do that in a thread-safe manner in a separate method such that we only have to pay for the compiler allocating
            // the required closure if this code path is hit:
            return AsWindowsRuntimeStreamInternalFactoryHelper(stream);
        }


        private static NetFxToWinRtStreamAdapter AsWindowsRuntimeStreamInternalFactoryHelper(Stream stream)
        {
            Debug.Assert(stream != null);

            // Get the adapter for managed stream again (it may have been created concurrently).
            // If none exists yet, create a new one:
            NetFxToWinRtStreamAdapter adapter = s_netFxToWinRtAdapterMap.GetValue(stream, (str) => NetFxToWinRtStreamAdapter.Create(str));

            Debug.Assert(adapter != null);
            adapter.SetWonInitializationRace();

            return adapter;
        }
        #endregion NetFx-to-WinRt conversion

#endif

    }  // class WindowsRuntimeStreamExtensions
}  // namespace

// WindowsRuntimeStreamExtensions.cs

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.


namespace Windows.Storage.Streams
{
    using global::System.Diagnostics;
    using global::System.IO;
    using global::System.Runtime.ExceptionServices;
    
    using global::System.Runtime.InteropServices;
    using global::System.Runtime.InteropServices.WindowsRuntime;
    internal static class WinRtIOHelper
    {
        internal const int DefaultIOBufferSize = 0x3000;  // = 12 KBytes = 12288 Bytes


        internal static ExceptionDispatchInfo NativeExceptionToIOExceptionInfo(Exception nativeException)
        {
            // If the interop layer gave us a specific exception type, we assume it knew what it was doing.
            // If it gave us an ExternalException or a generic Exception, we assume that it hit a
            // general/unknown case and wrap it into an IOException as this is what Stream users expect.

            // We will return a captured ExceptionDispatchInfo such that we can invoke .Throw() close to where
            // nativeException was caught - this will result in the most readable call stack.

            Debug.Assert(nativeException != null);

            if (!(nativeException.GetType().Equals(typeof(Exception)) /*|| nativeException is ExternalException */))
                return ExceptionDispatchInfo.Capture(nativeException);

            // If we do not have a meaningful message, we use a general IO error message:
            string message = nativeException.Message;
            if (string.IsNullOrWhiteSpace(message))
                message = global::Windows.Storage.Streams.SR.IO_General;

            return ExceptionDispatchInfo.Capture(new IOException(message, nativeException));
        }


        internal static void EnsureResultsInUserBuffer(IBuffer userBuffer, IBuffer resultBuffer)
        {
            // Results buffer may be different from user specified buffer. If so - copy data to the user.

            Debug.Assert(userBuffer != null);
            Debug.Assert(resultBuffer != null);

            if (resultBuffer.IsSameData(userBuffer))
                return;

            resultBuffer.CopyTo(userBuffer);
            userBuffer.Length = resultBuffer.Length;
        }
    }  // class WinRtIOHelper
}  // namespace

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.


namespace Windows.Storage.Streams
{
    using global::System.Diagnostics;
    using global::System.Diagnostics.Contracts;
    using global::System.IO;
    using global::System.Runtime.InteropServices;
    using global::System.Runtime.InteropServices.WindowsRuntime;
    using global::System.Threading.Tasks;
    using global::System.Threading;
    using Windows.Foundation;
    using global::System.Diagnostics.CodeAnalysis;
    /// <summary>
    /// A <code>Stream</code> used to wrap a Windows Runtime stream to expose it as a managed steam.
    /// </summary>
    internal sealed class WinRtToNetFxStreamAdapter : Stream, IDisposable
    {
        #region Construction

        internal static WinRtToNetFxStreamAdapter Create(object windowsruntimeStream)
        {
            if (windowsruntimeStream == null)
                throw new ArgumentNullException(nameof(windowsruntimeStream));

            bool canRead = windowsruntimeStream is IInputStream;
            bool canWrite = windowsruntimeStream is IOutputStream;
            bool canSeek = windowsruntimeStream is IRandomAccessStream;

            if (!canRead && !canWrite && !canSeek)
                throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_ObjectMustBeWinRtStreamToConvertToNetFxStream);

            // Proactively guard against a non-conforming curstomer implementations:
            if (canSeek)
            {
                IRandomAccessStream iras = (IRandomAccessStream)windowsruntimeStream;

                if (!canRead && iras.CanRead)
                    throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InstancesImplementingIRASThatCanReadMustImplementIIS);

                if (!canWrite && iras.CanWrite)
                    throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InstancesImplementingIRASThatCanWriteMustImplementIOS);

                if (!iras.CanRead)
                    canRead = false;

                if (!iras.CanWrite)
                    canWrite = false;
            }

            if (!canRead && !canWrite)
                throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_WinRtStreamCannotReadOrWrite);

            return new WinRtToNetFxStreamAdapter(windowsruntimeStream, canRead, canWrite, canSeek);
        }


        private WinRtToNetFxStreamAdapter(object winRtStream, bool canRead, bool canWrite, bool canSeek)
        {
            Debug.Assert(winRtStream != null);
            Debug.Assert(winRtStream is IInputStream || winRtStream is IOutputStream || winRtStream is IRandomAccessStream);

            Debug.Assert((canSeek && (winRtStream is IRandomAccessStream)) || (!canSeek && !(winRtStream is IRandomAccessStream)));

            Debug.Assert((canRead && (winRtStream is IInputStream))
                                 ||
                               (!canRead && (
                                    !(winRtStream is IInputStream)
                                        ||
                                    (winRtStream is IRandomAccessStream && !((IRandomAccessStream)winRtStream).CanRead)
                               ))
                             );

            Debug.Assert((canWrite && (winRtStream is IOutputStream))
                                 ||
                               (!canWrite && (
                                    !(winRtStream is IOutputStream)
                                        ||
                                    (winRtStream is IRandomAccessStream && !((IRandomAccessStream)winRtStream).CanWrite)
                               ))
                             );

            _winRtStream = winRtStream;
            _canRead = canRead;
            _canWrite = canWrite;
            _canSeek = canSeek;
        }

        #endregion Construction


        #region Instance variables

        private byte[] _oneByteBuffer = null;
        private bool _leaveUnderlyingStreamOpen = true;

        private object _winRtStream;
        private readonly bool _canRead;
        private readonly bool _canWrite;
        private readonly bool _canSeek;

        #endregion Instance variables


        #region Tools and Helpers

        /// <summary>
        /// We keep tables for mappings between managed and WinRT streams to make sure to always return the same adapter for a given underlying stream.
        /// However, in order to avoid global locks on those tables, several instances of this type may be created and then can race to be entered
        /// into the appropriate map table. All except for the winning instances will be thrown away. However, we must ensure that when the losers  are
        /// finalized, the do not dispose the underlying stream. To ensure that, we must call this method on the winner to notify it that it is safe to
        /// dispose the underlying stream.
        /// </summary>
        internal void SetWonInitializationRace()
        {
            _leaveUnderlyingStreamOpen = false;
        }


        public TWinRtStream GetWindowsRuntimeStream<TWinRtStream>() where TWinRtStream : class
        {
            object wrtStr = _winRtStream;

            if (wrtStr == null)
                return null;

            Debug.Assert(wrtStr is TWinRtStream,
                $"Attempted to get the underlying WinRT stream typed as \"{typeof(TWinRtStream)}\", " +
                $"but the underlying WinRT stream cannot be cast to that type. Its actual type is \"{wrtStr.GetType()}\".");

            return wrtStr as TWinRtStream;
        }


        private byte[] OneByteBuffer
        {
            get
            {
                byte[] obb = _oneByteBuffer;
                if (obb == null)  // benign race for multiple init
                    _oneByteBuffer = obb = new byte[1];
                return obb;
            }
        }

        private TWinRtStream EnsureNotDisposed<TWinRtStream>() where TWinRtStream : class
        {
            object wrtStr = _winRtStream;

            if (wrtStr == null)
                throw new ObjectDisposedException(global::Windows.Storage.Streams.SR.ObjectDisposed_CannotPerformOperation);

            return (wrtStr as TWinRtStream);
        }


        private void EnsureNotDisposed()
        {
            if (_winRtStream == null)
                throw new ObjectDisposedException(global::Windows.Storage.Streams.SR.ObjectDisposed_CannotPerformOperation);
        }


        private void EnsureCanRead()
        {
            if (!_canRead)
                throw new NotSupportedException(global::Windows.Storage.Streams.SR.NotSupported_CannotReadFromStream);
        }


        private void EnsureCanWrite()
        {
            if (!_canWrite)
                throw new NotSupportedException(global::Windows.Storage.Streams.SR.NotSupported_CannotWriteToStream);
        }

        #endregion Tools and Helpers


        #region Simple overrides

        protected override void Dispose(bool disposing)
        {
            // WinRT streams should implement IDisposable (IClosable in WinRT), but let's be defensive:
            if (disposing && _winRtStream != null && !_leaveUnderlyingStreamOpen)
            {
                IDisposable disposableWinRtStream = _winRtStream as IDisposable;  // benign race on winRtStream
                if (disposableWinRtStream != null)
                    disposableWinRtStream.Dispose();
            }

            _winRtStream = null;
            base.Dispose(disposing);
        }


        public override bool CanRead
        {
            [Pure]
            get
            { return (_canRead && _winRtStream != null); }
        }


        public override bool CanWrite
        {
            [Pure]
            get
            { return (_canWrite && _winRtStream != null); }
        }


        public override bool CanSeek
        {
            [Pure]
            get
            { return (_canSeek && _winRtStream != null); }
        }

        #endregion Simple overrides


        #region Length and Position functions

        public override long Length
        {
            get
            {
                IRandomAccessStream wrtStr = EnsureNotDisposed<IRandomAccessStream>();

                if (!_canSeek)
                    throw new NotSupportedException(global::Windows.Storage.Streams.SR.NotSupported_CannotUseLength_StreamNotSeekable);

                Debug.Assert(wrtStr != null);

                ulong size = wrtStr.Size;

                // These are over 8000 PetaBytes, we do not expect this to happen. However, let's be defensive:
                if (size > (ulong)long.MaxValue)
                    throw new IOException(global::Windows.Storage.Streams.SR.IO_UnderlyingWinRTStreamTooLong_CannotUseLengthOrPosition);

                return unchecked((long)size);
            }
        }


        public override long Position
        {
            get
            {
                IRandomAccessStream wrtStr = EnsureNotDisposed<IRandomAccessStream>();

                if (!_canSeek)
                    throw new NotSupportedException(global::Windows.Storage.Streams.SR.NotSupported_CannotUsePosition_StreamNotSeekable);

                Debug.Assert(wrtStr != null);

                ulong pos = wrtStr.Position;

                // These are over 8000 PetaBytes, we do not expect this to happen. However, let's be defensive:
                if (pos > (ulong)long.MaxValue)
                    throw new IOException(global::Windows.Storage.Streams.SR.IO_UnderlyingWinRTStreamTooLong_CannotUseLengthOrPosition);

                return unchecked((long)pos);
            }

            set
            {
                if (value < 0)
                    throw new ArgumentOutOfRangeException(nameof(Position), global::Windows.Storage.Streams.SR.ArgumentOutOfRange_IO_CannotSeekToNegativePosition);

                IRandomAccessStream wrtStr = EnsureNotDisposed<IRandomAccessStream>();

                if (!_canSeek)
                    throw new NotSupportedException(global::Windows.Storage.Streams.SR.NotSupported_CannotUsePosition_StreamNotSeekable);

                Debug.Assert(wrtStr != null);

                wrtStr.Seek(unchecked((ulong)value));
            }
        }


        public override long Seek(long offset, SeekOrigin origin)
        {
            IRandomAccessStream wrtStr = EnsureNotDisposed<IRandomAccessStream>();

            if (!_canSeek)
                throw new NotSupportedException(global::Windows.Storage.Streams.SR.NotSupported_CannotSeekInStream);

            Debug.Assert(wrtStr != null);

            switch (origin)
            {
                case SeekOrigin.Begin:
                    {
                        Position = offset;
                        return offset;
                    }

                case SeekOrigin.Current:
                    {
                        long curPos = Position;

                        if (long.MaxValue - curPos < offset)
                            throw new IOException(global::Windows.Storage.Streams.SR.IO_CannotSeekBeyondInt64MaxValue);

                        long newPos = curPos + offset;

                        if (newPos < 0)
                            throw new IOException(global::Windows.Storage.Streams.SR.ArgumentOutOfRange_IO_CannotSeekToNegativePosition);

                        Position = newPos;
                        return newPos;
                    }

                case SeekOrigin.End:
                    {
                        ulong size = wrtStr.Size;
                        long newPos;

                        if (size > (ulong)long.MaxValue)
                        {
                            if (offset >= 0)
                                throw new IOException(global::Windows.Storage.Streams.SR.IO_CannotSeekBeyondInt64MaxValue);

                            Debug.Assert(offset < 0);

                            ulong absOffset = (offset == long.MinValue) ? ((ulong)long.MaxValue) + 1 : (ulong)(-offset);
                            Debug.Assert(absOffset <= size);

                            ulong np = size - absOffset;
                            if (np > (ulong)long.MaxValue)
                                throw new IOException(global::Windows.Storage.Streams.SR.IO_CannotSeekBeyondInt64MaxValue);

                            newPos = (long)np;
                        }
                        else
                        {
                            Debug.Assert(size <= (ulong)long.MaxValue);

                            long s = unchecked((long)size);

                            if (long.MaxValue - s < offset)
                                throw new IOException(global::Windows.Storage.Streams.SR.IO_CannotSeekBeyondInt64MaxValue);

                            newPos = s + offset;

                            if (newPos < 0)
                                throw new IOException(global::Windows.Storage.Streams.SR.ArgumentOutOfRange_IO_CannotSeekToNegativePosition);
                        }

                        Position = newPos;
                        return newPos;
                    }

                default:
                    {
                        throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InvalidSeekOrigin, nameof(origin));
                    }
            }
        }


        public override void SetLength(long value)
        {
            if (value < 0)
                throw new ArgumentOutOfRangeException(nameof(value), global::Windows.Storage.Streams.SR.ArgumentOutOfRange_CannotResizeStreamToNegative);

            IRandomAccessStream wrtStr = EnsureNotDisposed<IRandomAccessStream>();

            if (!_canSeek)
                throw new NotSupportedException(global::Windows.Storage.Streams.SR.NotSupported_CannotSeekInStream);

            EnsureCanWrite();

            Debug.Assert(wrtStr != null);

            wrtStr.Size = unchecked((ulong)value);

            // If the length is set to a value < that the current position, then we need to set the position to that value
            // Because we can't directly set the position, we are going to seek to it.
            if (wrtStr.Size < wrtStr.Position)
                wrtStr.Seek(unchecked((ulong)value));
        }

        #endregion Length and Position functions


        #region Reading

#if NET
        [global::System.Runtime.Versioning.SupportedOSPlatform("windows10.0.10240.0")]
#endif
        private IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback callback, object state, bool usedByBlockingWrapper)
        {
            // This method is somewhat tricky: We could consider just calling ReadAsync (recall that Task implements IAsyncResult).
            // It would be OK for cases where BeginRead is invoked directly by the public user.
            // However, in cases where it is invoked by Read to achieve a blocking (synchronous) IO operation, the ReadAsync-approach may deadlock:
            //
            // The sync-over-async IO operation will be doing a blocking wait on the completion of the async IO operation assuming that
            // a wait handle would be signalled by the completion handler. Recall that the IAsyncInfo representing the IO operation may
            // not be free-threaded and not "free-marshalled"; it may also belong to an ASTA compartment because the underlying WinRT
            // stream lives in an ASTA compartment. The completion handler is invoked on a pool thread, i.e. in MTA.
            // That handler needs to fetch the results from the async IO operation, which requires a cross-compartment call from MTA into ASTA.
            // But because the ASTA thread is busy waiting this call will deadlock.
            // (Recall that although WaitOne pumps COM, ASTA specifically schedules calls on the outermost ?idle? pump only.)
            //
            // The solution is to make sure that:
            //  - In cases where main thread is waiting for the async IO to complete:
            //    Fetch results on the main thread after it has been signalled by the completion callback.
            //  - In cases where main thread is not waiting for the async IO to complete:
            //    Fetch results in the completion callback.
            //
            // But the Task-plumbing around IAsyncInfo.AsTask *always* fetches results in the completion handler because it has
            // no way of knowing whether or not someone is waiting. So, instead of using ReadAsync here we implement our own IAsyncResult
            // and our own completion handler which can behave differently according to whether it is being used by a blocking IO
            // operation wrapping a BeginRead/EndRead pair, or by an actual async operation based on the old Begin/End pattern.

            if (buffer == null)
                throw new ArgumentNullException(nameof(buffer));

            if (offset < 0)
                throw new ArgumentOutOfRangeException(nameof(offset));

            if (count < 0)
                throw new ArgumentOutOfRangeException(nameof(count));

            if (buffer.Length - offset < count)
                throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InsufficientSpaceInTargetBuffer);

            IInputStream wrtStr = EnsureNotDisposed<IInputStream>();
            EnsureCanRead();

            Debug.Assert(wrtStr != null);

            IBuffer userBuffer = buffer.AsBuffer(offset, count);
            IAsyncOperationWithProgress<IBuffer, uint> asyncReadOperation = wrtStr.ReadAsync(userBuffer,
                                                                                               unchecked((uint)count),
                                                                                               InputStreamOptions.Partial);

            StreamReadAsyncResult asyncResult = new StreamReadAsyncResult(asyncReadOperation, userBuffer, callback, state,
                                                                          processCompletedOperationInCallback: !usedByBlockingWrapper);

            // The StreamReadAsyncResult will set a private instance method to act as a Completed handler for asyncOperation.
            // This will cause a CCW to be created for the delegate and the delegate has a reference to its target, i.e. to
            // asyncResult, so asyncResult will not be collected. If we loose the entire AppDomain, then asyncResult and its CCW
            // will be collected but the stub will remain and the callback will fail gracefully. The underlying buffer is the only
            // item to which we expose a direct pointer and this is properly pinned using a mechanism similar to Overlapped.

            return asyncResult;
        }

        public override int EndRead(IAsyncResult asyncResult)
        {
            if (asyncResult == null)
                throw new ArgumentNullException(nameof(asyncResult));

            EnsureNotDisposed();
            EnsureCanRead();

            StreamOperationAsyncResult streamAsyncResult = asyncResult as StreamOperationAsyncResult;
            if (streamAsyncResult == null)
                throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_UnexpectedAsyncResult, nameof(asyncResult));

            streamAsyncResult.Wait();

            try
            {
                // If the async result did NOT process the async IO operation in its completion handler (i.e. check for errors,
                // cache results etc), then we need to do that processing now. This is to allow blocking-over-async IO operations.
                // See the big comment in BeginRead for details.

                if (!streamAsyncResult.ProcessCompletedOperationInCallback)
                    streamAsyncResult.ProcessCompletedOperation();

                // Rethrow errors caught in the completion callback, if any:
                if (streamAsyncResult.HasError)
                {
                    streamAsyncResult.CloseStreamOperation();
                    streamAsyncResult.ThrowCachedError();
                }

                // Done:

                long bytesCompleted = streamAsyncResult.BytesCompleted;
                Debug.Assert(bytesCompleted <= unchecked((long)int.MaxValue));

                return (int)bytesCompleted;
            }
            finally
            {
                // Closing multiple times is Ok.
                streamAsyncResult.CloseStreamOperation();
            }
        }

#if NET
        [global::System.Runtime.Versioning.SupportedOSPlatform("windows10.0.10240.0")]
#endif
        public override Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
        {
            if (buffer == null)
                throw new ArgumentNullException(nameof(buffer));

            if (offset < 0)
                throw new ArgumentOutOfRangeException(nameof(offset));

            if (count < 0)
                throw new ArgumentOutOfRangeException(nameof(count));

            if (buffer.Length - offset < count)
                throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InsufficientSpaceInTargetBuffer);

            EnsureNotDisposed();
            EnsureCanRead();

            // If already cancelled, bail early:
            cancellationToken.ThrowIfCancellationRequested();

            // State is Ok. Do the actual read:
            return ReadAsyncInternal(buffer, offset, count, cancellationToken);
        }

#if NET
        [global::System.Runtime.Versioning.SupportedOSPlatform("windows10.0.10240.0")]
#endif
        public override int Read(byte[] buffer, int offset, int count)
        {
            // Arguments validation and not-disposed validation are done in BeginRead.

            IAsyncResult asyncResult = BeginRead(buffer, offset, count, null, null, usedByBlockingWrapper: true);
            int bytesread = EndRead(asyncResult);
            return bytesread;
        }

#if NET
        [global::System.Runtime.Versioning.SupportedOSPlatform("windows10.0.10240.0")]
#endif
        public override int ReadByte()
        {
            // EnsureNotDisposed will be called in Read->BeginRead.

            byte[] oneByteArray = OneByteBuffer;

            if (0 == Read(oneByteArray, 0, 1))
                return -1;

            int value = oneByteArray[0];
            return value;
        }

        #endregion Reading


        #region Writing


        public override IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
        {
            return BeginWrite(buffer, offset, count, callback, state, usedByBlockingWrapper: false);
        }

        private IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback callback, object state, bool usedByBlockingWrapper)
        {
            // See the large comment in BeginRead about why we are not using this.WriteAsync,
            // and instead using a custom implementation of IAsyncResult.

            if (buffer == null)
                throw new ArgumentNullException(nameof(buffer));

            if (offset < 0)
                throw new ArgumentOutOfRangeException(nameof(offset));

            if (count < 0)
                throw new ArgumentOutOfRangeException(nameof(count));

            if (buffer.Length - offset < count)
                throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InsufficientArrayElementsAfterOffset);

            IOutputStream wrtStr = EnsureNotDisposed<IOutputStream>();
            EnsureCanWrite();

            Debug.Assert(wrtStr != null);

            IBuffer asyncWriteBuffer = buffer.AsBuffer(offset, count);

            IAsyncOperationWithProgress<uint, uint> asyncWriteOperation = wrtStr.WriteAsync(asyncWriteBuffer);

            StreamWriteAsyncResult asyncResult = new StreamWriteAsyncResult(asyncWriteOperation, callback, state,
                                                                            processCompletedOperationInCallback: !usedByBlockingWrapper);

            // The StreamReadAsyncResult will set a private instance method to act as a Completed handler for asyncOperation.
            // This will cause a CCW to be created for the delegate and the delegate has a reference to its target, i.e. to
            // asyncResult, so asyncResult will not be collected. If we loose the entire AppDomain, then asyncResult and its CCW
            // will be collected but the stub will remain and the callback will fail gracefully. The underlying buffer if the only
            // item to which we expose a direct pointer and this is properly pinned using a mechanism similar to Overlapped.

            return asyncResult;
        }

        public override void EndWrite(IAsyncResult asyncResult)
        {
            if (asyncResult == null)
                throw new ArgumentNullException(nameof(asyncResult));

            EnsureNotDisposed();
            EnsureCanWrite();

            StreamOperationAsyncResult streamAsyncResult = asyncResult as StreamOperationAsyncResult;
            if (streamAsyncResult == null)
                throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_UnexpectedAsyncResult, nameof(asyncResult));

            streamAsyncResult.Wait();

            try
            {
                // If the async result did NOT process the async IO operation in its completion handler (i.e. check for errors,
                // cache results etc), then we need to do that processing now. This is to allow blocking-over-async IO operations.
                // See the big comment in BeginWrite for details.

                if (!streamAsyncResult.ProcessCompletedOperationInCallback)
                    streamAsyncResult.ProcessCompletedOperation();

                // Rethrow errors caught in the completion callback, if any:
                if (streamAsyncResult.HasError)
                {
                    streamAsyncResult.CloseStreamOperation();
                    streamAsyncResult.ThrowCachedError();
                }
            }
            finally
            {
                // Closing multiple times is Ok.
                streamAsyncResult.CloseStreamOperation();
            }
        }

#if NET
        [global::System.Runtime.Versioning.SupportedOSPlatform("windows10.0.10240.0")]
#endif
        public override Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
        {
            if (buffer == null)
                throw new ArgumentNullException(nameof(buffer));

            if (offset < 0)
                throw new ArgumentOutOfRangeException(nameof(offset));

            if (count < 0)
                throw new ArgumentOutOfRangeException(nameof(count));

            if (buffer.Length - offset < count)
                throw new ArgumentException(global::Windows.Storage.Streams.SR.Argument_InsufficientArrayElementsAfterOffset);

            IOutputStream wrtStr = EnsureNotDisposed<IOutputStream>();
            EnsureCanWrite();

            Debug.Assert(wrtStr != null);

            // If already cancelled, bail early:
            cancellationToken.ThrowIfCancellationRequested();

            IBuffer asyncWriteBuffer = buffer.AsBuffer(offset, count);

            IAsyncOperationWithProgress<uint, uint> asyncWriteOperation = wrtStr.WriteAsync(asyncWriteBuffer);
            Task asyncWriteTask = asyncWriteOperation.AsTask(cancellationToken);

            // The underlying IBuffer is the only object to which we expose a direct pointer to native,
            // and that is properly pinned using a mechanism similar to Overlapped.

            return asyncWriteTask;
        }


        public override void Write(byte[] buffer, int offset, int count)
        {
            // Arguments validation and not-disposed validation are done in BeginWrite.

            IAsyncResult asyncResult = BeginWrite(buffer, offset, count, null, null, usedByBlockingWrapper: true);
            EndWrite(asyncResult);
        }


        public override void WriteByte(byte value)
        {
            // EnsureNotDisposed will be called in Write->BeginWrite.

            byte[] oneByteArray = OneByteBuffer;
            oneByteArray[0] = value;

            Write(oneByteArray, 0, 1);
        }

        #endregion Writing


        #region Flushing

        public override void Flush()
        {
            // See the large comment in BeginRead about why we are not using this.FlushAsync,
            // and instead using a custom implementation of IAsyncResult.

            IOutputStream wrtStr = EnsureNotDisposed<IOutputStream>();

            // Calling Flush in a non-writable stream is a no-op, not an error:
            if (!_canWrite)
                return;

            Debug.Assert(wrtStr != null);

            IAsyncOperation<bool> asyncFlushOperation = wrtStr.FlushAsync();
            StreamFlushAsyncResult asyncResult = new StreamFlushAsyncResult(asyncFlushOperation, processCompletedOperationInCallback: false);

            asyncResult.Wait();

            try
            {
                // We got signaled, so process the async Flush operation back on this thread:
                // (This is to allow blocking-over-async IO operations. See the big comment in BeginRead for details.)
                asyncResult.ProcessCompletedOperation();

                // Rethrow errors cached by the async result, if any:
                if (asyncResult.HasError)
                {
                    asyncResult.CloseStreamOperation();
                    asyncResult.ThrowCachedError();
                }
            }
            finally
            {
                // Closing multiple times is Ok.
                asyncResult.CloseStreamOperation();
            }
        }

#if NET
        [global::System.Runtime.Versioning.SupportedOSPlatform("windows10.0.10240.0")]
#endif
        public override Task FlushAsync(CancellationToken cancellationToken)
        {
            IOutputStream wrtStr = EnsureNotDisposed<IOutputStream>();

            // Calling Flush in a non-writable stream is a no-op, not an error:
            if (!_canWrite)
                return Task.CompletedTask;

            Debug.Assert(wrtStr != null);

            cancellationToken.ThrowIfCancellationRequested();

            IAsyncOperation<bool> asyncFlushOperation = wrtStr.FlushAsync();
            Task asyncFlushTask = asyncFlushOperation.AsTask(cancellationToken);
            return asyncFlushTask;
        }

        #endregion Flushing


        #region ReadAsyncInternal implementation
        // Moved it to the end while using Dev10 VS because it does not understand async and everything that follows looses intellisense.
        // Should move this code into the Reading regios once using Dev11 VS becomes the norm.

#if NET
        [global::System.Runtime.Versioning.SupportedOSPlatform("windows10.0.10240.0")]
#endif
        private async Task<int> ReadAsyncInternal(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
        {
            Debug.Assert(buffer != null);
            Debug.Assert(offset >= 0);
            Debug.Assert(count >= 0);
            Debug.Assert(buffer.Length - offset >= count);
            Debug.Assert(_canRead);

            IInputStream wrtStr = EnsureNotDisposed<IInputStream>();

            Debug.Assert(wrtStr != null);

            try
            {
                IBuffer userBuffer = buffer.AsBuffer(offset, count);
                IAsyncOperationWithProgress<IBuffer, uint> asyncReadOperation = wrtStr.ReadAsync(userBuffer,
                                                                                                   unchecked((uint)count),
                                                                                                   InputStreamOptions.Partial);

                IBuffer resultBuffer = await asyncReadOperation.AsTask(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);

                // If cancellationToken was cancelled until now, then we are currently propagating the corresponding cancellation exception.
                // (It will be correctly rethrown by the catch block below and overall we will return a cancelled task.)
                // But if the underlying operation managed to complete before it was cancelled, we want
                // the entire task to complete as well. This is ok as the continuation is very lightweight:

                if (resultBuffer == null)
                    return 0;

                WinRtIOHelper.EnsureResultsInUserBuffer(userBuffer, resultBuffer);

                Debug.Assert(resultBuffer.Length <= unchecked((uint)int.MaxValue));
                return (int)resultBuffer.Length;
            }
            catch (Exception ex)
            {
                // If the interop layer gave us an Exception, we assume that it hit a general/unknown case and wrap it into
                // an IOException as this is what Stream users expect.
                WinRtIOHelper.NativeExceptionToIOExceptionInfo(ex).Throw();
                return 0;
            }
        }
        #endregion ReadAsyncInternal implementation

    }  // class WinRtToNetFxStreamAdapter
}  // namespace

// WinRtToNetFxStreamAdapter.cs
